{
  "pr": "7253",
  "mean_delta_perplexity": 0.020625,
  "mean_perplexity_base": 1.889375,
  "mean_perplexity_pr": 1.91,
  "mean_perplexity_source": 2.1990625,
  "mean_perplexity_base_ast": 2.1246875,
  "mean_perplexity_pr_ast": 2.12375,
  "mean_perplexity_source_ast": 2.28,
  "results": {
    "qwen-coder": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 10:\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n          case :\n            \n            goto label\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.484375,
          "base_ppl": 2.0,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 2.1875,
          "pr_ast_ppl": 2.1875,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its use of structures and named variables, which makes the code easier to understand and maintain compared to the spaghetti code in Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates have similar structures, but Candidate A correctly recovers the for-loop while Candidate B uses a while-goto structure.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 10:\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n          case :\n            \n            goto label\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.484375,
          "base_ppl": 2.0,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 2.1875,
          "pr_ast_ppl": 2.1875,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach with clear variable names, proper use of data structures (like `BOF`, `WIND1`, `SST`, etc.), and cleaner control flow. While both candidates are functionally equivalent, Candidate B's implementation is more organized and adheres to common coding practices, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates have the same structure and complexity, but Candidate A correctly recovers the nested for-loop structure present in the source code.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_signextend-O0.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "source_ast": "{\n  if(){\n    switch(){\n      \n      case :\n        call(, , )\n        \n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if()call(, , )\n        return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  if(){\n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if(){\n          call(, , )\n        }\n        return\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  if(){\n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if(){\n          call(, , )\n        }\n        return\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.921875,
          "base_ppl": 2.171875,
          "pr_ppl": 2.171875,
          "source_ast_ppl": 1.8984375,
          "base_ast_ppl": 1.8046875,
          "pr_ast_ppl": 1.8125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "motivation": "Both candidates have similar structures, but Candidate A maintains the exact structure of the source AST without adding unnecessary elements.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_signextend-O2.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,byte *param_2,long param_3)\n\n{\n  if ((*param_2 & 8) == 0) {\n    switch(param_2[6]) {\n    case 1:\n      return (long)(char)param_3;\n    case 2:\n    case 7:\n    case 10:\n      return (long)(short)param_3;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      return (long)(int)param_3;\n    default:\n      param_3 = -1;\n      if ((*(byte *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\");\n        return -1;\n      }\n    }\n  }\n  return param_3;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,byte *param_2,long param_3)\n\n{\n  if ((*param_2 & 8) == 0) {\n    switch(param_2[6]) {\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      return (long)(int)param_3;\n    case 2:\n    case 7:\n    case 10:\n      return (long)(short)param_3;\n    case 1:\n      return (long)(char)param_3;\n    default:\n      param_3 = -1;\n      if ((*(byte *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\");\n        return -1;\n      }\n    }\n  }\n  return param_3;\n}\n\n",
        "source_ast": "{\n  if(){\n    switch(){\n      \n      case :\n        call(, , )\n        \n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if()call(, , )\n        return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  if(){\n    switch(){\n      case :\n        return\n      case :\n      case :\n      case :\n        return\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        return\n      case :\n        \n        \n        if(){\n          call(, )\n          return\n        }\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  if(){\n    switch(){\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        return\n      case :\n      case :\n      case :\n        return\n      case :\n        return\n      case :\n        \n        \n        if(){\n          call(, )\n          return\n        }\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.921875,
          "base_ppl": 1.7578125,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 1.8984375,
          "base_ast_ppl": 1.828125,
          "pr_ast_ppl": 1.8515625,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach using enums and clear variable names, which makes it easier for a human developer to understand and maintain. While both candidates are semantically equivalent, Candidate B's use of enums and explicit type casting aligns more closely with idiomatic C programming practices.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-file_file_signextend-O3.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,byte *param_2,long param_3)\n\n{\n  if ((*param_2 & 8) == 0) {\n    switch(param_2[6]) {\n    case 1:\n      return (long)(char)param_3;\n    case 2:\n    case 7:\n    case 10:\n      return (long)(short)param_3;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      return (long)(int)param_3;\n    default:\n      param_3 = -1;\n      if ((*(byte *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\");\n        return -1;\n      }\n    }\n  }\n  return param_3;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,byte *param_2,long param_3)\n\n{\n  if ((*param_2 & 8) == 0) {\n    switch(param_2[6]) {\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      return (long)(int)param_3;\n    case 2:\n    case 7:\n    case 10:\n      return (long)(short)param_3;\n    case 1:\n      return (long)(char)param_3;\n    default:\n      param_3 = -1;\n      if ((*(byte *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\");\n        return -1;\n      }\n    }\n  }\n  return param_3;\n}\n\n",
        "source_ast": "{\n  if(){\n    switch(){\n      \n      case :\n        call(, , )\n        \n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if()call(, , )\n        return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  if(){\n    switch(){\n      case :\n        return\n      case :\n      case :\n      case :\n        return\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        return\n      case :\n        \n        \n        if(){\n          call(, )\n          return\n        }\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  if(){\n    switch(){\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        return\n      case :\n      case :\n      case :\n        return\n      case :\n        return\n      case :\n        \n        \n        if(){\n          call(, )\n          return\n        }\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.921875,
          "base_ppl": 1.7578125,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 1.8984375,
          "base_ast_ppl": 1.828125,
          "pr_ast_ppl": 1.8515625,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "motivation": "Candidate A preserves the structure and loop types more accurately compared to Candidate B.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.484375,
          "base_ppl": 1.96875,
          "pr_ppl": 1.96875,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 2.3125,
          "pr_ast_ppl": 2.3125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a more structured approach with meaningful variable names, functions, and a clear control flow, making it more human-like compared to Candidate A's verbose and repetitive code.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n            break;\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              call(, , )\n              \n              \n            case :\n              call(, , )\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.7734375,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.703125,
          "pr_ast_ppl": 2.703125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and follows standard programming practices such as using descriptive variable names, proper indentation, and clear control structures. It also separates concerns better and makes use of higher-level abstractions, making it easier for a human developer to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n            break;\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              call(, , )\n              \n              \n            case :\n              call(, , )\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.7734375,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.703125,
          "pr_ast_ppl": 2.703125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured and readable approach, using clear function names, well-defined variables, and standard control structures like loops and conditionals, which makes it easier for human developers to understand and maintain compared to the highly nested and obfuscated code in Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate A more closely matches the structure and flow of the source code, including maintaining the use of loops and conditional structures without unnecessary complexity.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                \n                \n              case :\n                call(, , )\n                \n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                \n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.96875,
          "base_ppl": 1.9375,
          "pr_ppl": 1.9453125,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.078125,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach with clear function definitions, variable naming, and logical flow, making it easier to understand and maintain compared to Candidate A's more convoluted and repetitive code.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates have similar structures, but Candidate A correctly recovers the `for-loop` construct from the source code, whereas Candidate B does not accurately represent it.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                \n                \n              case :\n                call(, , )\n                \n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                \n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.96875,
          "base_ppl": 1.9453125,
          "pr_ppl": 1.9609375,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.078125,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its use of standard loop constructs and clear logic, which makes it easier to understand compared to the nested goto statements in Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-libxls_xls_isRecordTooSmall-O2.so",
        "function": "xls_isRecordTooSmall",
        "source_code": "int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1, const BYTE* buf) {\n    switch (bof1->id) {\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            return (bof1->size < 2 * sizeof(WORD));\n        case XLS_RECORD_CODEPAGE:\n            return (bof1->size < sizeof(WORD));\n\t\tcase XLS_RECORD_WINDOW1:\n            return (bof1->size < sizeof(WIND1));\n        case XLS_RECORD_SST:\n            return (bof1->size < offsetof(SST, strings));\n        case XLS_RECORD_BOUNDSHEET:\n            return (bof1->size < offsetof(BOUNDSHEET, name));\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n                return (bof1->size < sizeof(XF5));\n            }\n            return (bof1->size < sizeof(XF8));\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n            return (bof1->size < offsetof(FONT, name));\n        case XLS_RECORD_FORMAT:\n            return (bof1->size < offsetof(FORMAT, value));\n        case XLS_RECORD_STYLE:\n            {\n                struct {\n                    unsigned short idx;\n                    unsigned char ident;\n                    unsigned char lvl;\n                } *styl;\n                if(bof1->size < 2) {\n                    return 1;\n                }\n                styl = (void *)buf;\n                if(xlsShortVal(styl->idx) & 0x8000) {\n                    return bof1->size < 4;\n                } else {\n                    if(bof1->size < 3) return 1;\n                    return bof1->size < 3 + styl->ident;\n                }\n            }\n\t\tcase XLS_RECORD_1904:\n            return (bof1->size < sizeof(BYTE));\n        default:\n            break;\n    }\n    return 0;\n}\n",
        "function_base": "\nbool xls_isRecordTooSmall(long param_1,ushort *param_2,short *param_3)\n\n{\n  ushort uVar1;\n  short sVar2;\n  bool bVar3;\n  \n  uVar1 = *param_2;\n  if (uVar1 < 0xfc) {\n    bVar3 = false;\n    switch(uVar1) {\n    case 0x22:\n      bVar3 = param_2[1] == 0;\n      break;\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x41:\n      break;\n    case 0x31:\n      goto switchD_00101137_caseD_31;\n    case 0x3d:\n      bVar3 = param_2[1] < 0x12;\n      break;\n    case 0x42:\nswitchD_00101137_caseD_42:\n      bVar3 = param_2[1] < 2;\n      break;\n    default:\n      if (uVar1 == 0x85) {\n        bVar3 = param_2[1] < 6;\n      }\n      else {\n        bVar3 = false;\n        if (uVar1 == 0xe0) {\n          if (*(char *)(param_1 + 0xc) == '\\0') {\n            bVar3 = param_2[1] < 0x18;\n          }\n          else {\n            bVar3 = param_2[1] < 0x10;\n          }\n        }\n      }\n    }\n  }\n  else {\n    if (0x292 < uVar1) {\n      if (uVar1 == 0x293) {\n        if (param_2[1] < 2) {\n          return true;\n        }\n        sVar2 = xlsShortVal((int)*param_3);\n        uVar1 = param_2[1];\n        if (sVar2 < 0) {\n          return uVar1 < 4;\n        }\n        if (uVar1 < 3) {\n          return true;\n        }\n        return uVar1 < (ushort)(*(byte *)(param_3 + 1) + 3);\n      }\n      if (uVar1 != 0x41e) {\n        if (uVar1 != 0x809) {\n          return false;\n        }\n        return param_2[1] < 4;\n      }\n      goto switchD_00101137_caseD_42;\n    }\n    if (uVar1 == 0xfc) {\n      return param_2[1] < 8;\n    }\n    if (uVar1 != 0x231) {\n      return false;\n    }\nswitchD_00101137_caseD_31:\n    bVar3 = param_2[1] < 0xe;\n  }\n  return bVar3;\n}\n\n",
        "function_pr": "\nbool xls_isRecordTooSmall(long param_1,ushort *param_2,short *param_3)\n\n{\n  ushort uVar1;\n  short sVar2;\n  bool bVar3;\n  \n  uVar1 = *param_2;\n  if (uVar1 < 0xfc) {\n    bVar3 = false;\n    switch(uVar1) {\n    case 0x22:\n      bVar3 = param_2[1] == 0;\n      break;\n    default:\n      if (uVar1 == 0x85) {\n        bVar3 = param_2[1] < 6;\n      }\n      else {\n        bVar3 = false;\n        if (uVar1 == 0xe0) {\n          if (*(char *)(param_1 + 0xc) == '\\0') {\n            bVar3 = param_2[1] < 0x18;\n          }\n          else {\n            bVar3 = param_2[1] < 0x10;\n          }\n        }\n      }\n      break;\n    case 0x31:\n      goto switchD_00101137_caseD_31;\n    case 0x42:\nswitchD_00101137_caseD_42:\n      bVar3 = param_2[1] < 2;\n      break;\n    case 0x3d:\n      bVar3 = param_2[1] < 0x12;\n      break;\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x41:\n      break;\n    }\n  }\n  else {\n    if (0x292 < uVar1) {\n      if (uVar1 == 0x293) {\n        if (param_2[1] < 2) {\n          return true;\n        }\n        sVar2 = xlsShortVal((int)*param_3);\n        uVar1 = param_2[1];\n        if (sVar2 < 0) {\n          return uVar1 < 4;\n        }\n        if (uVar1 < 3) {\n          return true;\n        }\n        return uVar1 < (ushort)(*(byte *)(param_3 + 1) + 3);\n      }\n      if (uVar1 != 0x41e) {\n        if (uVar1 != 0x809) {\n          return false;\n        }\n        return param_2[1] < 4;\n      }\n      goto switchD_00101137_caseD_42;\n    }\n    if (uVar1 == 0xfc) {\n      return param_2[1] < 8;\n    }\n    if (uVar1 != 0x231) {\n      return false;\n    }\nswitchD_00101137_caseD_31:\n    bVar3 = param_2[1] < 0xe;\n  }\n  return bVar3;\n}\n\n",
        "source_ast": "{\n  switch(){\n    case :\n      \n      return\n    case :\n      return\n    case :\n      return\n    case :\n      return\n    case :\n      return\n    case :\n      if(){\n        return\n      }\n      return\n    case :\n    case :\n      return\n    case :\n      return\n    case :\n      {\n        \n        if(){\n          return\n        }\n        \n        if(call()){\n          return\n        }else{\n          if()return\n          return\n        }\n      }\n    case :\n      return\n    case :\n      \n      \n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  if(){\n    \n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        goto label\n      case :\n        \n        \n      case :\n        \n        \n      case :\n        \n        if(){\n          \n        }else{\n          \n          if(){\n            if(){\n              \n            }else{\n              \n            }\n          }\n        }\n    }\n  }else{\n    if(){\n      if(){\n        if(){\n          return\n        }\n        call()\n        \n        if(){\n          return\n        }\n        if(){\n          return\n        }\n        returncall()\n      }\n      if(){\n        if(){\n          return\n        }\n        return\n      }\n      goto label\n    }\n    if(){\n      return\n    }\n    if(){\n      return\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  if(){\n    \n    switch(){\n      case :\n        \n        \n      case :\n        \n        if(){\n          \n        }else{\n          \n          if(){\n            if(){\n              \n            }else{\n              \n            }\n          }\n        }\n        \n      case :\n        goto label\n      case :\n        \n        \n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n    }\n  }else{\n    if(){\n      if(){\n        if(){\n          return\n        }\n        call()\n        \n        if(){\n          return\n        }\n        if(){\n          return\n        }\n        returncall()\n      }\n      if(){\n        if(){\n          return\n        }\n        return\n      }\n      goto label\n    }\n    if(){\n      return\n    }\n    if(){\n      return\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 1.7421875,
          "pr_ppl": 1.7578125,
          "source_ast_ppl": 3.953125,
          "base_ast_ppl": 2.40625,
          "pr_ast_ppl": 2.375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is less complex and more readable due to its use of a switch statement instead of nested if-else structures and better variable naming, making it easier for a human developer to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate A correctly preserves the loop structure of the source code, including the nested if statements within the cases. Candidate B introduces unnecessary complexity with additional if-statements and a goto statement, making it less aligned with the original source.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-libxls_xls_isRecordTooSmall-O3.so",
        "function": "xls_isRecordTooSmall",
        "source_code": "int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1, const BYTE* buf) {\n    switch (bof1->id) {\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            return (bof1->size < 2 * sizeof(WORD));\n        case XLS_RECORD_CODEPAGE:\n            return (bof1->size < sizeof(WORD));\n\t\tcase XLS_RECORD_WINDOW1:\n            return (bof1->size < sizeof(WIND1));\n        case XLS_RECORD_SST:\n            return (bof1->size < offsetof(SST, strings));\n        case XLS_RECORD_BOUNDSHEET:\n            return (bof1->size < offsetof(BOUNDSHEET, name));\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n                return (bof1->size < sizeof(XF5));\n            }\n            return (bof1->size < sizeof(XF8));\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n            return (bof1->size < offsetof(FONT, name));\n        case XLS_RECORD_FORMAT:\n            return (bof1->size < offsetof(FORMAT, value));\n        case XLS_RECORD_STYLE:\n            {\n                struct {\n                    unsigned short idx;\n                    unsigned char ident;\n                    unsigned char lvl;\n                } *styl;\n                if(bof1->size < 2) {\n                    return 1;\n                }\n                styl = (void *)buf;\n                if(xlsShortVal(styl->idx) & 0x8000) {\n                    return bof1->size < 4;\n                } else {\n                    if(bof1->size < 3) return 1;\n                    return bof1->size < 3 + styl->ident;\n                }\n            }\n\t\tcase XLS_RECORD_1904:\n            return (bof1->size < sizeof(BYTE));\n        default:\n            break;\n    }\n    return 0;\n}\n",
        "function_base": "\nbool xls_isRecordTooSmall(long param_1,ushort *param_2,short *param_3)\n\n{\n  ushort uVar1;\n  short sVar2;\n  bool bVar3;\n  \n  uVar1 = *param_2;\n  if (uVar1 < 0xfc) {\n    bVar3 = false;\n    switch(uVar1) {\n    case 0x22:\n      bVar3 = param_2[1] == 0;\n      break;\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x41:\n      break;\n    case 0x31:\n      goto switchD_00101137_caseD_31;\n    case 0x3d:\n      bVar3 = param_2[1] < 0x12;\n      break;\n    case 0x42:\nswitchD_00101137_caseD_42:\n      bVar3 = param_2[1] < 2;\n      break;\n    default:\n      if (uVar1 == 0x85) {\n        bVar3 = param_2[1] < 6;\n      }\n      else {\n        bVar3 = false;\n        if (uVar1 == 0xe0) {\n          if (*(char *)(param_1 + 0xc) == '\\0') {\n            bVar3 = param_2[1] < 0x18;\n          }\n          else {\n            bVar3 = param_2[1] < 0x10;\n          }\n        }\n      }\n    }\n  }\n  else {\n    if (0x292 < uVar1) {\n      if (uVar1 == 0x293) {\n        if (param_2[1] < 2) {\n          return true;\n        }\n        sVar2 = xlsShortVal((int)*param_3);\n        uVar1 = param_2[1];\n        if (sVar2 < 0) {\n          return uVar1 < 4;\n        }\n        if (uVar1 < 3) {\n          return true;\n        }\n        return uVar1 < (ushort)(*(byte *)(param_3 + 1) + 3);\n      }\n      if (uVar1 != 0x41e) {\n        if (uVar1 != 0x809) {\n          return false;\n        }\n        return param_2[1] < 4;\n      }\n      goto switchD_00101137_caseD_42;\n    }\n    if (uVar1 == 0xfc) {\n      return param_2[1] < 8;\n    }\n    if (uVar1 != 0x231) {\n      return false;\n    }\nswitchD_00101137_caseD_31:\n    bVar3 = param_2[1] < 0xe;\n  }\n  return bVar3;\n}\n\n",
        "function_pr": "\nbool xls_isRecordTooSmall(long param_1,ushort *param_2,short *param_3)\n\n{\n  ushort uVar1;\n  short sVar2;\n  bool bVar3;\n  \n  uVar1 = *param_2;\n  if (uVar1 < 0xfc) {\n    bVar3 = false;\n    switch(uVar1) {\n    case 0x22:\n      bVar3 = param_2[1] == 0;\n      break;\n    default:\n      if (uVar1 == 0x85) {\n        bVar3 = param_2[1] < 6;\n      }\n      else {\n        bVar3 = false;\n        if (uVar1 == 0xe0) {\n          if (*(char *)(param_1 + 0xc) == '\\0') {\n            bVar3 = param_2[1] < 0x18;\n          }\n          else {\n            bVar3 = param_2[1] < 0x10;\n          }\n        }\n      }\n      break;\n    case 0x31:\n      goto switchD_00101137_caseD_31;\n    case 0x42:\nswitchD_00101137_caseD_42:\n      bVar3 = param_2[1] < 2;\n      break;\n    case 0x3d:\n      bVar3 = param_2[1] < 0x12;\n      break;\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x41:\n      break;\n    }\n  }\n  else {\n    if (0x292 < uVar1) {\n      if (uVar1 == 0x293) {\n        if (param_2[1] < 2) {\n          return true;\n        }\n        sVar2 = xlsShortVal((int)*param_3);\n        uVar1 = param_2[1];\n        if (sVar2 < 0) {\n          return uVar1 < 4;\n        }\n        if (uVar1 < 3) {\n          return true;\n        }\n        return uVar1 < (ushort)(*(byte *)(param_3 + 1) + 3);\n      }\n      if (uVar1 != 0x41e) {\n        if (uVar1 != 0x809) {\n          return false;\n        }\n        return param_2[1] < 4;\n      }\n      goto switchD_00101137_caseD_42;\n    }\n    if (uVar1 == 0xfc) {\n      return param_2[1] < 8;\n    }\n    if (uVar1 != 0x231) {\n      return false;\n    }\nswitchD_00101137_caseD_31:\n    bVar3 = param_2[1] < 0xe;\n  }\n  return bVar3;\n}\n\n",
        "source_ast": "{\n  switch(){\n    case :\n      \n      return\n    case :\n      return\n    case :\n      return\n    case :\n      return\n    case :\n      return\n    case :\n      if(){\n        return\n      }\n      return\n    case :\n    case :\n      return\n    case :\n      return\n    case :\n      {\n        \n        if(){\n          return\n        }\n        \n        if(call()){\n          return\n        }else{\n          if()return\n          return\n        }\n      }\n    case :\n      return\n    case :\n      \n      \n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  if(){\n    \n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        goto label\n      case :\n        \n        \n      case :\n        \n        \n      case :\n        \n        if(){\n          \n        }else{\n          \n          if(){\n            if(){\n              \n            }else{\n              \n            }\n          }\n        }\n    }\n  }else{\n    if(){\n      if(){\n        if(){\n          return\n        }\n        call()\n        \n        if(){\n          return\n        }\n        if(){\n          return\n        }\n        returncall()\n      }\n      if(){\n        if(){\n          return\n        }\n        return\n      }\n      goto label\n    }\n    if(){\n      return\n    }\n    if(){\n      return\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  if(){\n    \n    switch(){\n      case :\n        \n        \n      case :\n        \n        if(){\n          \n        }else{\n          \n          if(){\n            if(){\n              \n            }else{\n              \n            }\n          }\n        }\n        \n      case :\n        goto label\n      case :\n        \n        \n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n    }\n  }else{\n    if(){\n      if(){\n        if(){\n          return\n        }\n        call()\n        \n        if(){\n          return\n        }\n        if(){\n          return\n        }\n        returncall()\n      }\n      if(){\n        if(){\n          return\n        }\n        return\n      }\n      goto label\n    }\n    if(){\n      return\n    }\n    if(){\n      return\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 1.7421875,
          "pr_ppl": 1.7578125,
          "source_ast_ppl": 3.953125,
          "base_ast_ppl": 2.40625,
          "pr_ast_ppl": 2.375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach using switch cases and clear variable names, making it easier to understand and maintain compared to Candidate A's disorganized code with multiple goto statements.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.71875,
          "pr_ppl": 1.7109375,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.453125,
          "pr_ast_ppl": 2.453125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its structured approach using variables like `temp_key`, `temp_val`, and clear function calls, making it easier to understand and maintain compared to the unstructured and repetitive code in Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.96875,
          "base_ppl": 1.734375,
          "pr_ppl": 1.734375,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 2.921875,
          "pr_ast_ppl": 2.921875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and follows a standard loop structure, making it easier to understand compared to Candidate A which uses multiple labels and goto statements.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.6640625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.40625,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 3.109375,
          "pr_ast_ppl": 3.109375,
          "delta_ppl": 0.125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and follows standard C programming conventions, such as using descriptive variable names and structured control flow, which makes it easier for a human developer to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.6640625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.40625,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 3.109375,
          "pr_ast_ppl": 3.109375,
          "delta_ppl": 0.125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and follows a structured approach, making it easier for developers to understand and maintain compared to Candidate A's more complex and less readable format.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            \n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.734375,
          "base_ppl": 2.234375,
          "pr_ppl": 2.328125,
          "source_ast_ppl": 2.25,
          "base_ast_ppl": 3.359375,
          "pr_ast_ppl": 3.40625,
          "delta_ppl": 0.09375
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach with clear variable names, function signature, and proper use of control structures, making it more readable and easier to understand compared to the unstructured and repetitive nature of Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates have identical structures, so we need to prioritize based on the criteria provided. Since neither loop type is correct in either candidate, we must choose based on nesting depth. Candidate A has a single nested loop structure, while Candidate B has an additional layer of nesting. Therefore, Candidate A is preferred.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            \n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.734375,
          "base_ppl": 2.234375,
          "pr_ppl": 2.328125,
          "source_ast_ppl": 2.25,
          "base_ast_ppl": 3.359375,
          "pr_ast_ppl": 3.40625,
          "delta_ppl": 0.09375
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more readable and follows standard loop structures and clean logic compared to Candidate A's use of goto statements and less structured code.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates have identical control flow structures, but Candidate A correctly uses a ForLoop where the Source uses an equivalent structure. Therefore, it is considered more faithful to the source.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_zsav_read_compressed_data-O0.so",
        "function": "zsav_read_compressed_data",
        "source_code": "readstat_error_t zsav_read_compressed_data(sav_ctx_t *ctx,\n        readstat_error_t (*row_handler)(unsigned char *, size_t, sav_ctx_t *)) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = ctx->io;\n    readstat_off_t data_offset = 0;\n\n    size_t uncompressed_row_len = ctx->var_offset * 8;\n    readstat_off_t uncompressed_offset = 0;\n    unsigned char *uncompressed_row = NULL;\n\n    uLongf uncompressed_block_len = 0;\n    unsigned char *compressed_block = NULL, *uncompressed_block = NULL;\n\n    struct sav_row_stream_s state = { \n        .missing_value = ctx->missing_double,\n        .bias = ctx->bias,\n        .bswap = ctx->bswap };\n\n    struct zheader zheader;\n    struct ztrailer ztrailer;\n    struct ztrailer_entry *ztrailer_entries = NULL;\n\n    int n_blocks = 0;\n    int block_i = 0;\n    int i;\n\n    if (io->read(&zheader, sizeof(struct zheader), io->io_ctx) < sizeof(struct zheader)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    zheader.zheader_ofs = ctx->bswap ? byteswap8(zheader.zheader_ofs) : zheader.zheader_ofs;\n    zheader.ztrailer_ofs = ctx->bswap ? byteswap8(zheader.ztrailer_ofs) : zheader.ztrailer_ofs;\n    zheader.ztrailer_len = ctx->bswap ? byteswap8(zheader.ztrailer_len) : zheader.ztrailer_len;\n\n    if (zheader.zheader_ofs != io->seek(0, READSTAT_SEEK_CUR, io->io_ctx) - sizeof(struct zheader)) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    n_blocks = (zheader.ztrailer_len - 24) / 24;\n\n    if (io->seek(zheader.ztrailer_ofs, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->read(&ztrailer, sizeof(struct ztrailer), io->io_ctx) < sizeof(struct ztrailer)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ztrailer.bias = ctx->bswap ? byteswap8(ztrailer.bias) : ztrailer.bias;\n    ztrailer.zero = ctx->bswap ? byteswap8(ztrailer.zero) : ztrailer.zero;\n    ztrailer.block_size = ctx->bswap ? byteswap4(ztrailer.block_size) : ztrailer.block_size;\n    ztrailer.n_blocks = ctx->bswap ? byteswap4(ztrailer.n_blocks) : ztrailer.n_blocks;\n\n    if (n_blocks != ztrailer.n_blocks) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    if (n_blocks && (ztrailer_entries = readstat_malloc(n_blocks * sizeof(struct ztrailer_entry))) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (io->read(ztrailer_entries, n_blocks * sizeof(struct ztrailer_entry), io->io_ctx) < \n            n_blocks * sizeof(struct ztrailer_entry)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    for (i=0; i<n_blocks; i++) {\n        struct ztrailer_entry *entry = &ztrailer_entries[i];\n\n        entry->uncompressed_ofs = ctx->bswap ? byteswap8(entry->uncompressed_ofs) : entry->uncompressed_ofs;\n        entry->compressed_ofs = ctx->bswap ? byteswap8(entry->compressed_ofs) : entry->compressed_ofs;\n        entry->uncompressed_size = ctx->bswap ? byteswap4(entry->uncompressed_size) : entry->uncompressed_size;\n        entry->compressed_size = ctx->bswap ? byteswap4(entry->compressed_size) : entry->compressed_size;\n    }\n\n    if (uncompressed_row_len && (uncompressed_row = readstat_malloc(uncompressed_row_len)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    while (1) {\n        if (block_i == n_blocks)\n            goto cleanup;\n\n        struct ztrailer_entry *entry = &ztrailer_entries[block_i];\n        if (io->seek(entry->compressed_ofs, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n            retval = READSTAT_ERROR_SEEK;\n            goto cleanup;\n        }\n        if ((compressed_block = readstat_realloc(compressed_block, entry->compressed_size)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if (io->read(compressed_block, entry->compressed_size, io->io_ctx) != entry->compressed_size) {\n            retval = READSTAT_ERROR_READ;\n            goto cleanup;\n        }\n\n        uncompressed_block_len = entry->uncompressed_size;\n        if ((uncompressed_block = readstat_realloc(uncompressed_block, uncompressed_block_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        int status = uncompress(uncompressed_block, &uncompressed_block_len,\n                compressed_block, entry->compressed_size);\n        if (status != Z_OK || uncompressed_block_len != entry->uncompressed_size) {\n            retval = READSTAT_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        block_i++;\n        state.status = SAV_ROW_STREAM_HAVE_DATA;\n        data_offset = 0;\n\n        while (state.status != SAV_ROW_STREAM_NEED_DATA) {\n            state.next_in = &uncompressed_block[data_offset];\n            state.avail_in = uncompressed_block_len - data_offset;\n\n            state.next_out = &uncompressed_row[uncompressed_offset];\n            state.avail_out = uncompressed_row_len - uncompressed_offset;\n\n            sav_decompress_row(&state);\n\n            uncompressed_offset = uncompressed_row_len - state.avail_out;\n            data_offset = uncompressed_block_len - state.avail_in;\n\n            if (state.status == SAV_ROW_STREAM_FINISHED_ROW) {\n                retval = row_handler(uncompressed_row, uncompressed_row_len, ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                uncompressed_offset = 0;\n            }\n\n            if (state.status == SAV_ROW_STREAM_FINISHED_ALL)\n                goto cleanup;\n            if (ctx->row_limit > 0 && ctx->current_row == ctx->row_limit)\n                goto cleanup;\n        }\n    }\n\ncleanup:\n    if (uncompressed_row)\n        free(uncompressed_row);\n    if (ztrailer_entries)\n        free(ztrailer_entries);\n    if (compressed_block)\n        free(compressed_block);\n    if (uncompressed_block)\n        free(uncompressed_block);\n\n    return retval;\n}\n",
        "function_base": "\nint zsav_read_compressed_data(long param_1,code *param_2)\n\n{\n  undefined1 auVar1 [16];\n  int iVar2;\n  int iVar3;\n  ulong uVar4;\n  long lVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined4 local_158;\n  undefined4 local_154;\n  undefined8 local_150;\n  undefined8 local_148;\n  int local_140;\n  undefined4 local_13c;\n  undefined8 local_138;\n  undefined8 local_130;\n  long local_120;\n  undefined8 local_118;\n  long local_110;\n  int local_ec;\n  int local_e8;\n  void *local_e0;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined4 local_c8;\n  int local_c4;\n  long local_c0;\n  undefined8 local_b8;\n  long local_b0;\n  long local_a8;\n  long local_a0;\n  long local_98;\n  long local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined1 auStack_78 [8];\n  undefined4 local_70;\n  uint local_6c;\n  int local_68;\n  void *local_60;\n  void *local_58;\n  long local_50;\n  void *local_48;\n  long local_40;\n  long local_38;\n  long local_30;\n  long local_28;\n  int local_1c;\n  code *local_18;\n  long local_10;\n  \n  local_1c = 0;\n  local_28 = *(long *)(param_1 + 0x48);\n  local_30 = 0;\n  local_38 = (long)(*(int *)(param_1 + 0x1ac) << 3);\n  local_40 = 0;\n  local_48 = (void *)0x0;\n  local_50 = 0;\n  local_58 = (void *)0x0;\n  local_60 = (void *)0x0;\n  local_a8 = 0;\n  local_a0 = 0;\n  local_98 = 0;\n  local_90 = 0;\n  local_88 = *(undefined8 *)(param_1 + 0x1f0);\n  local_80 = *(undefined8 *)(param_1 + 0x218);\n  local_18 = param_2;\n  local_10 = param_1;\n  memset(auStack_78,0,8);\n  local_70 = 0;\n  local_6c = (uint)(*(byte *)(local_10 + 0x22c) & 1);\n  local_68 = 0;\n  local_e0 = (void *)0x0;\n  local_e8 = 0;\n  uVar4 = (**(code **)(local_28 + 0x18))(&local_c0,0x18,*(undefined8 *)(local_28 + 0x28));\n  if (uVar4 < 0x18) {\n    local_1c = 2;\n  }\n  else {\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_110 = local_c0;\n    }\n    else {\n      local_110 = byteswap8(local_c0);\n    }\n    local_c0 = local_110;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_118 = local_b8;\n    }\n    else {\n      local_118 = byteswap8(local_b8);\n    }\n    local_b8 = local_118;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_120 = local_b0;\n    }\n    else {\n      local_120 = byteswap8(local_b0);\n    }\n    lVar6 = local_c0;\n    local_b0 = local_120;\n    lVar5 = (**(code **)(local_28 + 0x10))(0,1,*(undefined8 *)(local_28 + 0x28));\n    if (lVar6 == lVar5 + -0x18) {\n      auVar1._8_8_ = 0;\n      auVar1._0_8_ = local_b0 - 0x18;\n      iVar2 = SUB164(auVar1 / ZEXT816(0x18),0);\n      lVar6 = (**(code **)(local_28 + 0x10))(local_b8,0,*(undefined8 *)(local_28 + 0x28));\n      if (lVar6 == -1) {\n        local_1c = 0xf;\n      }\n      else {\n        uVar4 = (**(code **)(local_28 + 0x18))(&local_d8,0x18,*(undefined8 *)(local_28 + 0x28));\n        if (uVar4 < 0x18) {\n          local_1c = 2;\n        }\n        else {\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_130 = local_d8;\n          }\n          else {\n            local_130 = byteswap8(local_d8);\n          }\n          local_d8 = local_130;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_138 = local_d0;\n          }\n          else {\n            local_138 = byteswap8(local_d0);\n          }\n          local_d0 = local_138;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_13c = local_c8;\n          }\n          else {\n            local_13c = byteswap4(local_c8);\n          }\n          local_c8 = local_13c;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_140 = local_c4;\n          }\n          else {\n            local_140 = byteswap4(local_c4);\n          }\n          local_c4 = local_140;\n          if (iVar2 == local_140) {\n            if ((iVar2 == 0) ||\n               (local_e0 = (void *)readstat_malloc((long)iVar2 * 0x18), local_e0 != (void *)0x0)) {\n              uVar4 = (**(code **)(local_28 + 0x18))\n                                (local_e0,(long)iVar2 * 0x18,*(undefined8 *)(local_28 + 0x28));\n              if (uVar4 < (ulong)((long)iVar2 * 0x18)) {\n                local_1c = 2;\n              }\n              else {\n                for (local_ec = 0; local_ec < iVar2; local_ec = local_ec + 1) {\n                  puVar7 = (undefined8 *)((long)local_e0 + (long)local_ec * 0x18);\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_148 = *puVar7;\n                  }\n                  else {\n                    local_148 = byteswap8(*puVar7);\n                  }\n                  *puVar7 = local_148;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_150 = puVar7[1];\n                  }\n                  else {\n                    local_150 = byteswap8(puVar7[1]);\n                  }\n                  puVar7[1] = local_150;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_154 = *(undefined4 *)(puVar7 + 2);\n                  }\n                  else {\n                    local_154 = byteswap4(*(undefined4 *)(puVar7 + 2));\n                  }\n                  *(undefined4 *)(puVar7 + 2) = local_154;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_158 = *(undefined4 *)((long)puVar7 + 0x14);\n                  }\n                  else {\n                    local_158 = byteswap4(*(undefined4 *)((long)puVar7 + 0x14));\n                  }\n                  *(undefined4 *)((long)puVar7 + 0x14) = local_158;\n                }\n                if ((local_38 == 0) ||\n                   (local_48 = (void *)readstat_malloc(local_38), local_48 != (void *)0x0)) {\n                  while (local_e8 != iVar2) {\n                    lVar6 = (**(code **)(local_28 + 0x10))\n                                      (*(undefined8 *)((long)local_e0 + (long)local_e8 * 0x18 + 8),0\n                                       ,*(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 == -1) {\n                      local_1c = 0xf;\n                      break;\n                    }\n                    local_58 = (void *)readstat_realloc(local_58,(long)*(int *)((long)local_e0 +\n                                                                               (long)local_e8 * 0x18\n                                                                               + 0x14));\n                    if (local_58 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    lVar6 = (**(code **)(local_28 + 0x18))\n                                      (local_58,(long)*(int *)((long)local_e0 +\n                                                              (long)local_e8 * 0x18 + 0x14),\n                                       *(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)) {\n                      local_1c = 2;\n                      break;\n                    }\n                    local_50 = (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10);\n                    local_60 = (void *)readstat_realloc(local_60,local_50);\n                    if (local_60 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    iVar3 = uncompress(local_60,&local_50,local_58,\n                                       (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)\n                                      );\n                    if ((iVar3 != 0) ||\n                       (local_50 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10))) {\n                      local_1c = 5;\n                      break;\n                    }\n                    local_e8 = local_e8 + 1;\n                    local_68 = 1;\n                    local_30 = 0;\n                    while (local_68 != 0) {\n                      local_a8 = (long)local_60 + local_30;\n                      local_a0 = local_50 - local_30;\n                      local_98 = (long)local_48 + local_40;\n                      local_90 = local_38 - local_40;\n                      sav_decompress_row(&local_a8);\n                      local_40 = local_38 - local_90;\n                      local_30 = local_50 - local_a0;\n                      if (local_68 == 2) {\n                        local_1c = (*local_18)(local_48,local_38,local_10);\n                        if (local_1c != 0) goto LAB_00101a68;\n                        local_40 = 0;\n                      }\n                      if ((local_68 == 3) ||\n                         ((0 < *(int *)(local_10 + 0x1b8) &&\n                          (*(int *)(local_10 + 0x1c0) == *(int *)(local_10 + 0x1b8)))))\n                      goto LAB_00101a68;\n                    }\n                  }\n                }\n                else {\n                  local_1c = 3;\n                }\n              }\n            }\n            else {\n              local_1c = 3;\n            }\n          }\n          else {\n            local_1c = 5;\n          }\n        }\n      }\n    }\n    else {\n      local_1c = 5;\n    }\n  }\nLAB_00101a68:\n  if (local_48 != (void *)0x0) {\n    free(local_48);\n  }\n  if (local_e0 != (void *)0x0) {\n    free(local_e0);\n  }\n  if (local_58 != (void *)0x0) {\n    free(local_58);\n  }\n  if (local_60 != (void *)0x0) {\n    free(local_60);\n  }\n  return local_1c;\n}\n\n",
        "function_pr": "\nint zsav_read_compressed_data(long param_1,code *param_2)\n\n{\n  undefined auVar1 [16];\n  int iVar2;\n  int iVar3;\n  ulong uVar4;\n  long lVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined4 local_158;\n  undefined4 local_154;\n  undefined8 local_150;\n  undefined8 local_148;\n  int local_140;\n  undefined4 local_13c;\n  undefined8 local_138;\n  undefined8 local_130;\n  long local_120;\n  undefined8 local_118;\n  long local_110;\n  int local_ec;\n  int local_e8;\n  void *local_e0;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined4 local_c8;\n  int local_c4;\n  long local_c0;\n  undefined8 local_b8;\n  long local_b0;\n  long local_a8;\n  long local_a0;\n  long local_98;\n  long local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined auStack_78 [8];\n  undefined4 local_70;\n  uint local_6c;\n  int local_68;\n  void *local_60;\n  void *local_58;\n  long local_50;\n  void *local_48;\n  long local_40;\n  long local_38;\n  long local_30;\n  long local_28;\n  int local_1c;\n  code *local_18;\n  long local_10;\n  \n  local_1c = 0;\n  local_28 = *(long *)(param_1 + 0x48);\n  local_30 = 0;\n  local_38 = (long)(*(int *)(param_1 + 0x1ac) << 3);\n  local_40 = 0;\n  local_48 = (void *)0x0;\n  local_50 = 0;\n  local_58 = (void *)0x0;\n  local_60 = (void *)0x0;\n  local_a8 = 0;\n  local_a0 = 0;\n  local_98 = 0;\n  local_90 = 0;\n  local_88 = *(undefined8 *)(param_1 + 0x1f0);\n  local_80 = *(undefined8 *)(param_1 + 0x218);\n  local_18 = param_2;\n  local_10 = param_1;\n  memset(auStack_78,0,8);\n  local_70 = 0;\n  local_6c = (uint)(*(byte *)(local_10 + 0x22c) & 1);\n  local_68 = 0;\n  local_e0 = (void *)0x0;\n  local_e8 = 0;\n  uVar4 = (**(code **)(local_28 + 0x18))(&local_c0,0x18,*(undefined8 *)(local_28 + 0x28));\n  if (uVar4 < 0x18) {\n    local_1c = 2;\n  }\n  else {\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_110 = local_c0;\n    }\n    else {\n      local_110 = byteswap8(local_c0);\n    }\n    local_c0 = local_110;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_118 = local_b8;\n    }\n    else {\n      local_118 = byteswap8(local_b8);\n    }\n    local_b8 = local_118;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_120 = local_b0;\n    }\n    else {\n      local_120 = byteswap8(local_b0);\n    }\n    lVar6 = local_c0;\n    local_b0 = local_120;\n    lVar5 = (**(code **)(local_28 + 0x10))(0,1,*(undefined8 *)(local_28 + 0x28));\n    if (lVar6 == lVar5 + -0x18) {\n      auVar1._8_8_ = 0;\n      auVar1._0_8_ = local_b0 - 0x18;\n      iVar2 = SUB164(auVar1 / ZEXT816(0x18),0);\n      lVar6 = (**(code **)(local_28 + 0x10))(local_b8,0,*(undefined8 *)(local_28 + 0x28));\n      if (lVar6 == -1) {\n        local_1c = 0xf;\n      }\n      else {\n        uVar4 = (**(code **)(local_28 + 0x18))(&local_d8,0x18,*(undefined8 *)(local_28 + 0x28));\n        if (uVar4 < 0x18) {\n          local_1c = 2;\n        }\n        else {\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_130 = local_d8;\n          }\n          else {\n            local_130 = byteswap8(local_d8);\n          }\n          local_d8 = local_130;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_138 = local_d0;\n          }\n          else {\n            local_138 = byteswap8(local_d0);\n          }\n          local_d0 = local_138;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_13c = local_c8;\n          }\n          else {\n            local_13c = byteswap4(local_c8);\n          }\n          local_c8 = local_13c;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_140 = local_c4;\n          }\n          else {\n            local_140 = byteswap4(local_c4);\n          }\n          local_c4 = local_140;\n          if (iVar2 == local_140) {\n            if ((iVar2 == 0) ||\n               (local_e0 = (void *)readstat_malloc((long)iVar2 * 0x18), local_e0 != (void *)0x0)) {\n              uVar4 = (**(code **)(local_28 + 0x18))\n                                (local_e0,(long)iVar2 * 0x18,*(undefined8 *)(local_28 + 0x28));\n              if (uVar4 < (ulong)((long)iVar2 * 0x18)) {\n                local_1c = 2;\n              }\n              else {\n                for (local_ec = 0; local_ec < iVar2; local_ec = local_ec + 1) {\n                  puVar7 = (undefined8 *)((long)local_e0 + (long)local_ec * 0x18);\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_148 = *puVar7;\n                  }\n                  else {\n                    local_148 = byteswap8(*puVar7);\n                  }\n                  *puVar7 = local_148;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_150 = puVar7[1];\n                  }\n                  else {\n                    local_150 = byteswap8(puVar7[1]);\n                  }\n                  puVar7[1] = local_150;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_154 = *(undefined4 *)(puVar7 + 2);\n                  }\n                  else {\n                    local_154 = byteswap4(*(undefined4 *)(puVar7 + 2));\n                  }\n                  *(undefined4 *)(puVar7 + 2) = local_154;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_158 = *(undefined4 *)((long)puVar7 + 0x14);\n                  }\n                  else {\n                    local_158 = byteswap4(*(undefined4 *)((long)puVar7 + 0x14));\n                  }\n                  *(undefined4 *)((long)puVar7 + 0x14) = local_158;\n                }\n                if ((local_38 == 0) ||\n                   (local_48 = (void *)readstat_malloc(local_38), local_48 != (void *)0x0)) {\n                  while (local_e8 != iVar2) {\n                    lVar6 = (**(code **)(local_28 + 0x10))\n                                      (*(undefined8 *)((long)local_e0 + (long)local_e8 * 0x18 + 8),0\n                                       ,*(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 == -1) {\n                      local_1c = 0xf;\n                      break;\n                    }\n                    local_58 = (void *)readstat_realloc(local_58,(long)*(int *)((long)local_e0 +\n                                                                               (long)local_e8 * 0x18\n                                                                               + 0x14));\n                    if (local_58 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    lVar6 = (**(code **)(local_28 + 0x18))\n                                      (local_58,(long)*(int *)((long)local_e0 +\n                                                              (long)local_e8 * 0x18 + 0x14),\n                                       *(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)) {\n                      local_1c = 2;\n                      break;\n                    }\n                    local_50 = (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10);\n                    local_60 = (void *)readstat_realloc(local_60,local_50);\n                    if (local_60 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    iVar3 = uncompress(local_60,&local_50,local_58,\n                                       (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)\n                                      );\n                    if ((iVar3 != 0) ||\n                       (local_50 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10))) {\n                      local_1c = 5;\n                      break;\n                    }\n                    local_e8 = local_e8 + 1;\n                    local_68 = 1;\n                    local_30 = 0;\n                    while (local_68 != 0) {\n                      local_a8 = (long)local_60 + local_30;\n                      local_a0 = local_50 - local_30;\n                      local_98 = (long)local_48 + local_40;\n                      local_90 = local_38 - local_40;\n                      sav_decompress_row(&local_a8);\n                      local_40 = local_38 - local_90;\n                      local_30 = local_50 - local_a0;\n                      if (local_68 == 2) {\n                        local_1c = (*local_18)(local_48,local_38,local_10);\n                        if (local_1c != 0) goto LAB_00101a68;\n                        local_40 = 0;\n                      }\n                      if ((local_68 == 3) ||\n                         ((0 < *(int *)(local_10 + 0x1b8) &&\n                          (*(int *)(local_10 + 0x1c0) == *(int *)(local_10 + 0x1b8)))))\n                      goto LAB_00101a68;\n                    }\n                  }\n                }\n                else {\n                  local_1c = 3;\n                }\n              }\n            }\n            else {\n              local_1c = 3;\n            }\n          }\n          else {\n            local_1c = 5;\n          }\n        }\n      }\n    }\n    else {\n      local_1c = 5;\n    }\n  }\nLAB_00101a68:\n  if (local_48 != (void *)0x0) {\n    free(local_48);\n  }\n  if (local_e0 != (void *)0x0) {\n    free(local_e0);\n  }\n  if (local_58 != (void *)0x0) {\n    free(local_58);\n  }\n  if (local_60 != (void *)0x0) {\n    free(local_60);\n  }\n  return local_1c;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  if(){\n    \n    goto label\n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  for(;;){\n    \n    (? call(): )\n    (? call(): )\n    (? call(): )\n    (? call(): )\n  }\n  if(call()){\n    \n    goto label\n  }\n  while(){\n    if()goto label\n    \n    if(call(, , )){\n      \n      goto label\n    }\n    if(call(, )){\n      \n      goto label\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    \n    if(call(, )){\n      \n      goto label\n    }\n    call(, , , )\n    if(){\n      \n      goto label\n    }\n    \n    \n    \n    while(){\n      \n      \n      \n      \n      call()\n      \n      \n      if(){\n        call(, , )\n        if()goto label\n        \n      }\n      if()goto label\n      if()goto label\n    }\n  }\n  if()call()\n  if()call()\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, , )\n  \n  call()\n  \n  \n  \n  call(, , )\n  if(){\n    \n  }else{\n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    \n    call(, , )\n    if(){\n      \n      \n      call(call(), )\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          \n        }else{\n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            if(call()){\n              call(, , )\n              if(call()){\n                \n              }else{\n                for(;;){\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                }\n                if(call()){\n                  while(){\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    \n                    \n                    while(){\n                      \n                      \n                      \n                      \n                      call()\n                      \n                      \n                      if(){\n                        call(, , )\n                        if()goto label\n                        \n                      }\n                      if()goto label\n                    }\n                  }\n                }else{\n                  \n                }\n              }\n            }else{\n              \n            }\n          }else{\n            \n          }\n        }\n      }\n    }else{\n      \n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, , )\n  \n  call()\n  \n  \n  \n  call(, , )\n  if(){\n    \n  }else{\n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    \n    call(, , )\n    if(){\n      \n      \n      call(call(), )\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          \n        }else{\n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            if(call()){\n              call(, , )\n              if(call()){\n                \n              }else{\n                for(;;){\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                }\n                if(call()){\n                  while(){\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    \n                    \n                    while(){\n                      \n                      \n                      \n                      \n                      call()\n                      \n                      \n                      if(){\n                        call(, , )\n                        if()goto label\n                        \n                      }\n                      if()goto label\n                    }\n                  }\n                }else{\n                  \n                }\n              }\n            }else{\n              \n            }\n          }else{\n            \n          }\n        }\n      }\n    }else{\n      \n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 1.53125,
          "pr_ppl": 1.53125,
          "source_ast_ppl": 2.6875,
          "base_ast_ppl": 2.234375,
          "pr_ast_ppl": 2.234375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach with clear variable names and function organization, making it easier to understand and maintain compared to the highly obfuscated and nested structure of Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      \n      do{\n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n        }\n        if()goto label\n        \n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.125,
          "base_ppl": 1.8046875,
          "pr_ppl": 1.8046875,
          "source_ast_ppl": 6.46875,
          "base_ast_ppl": 3.03125,
          "pr_ast_ppl": 3.03125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach with clear variable names, idiomatic C constructs, and a logical flow that mirrors typical C programming practices. While Candidate A maintains the same functionality, its structure is less readable and resembles more of a machine-generated output rather than hand-written code.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      \n      do{\n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n        }\n        if()goto label\n        \n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.125,
          "base_ppl": 1.8046875,
          "pr_ppl": 1.8046875,
          "source_ast_ppl": 6.46875,
          "base_ast_ppl": 3.03125,
          "pr_ast_ppl": 3.03125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its structured loop and clear variable names, despite containing some errors. Candidate A maintains the same logic but lacks proper structuring and type definitions, making it less readable.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate A correctly recovers the source's for-loop structure, whereas Candidate B uses an unnecessary goto statement.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            if(){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            if(){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.734375,
          "base_ppl": 1.890625,
          "pr_ppl": 1.890625,
          "source_ast_ppl": 2.25,
          "base_ast_ppl": 3.015625,
          "pr_ast_ppl": 3.015625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B has a more structured and readable format, with clear variable names and logical control flow, which makes it easier to understand and maintain compared to Candidate A's obfuscated code.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.6640625,
          "base_ppl": 2.03125,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 2.96875,
          "pr_ast_ppl": 2.96875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses clear variable names, follows standard control structures, and includes proper function documentation, making it more human-readable and easier to understand compared to Candidate A's verbose and less structured approach.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_por-O0.so",
        "function": "readstat_parse_por",
        "source_code": "readstat_error_t readstat_parse_por(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    unsigned char reverse_lookup[256];\n    char vanity[5][40];\n    char error_buf[1024];\n\n    por_ctx_t *ctx = por_ctx_init();\n    \n    ctx->handle = parser->handlers;\n    ctx->user_ctx = user_ctx;\n    ctx->io = io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (parser->output_encoding) {\n        if (strcmp(parser->output_encoding, \"UTF-8\") != 0)\n            ctx->converter = iconv_open(parser->output_encoding, \"UTF-8\");\n\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n    \n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n    \n    if (read_bytes(ctx, vanity, sizeof(vanity)) != sizeof(vanity)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    retval = readstat_convert(ctx->file_label, sizeof(ctx->file_label), vanity[1] + 20, 20, NULL);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if (read_bytes(ctx, reverse_lookup, sizeof(reverse_lookup)) != sizeof(reverse_lookup)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n    \n    ctx->space = reverse_lookup[126];\n\n    int i;\n\n    for (i=0; i<256; i++) {\n        if (por_ascii_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_ascii_lookup[i];\n        } else if (por_unicode_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_unicode_lookup[i];\n        }\n    }\n\n    ctx->byte2unicode[reverse_lookup[64]] = por_unicode_lookup[64];\n\n    unsigned char check[8];\n    char tr_check[8];\n    \n    if (read_bytes(ctx, check, sizeof(check)) != sizeof(check)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ssize_t encoded_len;\n\n    if ((encoded_len = por_utf8_encode(check, sizeof(check), tr_check, sizeof(tr_check), ctx->byte2unicode)) == -1) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error converting check string: %.*s\", (int)sizeof(check), check);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_CONVERT;\n        goto cleanup;\n    }\n\n    if (strncmp(\"SPSSPORT\", tr_check, encoded_len) != 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n    \n    ctx->var_offset = -1;\n    \n    char string[256];\n\n    retval = read_version_and_timestamp(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n\n    while (1) {\n        uint16_t tr_tag = read_tag(ctx);\n        switch (tr_tag) {\n            case '1': /* product ID */\n            case '2': /* author ID */\n            case '3': /* sub-product ID */\n                retval = read_string(ctx, string, sizeof(string));\n                break;\n            case '4': /* variable count */\n                retval = read_variable_count_record(ctx);\n                break;\n            case '5': /* precision */\n                retval = read_precision_record(ctx);\n                break;\n            case '6': /* case weight */\n                retval = read_case_weight_record(ctx);\n                break;\n            case '7': /* variable */\n                retval = read_variable_record(ctx);\n                break;\n            case '8': /* missing value */\n                retval = read_missing_value_record(ctx);\n                break;\n            case 'B': /* missing value range */\n                retval = read_missing_value_range_record(ctx);\n                break;\n            case '9': /* LO THRU x */\n                retval = read_missing_value_lo_range_record(ctx);\n                break;\n            case 'A': /* x THRU HI */\n                retval = read_missing_value_hi_range_record(ctx);\n                break;\n            case 'C': /* variable label */\n                retval = read_variable_label_record(ctx);\n                break;\n            case 'D': /* value label */\n                retval = read_value_label_record(ctx);\n                break;\n            case 'E': /* document record */\n                retval = read_document_record(ctx);\n                break;\n            case 'F': /* file data */\n                if (ctx->var_offset != ctx->var_count - 1) {\n                    retval = READSTAT_ERROR_COLUMN_COUNT_MISMATCH;\n                    goto cleanup;\n                }\n\n                retval = handle_variables(ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                if (ctx->handle.value) {\n                    retval = read_por_file_data(ctx);\n                }\n                goto cleanup;\n            default:\n                retval = READSTAT_ERROR_PARSE;\n                goto cleanup;\n        }\n        if (retval != READSTAT_OK)\n            break;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n    por_ctx_free(ctx);\n    \n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_por(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  iconv_t pvVar3;\n  long lVar4;\n  undefined1 local_738 [264];\n  size_t local_630;\n  char local_624 [8];\n  undefined1 local_61c [8];\n  int local_614;\n  void *local_610;\n  char local_608 [1024];\n  undefined1 local_208 [60];\n  undefined1 auStack_1cc [148];\n  byte local_138 [264];\n  undefined8 *local_30;\n  int local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_24 = 0;\n  local_30 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_610 = (void *)por_ctx_init();\n  memcpy(local_610,local_10,0x40);\n  *(undefined8 *)((long)local_610 + 0x48) = local_20;\n  *(undefined8 **)((long)local_610 + 0x58) = local_30;\n  *(int *)((long)local_610 + 0x2d0) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)local_610 + 0x2d4) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  if (*(long *)((long)local_10 + 0x50) != 0) {\n    iVar2 = strcmp(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n    if (iVar2 != 0) {\n      pvVar3 = iconv_open(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n      *(iconv_t *)((long)local_610 + 0x2a8) = pvVar3;\n    }\n    if (*(long *)((long)local_610 + 0x2a8) == -1) {\n      *(undefined8 *)((long)local_610 + 0x2a8) = 0;\n      local_24 = 7;\n      goto LAB_00101f5b;\n    }\n  }\n  iVar2 = (*(code *)*local_30)(local_18,local_30[5]);\n  if (iVar2 == -1) {\n    local_24 = 1;\n  }\n  else {\n    lVar4 = (*(code *)local_30[2])(0,2,local_30[5]);\n    *(long *)((long)local_610 + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_24 = 0xf;\n    }\n    else {\n      lVar4 = (*(code *)local_30[2])(0,0,local_30[5]);\n      if (lVar4 == -1) {\n        local_24 = 0xf;\n      }\n      else {\n        lVar4 = read_bytes(local_610,local_208,200);\n        if (lVar4 == 200) {\n          local_24 = readstat_convert((long)local_610 + 0x89,0x15,auStack_1cc,0x14,0);\n          if (local_24 == 0) {\n            lVar4 = read_bytes(local_610,local_138,0x100);\n            if (lVar4 == 0x100) {\n              *(byte *)((long)local_610 + 0x60) = local_138[0x7e];\n              for (local_614 = 0; local_614 < 0x100; local_614 = local_614 + 1) {\n                if (PTR_por_ascii_lookup_00105fe8[local_614] == '\\0') {\n                  if (*(short *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2) != 0) {\n                    *(undefined2 *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                         *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2);\n                  }\n                }\n                else {\n                  *(short *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                       (short)(char)PTR_por_ascii_lookup_00105fe8[local_614];\n                }\n              }\n              *(undefined2 *)((long)local_610 + (ulong)local_138[0x40] * 2 + 0x9e) =\n                   *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + 0x80);\n              lVar4 = read_bytes(local_610,local_61c,8);\n              if (lVar4 == 8) {\n                local_630 = por_utf8_encode(local_61c,8,local_624,8,(long)local_610 + 0x9e);\n                if (local_630 == 0xffffffffffffffff) {\n                  if (*(long *)((long)local_610 + 0x30) != 0) {\n                    snprintf(local_608,0x400,\"Error converting check string: %.*s\",8,local_61c);\n                    (**(code **)((long)local_610 + 0x30))\n                              (local_608,*(undefined8 *)((long)local_610 + 0x48));\n                  }\n                  local_24 = 0x10;\n                }\n                else {\n                  iVar2 = strncmp(\"SPSSPORT\",local_624,local_630);\n                  if (iVar2 == 0) {\n                    *(undefined4 *)((long)local_610 + 0x2cc) = 0xffffffff;\n                    local_24 = read_version_and_timestamp(local_610);\n                    if (local_24 == 0) {\n                      local_24 = 0;\n                      do {\n                        uVar1 = read_tag(local_610);\n                        switch(uVar1) {\n                        case 0x31:\n                        case 0x32:\n                        case 0x33:\n                          local_24 = read_string(local_610,local_738,0x100);\n                          break;\n                        case 0x34:\n                          local_24 = read_variable_count_record(local_610);\n                          break;\n                        case 0x35:\n                          local_24 = read_precision_record(local_610);\n                          break;\n                        case 0x36:\n                          local_24 = read_case_weight_record(local_610);\n                          break;\n                        case 0x37:\n                          local_24 = read_variable_record(local_610);\n                          break;\n                        case 0x38:\n                          local_24 = read_missing_value_record(local_610);\n                          break;\n                        case 0x39:\n                          local_24 = read_missing_value_lo_range_record(local_610);\n                          break;\n                        default:\n                          local_24 = 5;\n                          goto LAB_00101f5b;\n                        case 0x41:\n                          local_24 = read_missing_value_hi_range_record(local_610);\n                          break;\n                        case 0x42:\n                          local_24 = read_missing_value_range_record(local_610);\n                          break;\n                        case 0x43:\n                          local_24 = read_variable_label_record(local_610);\n                          break;\n                        case 0x44:\n                          local_24 = read_value_label_record(local_610);\n                          break;\n                        case 0x45:\n                          local_24 = read_document_record(local_610);\n                          break;\n                        case 0x46:\n                          if (*(int *)((long)local_610 + 0x2cc) ==\n                              *(int *)((long)local_610 + 0x2c8) + -1) {\n                            local_24 = handle_variables(local_610);\n                            if ((local_24 == 0) && (*(long *)((long)local_610 + 0x20) != 0)) {\n                              local_24 = read_por_file_data(local_610);\n                            }\n                          }\n                          else {\n                            local_24 = 8;\n                          }\n                          goto LAB_00101f5b;\n                        }\n                      } while (local_24 == 0);\n                    }\n                  }\n                  else {\n                    local_24 = 5;\n                  }\n                }\n              }\n              else {\n                local_24 = 2;\n              }\n            }\n            else {\n              local_24 = 2;\n            }\n          }\n        }\n        else {\n          local_24 = 2;\n        }\n      }\n    }\n  }\nLAB_00101f5b:\n  (*(code *)local_30[1])(local_30[5]);\n  por_ctx_free(local_610);\n  return local_24;\n}\n\n",
        "function_pr": "\nint readstat_parse_por(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  iconv_t pvVar3;\n  long lVar4;\n  undefined local_738 [264];\n  size_t local_630;\n  char local_624 [8];\n  undefined local_61c [8];\n  int local_614;\n  void *local_610;\n  char local_608 [1024];\n  undefined local_208 [60];\n  undefined auStack_1cc [148];\n  byte local_138 [264];\n  undefined8 *local_30;\n  int local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_24 = 0;\n  local_30 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_610 = (void *)por_ctx_init();\n  memcpy(local_610,local_10,0x40);\n  *(undefined8 *)((long)local_610 + 0x48) = local_20;\n  *(undefined8 **)((long)local_610 + 0x58) = local_30;\n  *(int *)((long)local_610 + 0x2d0) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)local_610 + 0x2d4) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  if (*(long *)((long)local_10 + 0x50) != 0) {\n    iVar2 = strcmp(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n    if (iVar2 != 0) {\n      pvVar3 = iconv_open(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n      *(iconv_t *)((long)local_610 + 0x2a8) = pvVar3;\n    }\n    if (*(long *)((long)local_610 + 0x2a8) == -1) {\n      *(undefined8 *)((long)local_610 + 0x2a8) = 0;\n      local_24 = 7;\n      goto LAB_00101f5b;\n    }\n  }\n  iVar2 = (*(code *)*local_30)(local_18,local_30[5]);\n  if (iVar2 == -1) {\n    local_24 = 1;\n  }\n  else {\n    lVar4 = (*(code *)local_30[2])(0,2,local_30[5]);\n    *(long *)((long)local_610 + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_24 = 0xf;\n    }\n    else {\n      lVar4 = (*(code *)local_30[2])(0,0,local_30[5]);\n      if (lVar4 == -1) {\n        local_24 = 0xf;\n      }\n      else {\n        lVar4 = read_bytes(local_610,local_208,200);\n        if (lVar4 == 200) {\n          local_24 = readstat_convert((long)local_610 + 0x89,0x15,auStack_1cc,0x14,0);\n          if (local_24 == 0) {\n            lVar4 = read_bytes(local_610,local_138,0x100);\n            if (lVar4 == 0x100) {\n              *(byte *)((long)local_610 + 0x60) = local_138[0x7e];\n              for (local_614 = 0; local_614 < 0x100; local_614 = local_614 + 1) {\n                if (PTR_por_ascii_lookup_00105fe8[local_614] == '\\0') {\n                  if (*(short *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2) != 0) {\n                    *(undefined2 *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                         *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2);\n                  }\n                }\n                else {\n                  *(short *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                       (short)(char)PTR_por_ascii_lookup_00105fe8[local_614];\n                }\n              }\n              *(undefined2 *)((long)local_610 + (ulong)local_138[0x40] * 2 + 0x9e) =\n                   *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + 0x80);\n              lVar4 = read_bytes(local_610,local_61c,8);\n              if (lVar4 == 8) {\n                local_630 = por_utf8_encode(local_61c,8,local_624,8,(long)local_610 + 0x9e);\n                if (local_630 == 0xffffffffffffffff) {\n                  if (*(long *)((long)local_610 + 0x30) != 0) {\n                    snprintf(local_608,0x400,\"Error converting check string: %.*s\",8,local_61c);\n                    (**(code **)((long)local_610 + 0x30))\n                              (local_608,*(undefined8 *)((long)local_610 + 0x48));\n                  }\n                  local_24 = 0x10;\n                }\n                else {\n                  iVar2 = strncmp(\"SPSSPORT\",local_624,local_630);\n                  if (iVar2 == 0) {\n                    *(undefined4 *)((long)local_610 + 0x2cc) = 0xffffffff;\n                    local_24 = read_version_and_timestamp(local_610);\n                    if (local_24 == 0) {\n                      local_24 = 0;\n                      do {\n                        uVar1 = read_tag(local_610);\n                        switch(uVar1) {\n                        case 0x31:\n                        case 0x32:\n                        case 0x33:\n                          local_24 = read_string(local_610,local_738,0x100);\n                          break;\n                        case 0x34:\n                          local_24 = read_variable_count_record(local_610);\n                          break;\n                        case 0x35:\n                          local_24 = read_precision_record(local_610);\n                          break;\n                        case 0x36:\n                          local_24 = read_case_weight_record(local_610);\n                          break;\n                        case 0x37:\n                          local_24 = read_variable_record(local_610);\n                          break;\n                        case 0x38:\n                          local_24 = read_missing_value_record(local_610);\n                          break;\n                        case 0x42:\n                          local_24 = read_missing_value_range_record(local_610);\n                          break;\n                        case 0x39:\n                          local_24 = read_missing_value_lo_range_record(local_610);\n                          break;\n                        case 0x41:\n                          local_24 = read_missing_value_hi_range_record(local_610);\n                          break;\n                        case 0x43:\n                          local_24 = read_variable_label_record(local_610);\n                          break;\n                        case 0x44:\n                          local_24 = read_value_label_record(local_610);\n                          break;\n                        case 0x45:\n                          local_24 = read_document_record(local_610);\n                          break;\n                        case 0x46:\n                          if (*(int *)((long)local_610 + 0x2cc) ==\n                              *(int *)((long)local_610 + 0x2c8) + -1) {\n                            local_24 = handle_variables(local_610);\n                            if ((local_24 == 0) && (*(long *)((long)local_610 + 0x20) != 0)) {\n                              local_24 = read_por_file_data(local_610);\n                            }\n                          }\n                          else {\n                            local_24 = 8;\n                          }\n                          goto LAB_00101f5b;\n                        default:\n                          local_24 = 5;\n                          goto LAB_00101f5b;\n                        }\n                      } while (local_24 == 0);\n                    }\n                  }\n                  else {\n                    local_24 = 5;\n                  }\n                }\n              }\n              else {\n                local_24 = 2;\n              }\n            }\n            else {\n              local_24 = 2;\n            }\n          }\n        }\n        else {\n          local_24 = 2;\n        }\n      }\n    }\n  }\nLAB_00101f5b:\n  (*(code *)local_30[1])(local_30[5]);\n  por_ctx_free(local_610);\n  return local_24;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  if()\n  if(){\n    if(call(, ))call(, )\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , , , )\n  if()goto label\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  for(;;){\n    if(){\n      \n    }elseif(){\n      \n    }\n  }\n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , , , )){\n    if(){\n      call(, , , , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  call()\n  if()goto label\n  while(){\n    call()\n    switch(){\n      case :\n      \n      case :\n      \n      case :\n        \n        call(, , )\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        if(){\n          \n          goto label\n        }\n        call()\n        if()goto label\n        if(){\n          call()\n        }\n        goto label\n      case :\n        \n        \n        goto label\n    }\n    if()\n  }\n  call()\n  call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, , )\n  \n  \n  \n  if(){\n    \n  }\n  if(){\n    call(, )\n    if(){\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n    }else{\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          call(, , , , )\n          if(){\n            call(, , )\n            if(){\n              \n              for(;;){\n                if(){\n                  if(){\n                    \n                  }\n                }else{\n                  \n                }\n              }\n              \n              call(, , )\n              if(){\n                call(, , , , )\n                if(){\n                  if(){\n                    call(, , , , )\n                    call(, )\n                  }\n                  \n                }else{\n                  call(, , )\n                  if(){\n                    \n                    call()\n                    if(){\n                      \n                      do{\n                        call()\n                        switch(){\n                          case :\n                          case :\n                          case :\n                            call(, , )\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            \n                            \n                            goto label\n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            if(){\n                              call()\n                              if(){\n                                call()\n                              }\n                            }else{\n                              \n                            }\n                            goto label\n                        }\n                      }while()\n                    }\n                  }else{\n                    \n                  }\n                }\n              }else{\n                \n              }\n            }else{\n              \n            }\n          }\n        }else{\n          \n        }\n      }\n    }\n  }\n  call()\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, , )\n  \n  \n  \n  if(){\n    \n  }\n  if(){\n    call(, )\n    if(){\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n    }else{\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          call(, , , , )\n          if(){\n            call(, , )\n            if(){\n              \n              for(;;){\n                if(){\n                  if(){\n                    \n                  }\n                }else{\n                  \n                }\n              }\n              \n              call(, , )\n              if(){\n                call(, , , , )\n                if(){\n                  if(){\n                    call(, , , , )\n                    call(, )\n                  }\n                  \n                }else{\n                  call(, , )\n                  if(){\n                    \n                    call()\n                    if(){\n                      \n                      do{\n                        call()\n                        switch(){\n                          case :\n                          case :\n                          case :\n                            call(, , )\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            if(){\n                              call()\n                              if(){\n                                call()\n                              }\n                            }else{\n                              \n                            }\n                            goto label\n                          case :\n                            \n                            \n                            goto label\n                        }\n                      }while()\n                    }\n                  }else{\n                    \n                  }\n                }\n              }else{\n                \n              }\n            }else{\n              \n            }\n          }\n        }else{\n          \n        }\n      }\n    }\n  }\n  call()\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 1.8828125,
          "pr_ppl": 1.8828125,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.421875,
          "pr_ast_ppl": 2.421875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach with clear function definitions and logical flow, making it easier to understand and maintain compared to Candidate A which is essentially a copy-paste of the original code without any meaningful changes.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_dta_ctx_init-O0.so",
        "function": "dta_ctx_init",
        "source_code": "readstat_error_t dta_ctx_init(dta_ctx_t *ctx, uint32_t nvar, uint64_t nobs,\n        unsigned char byteorder, unsigned char ds_format,\n        const char *input_encoding, const char *output_encoding) {\n    readstat_error_t retval = READSTAT_OK;\n    int machine_byteorder = DTA_HILO;\n    if (ds_format < DTA_MIN_VERSION || ds_format > DTA_MAX_VERSION)\n        return READSTAT_ERROR_UNSUPPORTED_FILE_FORMAT_VERSION;\n\n    if (machine_is_little_endian()) {\n        machine_byteorder = DTA_LOHI;\n    }\n\n    ctx->bswap = (byteorder != machine_byteorder);\n    ctx->ds_format = ds_format;\n    ctx->endianness = byteorder == DTA_LOHI ? READSTAT_ENDIAN_LITTLE : READSTAT_ENDIAN_BIG;\n\n    ctx->nvar = nvar;\n    ctx->nobs = nobs;\n\n    if (ctx->nvar) {\n        if ((ctx->variables = readstat_calloc(ctx->nvar, sizeof(readstat_variable_t *))) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n    }\n\n    ctx->machine_is_twos_complement = READSTAT_MACHINE_IS_TWOS_COMPLEMENT;\n\n    if (ds_format < 105) {\n        ctx->fmtlist_entry_len = 7;\n    } else if (ds_format < 114) {\n        ctx->fmtlist_entry_len = 12;\n    } else if (ds_format < 118) {\n        ctx->fmtlist_entry_len = 49;\n    } else {\n        ctx->fmtlist_entry_len = 57;\n    }\n    \n    if (ds_format >= 117) {\n        ctx->typlist_version = 117;\n    } else if (ds_format >= 111) {\n        ctx->typlist_version = 111;\n    } else {\n        ctx->typlist_version = 0;\n    }\n\n    if (ds_format >= 118) {\n        ctx->data_label_len_len = 2;\n        ctx->strl_v_len = 2;\n        ctx->strl_o_len = 6;\n    } else if (ds_format >= 117) {\n        ctx->data_label_len_len = 1;\n        ctx->strl_v_len = 4;\n        ctx->strl_o_len = 4;\n    }\n\n    if (ds_format < 105) {\n        ctx->expansion_len_len = 0;\n    } else if (ds_format < 110) {\n        ctx->expansion_len_len = 2;\n    } else {\n        ctx->expansion_len_len = 4;\n    }\n    \n    if (ds_format < 110) {\n        ctx->lbllist_entry_len = 9;\n        ctx->variable_name_len = 9;\n        ctx->ch_metadata_len = 9;\n    } else if (ds_format < 118) {\n        ctx->lbllist_entry_len = 33;\n        ctx->variable_name_len = 33;\n        ctx->ch_metadata_len = 33;\n    } else {\n        ctx->lbllist_entry_len = 129;\n        ctx->variable_name_len = 129;\n        ctx->ch_metadata_len = 129;\n    }\n\n    if (ds_format < 108) {\n        ctx->variable_labels_entry_len = 32;\n        ctx->data_label_len = 32;\n    } else if (ds_format < 118) {\n        ctx->variable_labels_entry_len = 81;\n        ctx->data_label_len = 81;\n    } else {\n        ctx->variable_labels_entry_len = 321;\n        ctx->data_label_len = 321;\n    }\n\n    if (ds_format < 105) {\n        ctx->timestamp_len = 0;\n        ctx->value_label_table_len_len = 2;\n        ctx->value_label_table_labname_len = 12;\n        ctx->value_label_table_padding_len = 2;\n    } else {\n        ctx->timestamp_len = 18;\n        ctx->value_label_table_len_len = 4;\n        if (ds_format < 118) {\n            ctx->value_label_table_labname_len = 33;\n        } else {\n            ctx->value_label_table_labname_len = 129;\n        }\n        ctx->value_label_table_padding_len = 3;\n    }\n\n    if (ds_format < 117) {\n        ctx->typlist_entry_len = 1;\n        ctx->file_is_xmlish = 0;\n    } else {\n        ctx->typlist_entry_len = 2;\n        ctx->file_is_xmlish = 1;\n    }\n\n    if (ds_format < 113) {\n        ctx->max_int8 = DTA_OLD_MAX_INT8;\n        ctx->max_int16 = DTA_OLD_MAX_INT16;\n        ctx->max_int32 = DTA_OLD_MAX_INT32;\n        ctx->max_float = DTA_OLD_MAX_FLOAT;\n        ctx->max_double = DTA_OLD_MAX_DOUBLE;\n    } else {\n        ctx->max_int8 = DTA_113_MAX_INT8;\n        ctx->max_int16 = DTA_113_MAX_INT16;\n        ctx->max_int32 = DTA_113_MAX_INT32;\n        ctx->max_float = DTA_113_MAX_FLOAT;\n        ctx->max_double = DTA_113_MAX_DOUBLE;\n\n        ctx->supports_tagged_missing = 1;\n    }\n\n    if (output_encoding) {\n        if (input_encoding) {\n            ctx->converter = iconv_open(output_encoding, input_encoding);\n        } else if (ds_format < 118) {\n            ctx->converter = iconv_open(output_encoding, \"WINDOWS-1252\");\n        } else if (strcmp(output_encoding, \"UTF-8\") != 0) {\n            ctx->converter = iconv_open(output_encoding, \"UTF-8\");\n        }\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n\n    if (ds_format < 119) {\n        ctx->srtlist_len = (ctx->nvar + 1) * sizeof(int16_t);\n    } else {\n        ctx->srtlist_len = (ctx->nvar + 1) * sizeof(int32_t);\n    }\n\n    if ((ctx->srtlist = readstat_malloc(ctx->srtlist_len)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->nvar > 0) {\n        ctx->typlist_len = ctx->nvar * sizeof(uint16_t);\n        ctx->varlist_len = ctx->variable_name_len * ctx->nvar * sizeof(char);\n        ctx->fmtlist_len = ctx->fmtlist_entry_len * ctx->nvar * sizeof(char);\n        ctx->lbllist_len = ctx->lbllist_entry_len * ctx->nvar * sizeof(char);\n        ctx->variable_labels_len = ctx->variable_labels_entry_len * ctx->nvar * sizeof(char);\n\n        if ((ctx->typlist = readstat_malloc(ctx->typlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->varlist = readstat_malloc(ctx->varlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->fmtlist = readstat_malloc(ctx->fmtlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->lbllist = readstat_malloc(ctx->lbllist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->variable_labels = readstat_malloc(ctx->variable_labels_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n    }\n\n    ctx->initialized = 1;\n\ncleanup:\n    return retval;\n}\n",
        "function_base": "\nundefined4\ndta_ctx_init(long param_1,undefined4 param_2,undefined8 param_3,char param_4,byte param_5,\n            char *param_6,char *param_7)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  iconv_t pvVar4;\n  undefined4 uVar5;\n  \n  cVar1 = '\\x01';\n  if ((param_5 < 0x68) || (0x77 < param_5)) {\n    return 0x18;\n  }\n  iVar2 = machine_is_little_endian();\n  if (iVar2 != 0) {\n    cVar1 = '\\x02';\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfe | param_4 != cVar1;\n  *(uint *)(param_1 + 0x108) = (uint)param_5;\n  uVar5 = 2;\n  if (param_4 == '\\x02') {\n    uVar5 = 1;\n  }\n  *(undefined4 *)(param_1 + 0x170) = uVar5;\n  *(undefined4 *)(param_1 + 0x10c) = param_2;\n  *(undefined8 *)(param_1 + 0x110) = param_3;\n  if (*(int *)(param_1 + 0x10c) != 0) {\n    lVar3 = readstat_calloc((long)*(int *)(param_1 + 0x10c),8);\n    *(long *)(param_1 + 0x168) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfd;\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xa0) = 7;\n  }\n  else if (param_5 < 0x72) {\n    *(undefined8 *)(param_1 + 0xa0) = 0xc;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa0) = 0x31;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa0) = 0x39;\n  }\n  if (param_5 < 0x75) {\n    if (param_5 < 0x6f) {\n      *(undefined1 *)(param_1 + 0x28) = 0;\n    }\n    else {\n      *(undefined1 *)(param_1 + 0x28) = 0x6f;\n    }\n  }\n  else {\n    *(undefined1 *)(param_1 + 0x28) = 0x75;\n  }\n  if (param_5 < 0x76) {\n    if (0x74 < param_5) {\n      *(undefined8 *)(param_1 + 0x10) = 1;\n      *(undefined8 *)(param_1 + 0xe0) = 4;\n      *(undefined8 *)(param_1 + 0xe8) = 4;\n    }\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x10) = 2;\n    *(undefined8 *)(param_1 + 0xe0) = 2;\n    *(undefined8 *)(param_1 + 0xe8) = 6;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xb8) = 0;\n  }\n  else if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xb8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb8) = 4;\n  }\n  if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xa8) = 9;\n    *(undefined8 *)(param_1 + 0x98) = 9;\n    *(undefined8 *)(param_1 + 0xc0) = 9;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa8) = 0x21;\n    *(undefined8 *)(param_1 + 0x98) = 0x21;\n    *(undefined8 *)(param_1 + 0xc0) = 0x21;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa8) = 0x81;\n    *(undefined8 *)(param_1 + 0x98) = 0x81;\n    *(undefined8 *)(param_1 + 0xc0) = 0x81;\n  }\n  if (param_5 < 0x6c) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x20;\n    *(undefined8 *)(param_1 + 8) = 0x20;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x51;\n    *(undefined8 *)(param_1 + 8) = 0x51;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb0) = 0x141;\n    *(undefined8 *)(param_1 + 8) = 0x141;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n    *(undefined8 *)(param_1 + 200) = 2;\n    *(undefined8 *)(param_1 + 0xd0) = 0xc;\n    *(undefined8 *)(param_1 + 0xd8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x20) = 0x12;\n    *(undefined8 *)(param_1 + 200) = 4;\n    if (param_5 < 0x76) {\n      *(undefined8 *)(param_1 + 0xd0) = 0x21;\n    }\n    else {\n      *(undefined8 *)(param_1 + 0xd0) = 0x81;\n    }\n    *(undefined8 *)(param_1 + 0xd8) = 3;\n  }\n  if (param_5 < 0x75) {\n    *(undefined8 *)(param_1 + 0x30) = 1;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x30) = 2;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb | 4;\n  }\n  if (param_5 < 0x71) {\n    *(undefined1 *)(param_1 + 0x139) = 0x7e;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7ffe;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7ffffffe;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n  }\n  else {\n    *(undefined1 *)(param_1 + 0x139) = 100;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7fe4;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7fffffe4;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xf7 | 8;\n  }\n  if (param_7 != (char *)0x0) {\n    if (param_6 == (char *)0x0) {\n      if (param_5 < 0x76) {\n        pvVar4 = iconv_open(param_7,\"WINDOWS-1252\");\n        *(iconv_t *)(param_1 + 0x178) = pvVar4;\n      }\n      else {\n        iVar2 = strcmp(param_7,\"UTF-8\");\n        if (iVar2 != 0) {\n          pvVar4 = iconv_open(param_7,\"UTF-8\");\n          *(iconv_t *)(param_1 + 0x178) = pvVar4;\n        }\n      }\n    }\n    else {\n      pvVar4 = iconv_open(param_7,param_6);\n      *(iconv_t *)(param_1 + 0x178) = pvVar4;\n    }\n    if (*(long *)(param_1 + 0x178) == -1) {\n      *(undefined8 *)(param_1 + 0x178) = 0;\n      return 7;\n    }\n  }\n  if (param_5 < 0x77) {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 1;\n  }\n  else {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 2;\n  }\n  lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x60));\n  *(long *)(param_1 + 0x58) = lVar3;\n  if (lVar3 == 0) {\n    return 3;\n  }\n  if (0 < *(int *)(param_1 + 0x10c)) {\n    *(long *)(param_1 + 0x40) = (long)*(int *)(param_1 + 0x10c) << 1;\n    *(long *)(param_1 + 0x50) = *(long *)(param_1 + 0x98) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x70) = *(long *)(param_1 + 0xa0) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x80) = *(long *)(param_1 + 0xa8) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x90) = *(long *)(param_1 + 0xb0) * (long)*(int *)(param_1 + 0x10c);\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x40));\n    *(long *)(param_1 + 0x38) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x50));\n    *(long *)(param_1 + 0x48) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x70));\n    *(long *)(param_1 + 0x68) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x80));\n    *(long *)(param_1 + 0x78) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x90));\n    *(long *)(param_1 + 0x88) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(undefined4 *)(param_1 + 0x1d8) = 1;\n  return 0;\n}\n\n",
        "function_pr": "\nundefined4\ndta_ctx_init(long param_1,undefined4 param_2,undefined8 param_3,char param_4,byte param_5,\n            char *param_6,char *param_7)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  iconv_t pvVar4;\n  undefined4 uVar5;\n  \n  cVar1 = '\\x01';\n  if ((param_5 < 0x68) || (0x77 < param_5)) {\n    return 0x18;\n  }\n  iVar2 = machine_is_little_endian();\n  if (iVar2 != 0) {\n    cVar1 = '\\x02';\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfe | param_4 != cVar1;\n  *(uint *)(param_1 + 0x108) = (uint)param_5;\n  uVar5 = 2;\n  if (param_4 == '\\x02') {\n    uVar5 = 1;\n  }\n  *(undefined4 *)(param_1 + 0x170) = uVar5;\n  *(undefined4 *)(param_1 + 0x10c) = param_2;\n  *(undefined8 *)(param_1 + 0x110) = param_3;\n  if (*(int *)(param_1 + 0x10c) != 0) {\n    lVar3 = readstat_calloc((long)*(int *)(param_1 + 0x10c),8);\n    *(long *)(param_1 + 0x168) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfd;\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xa0) = 7;\n  }\n  else if (param_5 < 0x72) {\n    *(undefined8 *)(param_1 + 0xa0) = 0xc;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa0) = 0x31;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa0) = 0x39;\n  }\n  if (param_5 < 0x75) {\n    if (param_5 < 0x6f) {\n      *(undefined *)(param_1 + 0x28) = 0;\n    }\n    else {\n      *(undefined *)(param_1 + 0x28) = 0x6f;\n    }\n  }\n  else {\n    *(undefined *)(param_1 + 0x28) = 0x75;\n  }\n  if (param_5 < 0x76) {\n    if (0x74 < param_5) {\n      *(undefined8 *)(param_1 + 0x10) = 1;\n      *(undefined8 *)(param_1 + 0xe0) = 4;\n      *(undefined8 *)(param_1 + 0xe8) = 4;\n    }\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x10) = 2;\n    *(undefined8 *)(param_1 + 0xe0) = 2;\n    *(undefined8 *)(param_1 + 0xe8) = 6;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xb8) = 0;\n  }\n  else if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xb8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb8) = 4;\n  }\n  if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xa8) = 9;\n    *(undefined8 *)(param_1 + 0x98) = 9;\n    *(undefined8 *)(param_1 + 0xc0) = 9;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa8) = 0x21;\n    *(undefined8 *)(param_1 + 0x98) = 0x21;\n    *(undefined8 *)(param_1 + 0xc0) = 0x21;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa8) = 0x81;\n    *(undefined8 *)(param_1 + 0x98) = 0x81;\n    *(undefined8 *)(param_1 + 0xc0) = 0x81;\n  }\n  if (param_5 < 0x6c) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x20;\n    *(undefined8 *)(param_1 + 8) = 0x20;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x51;\n    *(undefined8 *)(param_1 + 8) = 0x51;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb0) = 0x141;\n    *(undefined8 *)(param_1 + 8) = 0x141;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n    *(undefined8 *)(param_1 + 200) = 2;\n    *(undefined8 *)(param_1 + 0xd0) = 0xc;\n    *(undefined8 *)(param_1 + 0xd8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x20) = 0x12;\n    *(undefined8 *)(param_1 + 200) = 4;\n    if (param_5 < 0x76) {\n      *(undefined8 *)(param_1 + 0xd0) = 0x21;\n    }\n    else {\n      *(undefined8 *)(param_1 + 0xd0) = 0x81;\n    }\n    *(undefined8 *)(param_1 + 0xd8) = 3;\n  }\n  if (param_5 < 0x75) {\n    *(undefined8 *)(param_1 + 0x30) = 1;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x30) = 2;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb | 4;\n  }\n  if (param_5 < 0x71) {\n    *(undefined *)(param_1 + 0x139) = 0x7e;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7ffe;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7ffffffe;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n  }\n  else {\n    *(undefined *)(param_1 + 0x139) = 100;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7fe4;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7fffffe4;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xf7 | 8;\n  }\n  if (param_7 != (char *)0x0) {\n    if (param_6 == (char *)0x0) {\n      if (param_5 < 0x76) {\n        pvVar4 = iconv_open(param_7,\"WINDOWS-1252\");\n        *(iconv_t *)(param_1 + 0x178) = pvVar4;\n      }\n      else {\n        iVar2 = strcmp(param_7,\"UTF-8\");\n        if (iVar2 != 0) {\n          pvVar4 = iconv_open(param_7,\"UTF-8\");\n          *(iconv_t *)(param_1 + 0x178) = pvVar4;\n        }\n      }\n    }\n    else {\n      pvVar4 = iconv_open(param_7,param_6);\n      *(iconv_t *)(param_1 + 0x178) = pvVar4;\n    }\n    if (*(long *)(param_1 + 0x178) == -1) {\n      *(undefined8 *)(param_1 + 0x178) = 0;\n      return 7;\n    }\n  }\n  if (param_5 < 0x77) {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 1;\n  }\n  else {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 2;\n  }\n  lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x60));\n  *(long *)(param_1 + 0x58) = lVar3;\n  if (lVar3 == 0) {\n    return 3;\n  }\n  if (0 < *(int *)(param_1 + 0x10c)) {\n    *(long *)(param_1 + 0x40) = (long)*(int *)(param_1 + 0x10c) << 1;\n    *(long *)(param_1 + 0x50) = *(long *)(param_1 + 0x98) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x70) = *(long *)(param_1 + 0xa0) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x80) = *(long *)(param_1 + 0xa8) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x90) = *(long *)(param_1 + 0xb0) * (long)*(int *)(param_1 + 0x10c);\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x40));\n    *(long *)(param_1 + 0x38) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x50));\n    *(long *)(param_1 + 0x48) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x70));\n    *(long *)(param_1 + 0x68) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x80));\n    *(long *)(param_1 + 0x78) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x90));\n    *(long *)(param_1 + 0x88) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(undefined4 *)(param_1 + 0x1d8) = 1;\n  return 0;\n}\n\n",
        "source_ast": "{\n  \n  \n  if()return\n  if(call()){\n    \n  }\n  \n  \n  (? : )\n  \n  \n  if(){\n    if(call(, )){\n      \n      goto label\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      call(, )\n    }elseif(){\n      call(, )\n    }elseif(call(, )){\n      call(, )\n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(){\n    \n    \n    \n    \n    \n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  call()\n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    call(, )\n    \n    if(){\n      return\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    if(){\n      \n    }else{\n      \n    }\n  }else{\n    \n  }\n  if(){\n    if(){\n      \n      \n      \n    }\n  }else{\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      if(){\n        call(, )\n        \n      }else{\n        call(, )\n        if(){\n          call(, )\n          \n        }\n      }\n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      return\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  call()\n  \n  if(){\n    return\n  }\n  if(){\n    \n    \n    \n    \n    \n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n  }\n  \n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  call()\n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    call(, )\n    \n    if(){\n      return\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    if(){\n      \n    }else{\n      \n    }\n  }else{\n    \n  }\n  if(){\n    if(){\n      \n      \n      \n    }\n  }else{\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      if(){\n        call(, )\n        \n      }else{\n        call(, )\n        if(){\n          call(, )\n          \n        }\n      }\n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      return\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  call()\n  \n  if(){\n    return\n  }\n  if(){\n    \n    \n    \n    \n    \n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n  }\n  \n  return\n}",
        "metrics": {
          "source_ppl": 1.8359375,
          "base_ppl": 1.4609375,
          "pr_ppl": 1.4609375,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.296875,
          "pr_ast_ppl": 2.296875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured and readable format, using meaningful variable names and clear control flow, which makes it easier for a human developer to understand compared to the convoluted and less intuitive structure of Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      }
    ],
    "deepseek-r1": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 10:\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n          case :\n            \n            goto label\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 5.5,
          "base_ppl": 4.3125,
          "pr_ppl": 4.40625,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 4.0625,
          "pr_ast_ppl": 4.125,
          "delta_ppl": 0.09375
        },
        "llm_qualitative": {
          "motivation": "Candidate B provides a more maintainable and readable implementation of the original C code while preserving semantic equivalence. It avoids duplication, follows better coding practices, and is simpler in structure.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 10:\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n          case :\n            \n            goto label\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 5.5,
          "base_ppl": 4.3125,
          "pr_ppl": 4.40625,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 4.0625,
          "pr_ast_ppl": 4.125,
          "delta_ppl": 0.09375
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "motivation": "Candidate B correctly uses do-while loops, matching the source AST's structure and loop type, whereas Candidate A incorrectly uses for-loops. B also maintains better nesting and structural alignment.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-file_file_signextend-O0.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "source_ast": "{\n  if(){\n    switch(){\n      \n      case :\n        call(, , )\n        \n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if()call(, , )\n        return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  if(){\n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if(){\n          call(, , )\n        }\n        return\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  if(){\n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if(){\n          call(, , )\n        }\n        return\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 8.5,
          "base_ppl": 3.984375,
          "pr_ppl": 4.21875,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 2.65625,
          "pr_ast_ppl": 2.703125,
          "delta_ppl": 0.234375
        },
        "llm_qualitative": {
          "motivation": "Candidate A closely mirrors the original code's structure and logic, using a simple switch on the character from param_2 for handling different cases. Candidate B uses a more complex structure with file type handling and different casting, which is less standard and less human-readable.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-file_file_signextend-O2.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,byte *param_2,long param_3)\n\n{\n  if ((*param_2 & 8) == 0) {\n    switch(param_2[6]) {\n    case 1:\n      return (long)(char)param_3;\n    case 2:\n    case 7:\n    case 10:\n      return (long)(short)param_3;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      return (long)(int)param_3;\n    default:\n      param_3 = -1;\n      if ((*(byte *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\");\n        return -1;\n      }\n    }\n  }\n  return param_3;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,byte *param_2,long param_3)\n\n{\n  if ((*param_2 & 8) == 0) {\n    switch(param_2[6]) {\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      return (long)(int)param_3;\n    case 2:\n    case 7:\n    case 10:\n      return (long)(short)param_3;\n    case 1:\n      return (long)(char)param_3;\n    default:\n      param_3 = -1;\n      if ((*(byte *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\");\n        return -1;\n      }\n    }\n  }\n  return param_3;\n}\n\n",
        "source_ast": "{\n  if(){\n    switch(){\n      \n      case :\n        call(, , )\n        \n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if()call(, , )\n        return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  if(){\n    switch(){\n      case :\n        return\n      case :\n      case :\n      case :\n        return\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        return\n      case :\n        \n        \n        if(){\n          call(, )\n          return\n        }\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  if(){\n    switch(){\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        return\n      case :\n      case :\n      case :\n        return\n      case :\n        return\n      case :\n        \n        \n        if(){\n          call(, )\n          return\n        }\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 8.5,
          "base_ppl": 2.71875,
          "pr_ppl": 2.828125,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 2.5,
          "pr_ast_ppl": 2.484375,
          "delta_ppl": 0.109375
        },
        "llm_qualitative": {
          "motivation": "Candidate A is preferred because it is semantically equivalent to the original code and maintains a clean, human-readable structure with switch cases for different cases, making it more readable and maintainable.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "A recovered the for-loop while B used while-goto. A has the correct loop types and nesting depth, and better preserves the control flow structure.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_signextend-O3.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,byte *param_2,long param_3)\n\n{\n  if ((*param_2 & 8) == 0) {\n    switch(param_2[6]) {\n    case 1:\n      return (long)(char)param_3;\n    case 2:\n    case 7:\n    case 10:\n      return (long)(short)param_3;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      return (long)(int)param_3;\n    default:\n      param_3 = -1;\n      if ((*(byte *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\");\n        return -1;\n      }\n    }\n  }\n  return param_3;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,byte *param_2,long param_3)\n\n{\n  if ((*param_2 & 8) == 0) {\n    switch(param_2[6]) {\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      return (long)(int)param_3;\n    case 2:\n    case 7:\n    case 10:\n      return (long)(short)param_3;\n    case 1:\n      return (long)(char)param_3;\n    default:\n      param_3 = -1;\n      if ((*(byte *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\");\n        return -1;\n      }\n    }\n  }\n  return param_3;\n}\n\n",
        "source_ast": "{\n  if(){\n    switch(){\n      \n      case :\n        call(, , )\n        \n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if()call(, , )\n        return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  if(){\n    switch(){\n      case :\n        return\n      case :\n      case :\n      case :\n        return\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        return\n      case :\n        \n        \n        if(){\n          call(, )\n          return\n        }\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  if(){\n    switch(){\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        return\n      case :\n      case :\n      case :\n        return\n      case :\n        return\n      case :\n        \n        \n        if(){\n          call(, )\n          return\n        }\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 8.5,
          "base_ppl": 2.71875,
          "pr_ppl": 2.828125,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 2.5,
          "pr_ast_ppl": 2.484375,
          "delta_ppl": 0.109375
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more human-readable and maintains the exact semantic equivalence of the original code. It uses standard loops and clean logic, avoiding spaghetti code. The switch statement in A follows conventional C programming practices, making it more readable and maintainable. While Candidate B attempts to use file types, it deviates from the original functionality and logic, making it less suitable.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "A recovered the for-loop (switch) while B used while-goto (extra returns and more nesting levels).",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 5.5,
          "base_ppl": 4.1875,
          "pr_ppl": 4.15625,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 4.65625,
          "pr_ast_ppl": 4.65625,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B's code is more readable and follows better software development practices by using clear variable names, better memory management, and more structured control flow.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n            break;\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              call(, , )\n              \n              \n            case :\n              call(, , )\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 3.25,
          "pr_ppl": 3.28125,
          "source_ast_ppl": 5.125,
          "base_ast_ppl": 6.375,
          "pr_ast_ppl": 6.46875,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "motivation": "A used more goto labels and unnecessary nesting, which increases complexity. B better maintains loop fidelity and nesting depth closer to the source.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n            break;\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              call(, , )\n              \n              \n            case :\n              call(, , )\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 3.25,
          "pr_ppl": 3.28125,
          "source_ast_ppl": 5.125,
          "base_ast_ppl": 6.375,
          "pr_ast_ppl": 6.46875,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B provides a more maintainable and readable implementation while maintaining the original functionality. It uses simpler control structures and avoids the complexity of deeply nested loops and conditional checks. The use of helper functions like `bsearch_varname` makes the code more modular and easier to understand.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                \n                \n              case :\n                call(, , )\n                \n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                \n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 5.0,
          "base_ppl": 3.953125,
          "pr_ppl": 3.921875,
          "source_ast_ppl": 8.375,
          "base_ast_ppl": 10.25,
          "pr_ast_ppl": 10.75,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A maintains the original code's structure and readability while making only minor adjustments. It is the closest to the original while still being human-readable and maintainable.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "A recovered the for-loop while B used while-goto. A uses correct loop types and has similar nesting structure despite missing some else clauses, making it closer to the Source AST.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                \n                \n              case :\n                call(, , )\n                \n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                \n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 5.0,
          "base_ppl": 3.984375,
          "pr_ppl": 4.03125,
          "source_ast_ppl": 8.375,
          "base_ast_ppl": 10.25,
          "pr_ast_ppl": 10.75,
          "delta_ppl": 0.046875
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more human-readable due to its verbose, commented style and clear variable names, making it easier to understand the logic despite being longer.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-libxls_xls_isRecordTooSmall-O2.so",
        "function": "xls_isRecordTooSmall",
        "source_code": "int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1, const BYTE* buf) {\n    switch (bof1->id) {\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            return (bof1->size < 2 * sizeof(WORD));\n        case XLS_RECORD_CODEPAGE:\n            return (bof1->size < sizeof(WORD));\n\t\tcase XLS_RECORD_WINDOW1:\n            return (bof1->size < sizeof(WIND1));\n        case XLS_RECORD_SST:\n            return (bof1->size < offsetof(SST, strings));\n        case XLS_RECORD_BOUNDSHEET:\n            return (bof1->size < offsetof(BOUNDSHEET, name));\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n                return (bof1->size < sizeof(XF5));\n            }\n            return (bof1->size < sizeof(XF8));\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n            return (bof1->size < offsetof(FONT, name));\n        case XLS_RECORD_FORMAT:\n            return (bof1->size < offsetof(FORMAT, value));\n        case XLS_RECORD_STYLE:\n            {\n                struct {\n                    unsigned short idx;\n                    unsigned char ident;\n                    unsigned char lvl;\n                } *styl;\n                if(bof1->size < 2) {\n                    return 1;\n                }\n                styl = (void *)buf;\n                if(xlsShortVal(styl->idx) & 0x8000) {\n                    return bof1->size < 4;\n                } else {\n                    if(bof1->size < 3) return 1;\n                    return bof1->size < 3 + styl->ident;\n                }\n            }\n\t\tcase XLS_RECORD_1904:\n            return (bof1->size < sizeof(BYTE));\n        default:\n            break;\n    }\n    return 0;\n}\n",
        "function_base": "\nbool xls_isRecordTooSmall(long param_1,ushort *param_2,short *param_3)\n\n{\n  ushort uVar1;\n  short sVar2;\n  bool bVar3;\n  \n  uVar1 = *param_2;\n  if (uVar1 < 0xfc) {\n    bVar3 = false;\n    switch(uVar1) {\n    case 0x22:\n      bVar3 = param_2[1] == 0;\n      break;\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x41:\n      break;\n    case 0x31:\n      goto switchD_00101137_caseD_31;\n    case 0x3d:\n      bVar3 = param_2[1] < 0x12;\n      break;\n    case 0x42:\nswitchD_00101137_caseD_42:\n      bVar3 = param_2[1] < 2;\n      break;\n    default:\n      if (uVar1 == 0x85) {\n        bVar3 = param_2[1] < 6;\n      }\n      else {\n        bVar3 = false;\n        if (uVar1 == 0xe0) {\n          if (*(char *)(param_1 + 0xc) == '\\0') {\n            bVar3 = param_2[1] < 0x18;\n          }\n          else {\n            bVar3 = param_2[1] < 0x10;\n          }\n        }\n      }\n    }\n  }\n  else {\n    if (0x292 < uVar1) {\n      if (uVar1 == 0x293) {\n        if (param_2[1] < 2) {\n          return true;\n        }\n        sVar2 = xlsShortVal((int)*param_3);\n        uVar1 = param_2[1];\n        if (sVar2 < 0) {\n          return uVar1 < 4;\n        }\n        if (uVar1 < 3) {\n          return true;\n        }\n        return uVar1 < (ushort)(*(byte *)(param_3 + 1) + 3);\n      }\n      if (uVar1 != 0x41e) {\n        if (uVar1 != 0x809) {\n          return false;\n        }\n        return param_2[1] < 4;\n      }\n      goto switchD_00101137_caseD_42;\n    }\n    if (uVar1 == 0xfc) {\n      return param_2[1] < 8;\n    }\n    if (uVar1 != 0x231) {\n      return false;\n    }\nswitchD_00101137_caseD_31:\n    bVar3 = param_2[1] < 0xe;\n  }\n  return bVar3;\n}\n\n",
        "function_pr": "\nbool xls_isRecordTooSmall(long param_1,ushort *param_2,short *param_3)\n\n{\n  ushort uVar1;\n  short sVar2;\n  bool bVar3;\n  \n  uVar1 = *param_2;\n  if (uVar1 < 0xfc) {\n    bVar3 = false;\n    switch(uVar1) {\n    case 0x22:\n      bVar3 = param_2[1] == 0;\n      break;\n    default:\n      if (uVar1 == 0x85) {\n        bVar3 = param_2[1] < 6;\n      }\n      else {\n        bVar3 = false;\n        if (uVar1 == 0xe0) {\n          if (*(char *)(param_1 + 0xc) == '\\0') {\n            bVar3 = param_2[1] < 0x18;\n          }\n          else {\n            bVar3 = param_2[1] < 0x10;\n          }\n        }\n      }\n      break;\n    case 0x31:\n      goto switchD_00101137_caseD_31;\n    case 0x42:\nswitchD_00101137_caseD_42:\n      bVar3 = param_2[1] < 2;\n      break;\n    case 0x3d:\n      bVar3 = param_2[1] < 0x12;\n      break;\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x41:\n      break;\n    }\n  }\n  else {\n    if (0x292 < uVar1) {\n      if (uVar1 == 0x293) {\n        if (param_2[1] < 2) {\n          return true;\n        }\n        sVar2 = xlsShortVal((int)*param_3);\n        uVar1 = param_2[1];\n        if (sVar2 < 0) {\n          return uVar1 < 4;\n        }\n        if (uVar1 < 3) {\n          return true;\n        }\n        return uVar1 < (ushort)(*(byte *)(param_3 + 1) + 3);\n      }\n      if (uVar1 != 0x41e) {\n        if (uVar1 != 0x809) {\n          return false;\n        }\n        return param_2[1] < 4;\n      }\n      goto switchD_00101137_caseD_42;\n    }\n    if (uVar1 == 0xfc) {\n      return param_2[1] < 8;\n    }\n    if (uVar1 != 0x231) {\n      return false;\n    }\nswitchD_00101137_caseD_31:\n    bVar3 = param_2[1] < 0xe;\n  }\n  return bVar3;\n}\n\n",
        "source_ast": "{\n  switch(){\n    case :\n      \n      return\n    case :\n      return\n    case :\n      return\n    case :\n      return\n    case :\n      return\n    case :\n      if(){\n        return\n      }\n      return\n    case :\n    case :\n      return\n    case :\n      return\n    case :\n      {\n        \n        if(){\n          return\n        }\n        \n        if(call()){\n          return\n        }else{\n          if()return\n          return\n        }\n      }\n    case :\n      return\n    case :\n      \n      \n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  if(){\n    \n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        goto label\n      case :\n        \n        \n      case :\n        \n        \n      case :\n        \n        if(){\n          \n        }else{\n          \n          if(){\n            if(){\n              \n            }else{\n              \n            }\n          }\n        }\n    }\n  }else{\n    if(){\n      if(){\n        if(){\n          return\n        }\n        call()\n        \n        if(){\n          return\n        }\n        if(){\n          return\n        }\n        returncall()\n      }\n      if(){\n        if(){\n          return\n        }\n        return\n      }\n      goto label\n    }\n    if(){\n      return\n    }\n    if(){\n      return\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  if(){\n    \n    switch(){\n      case :\n        \n        \n      case :\n        \n        if(){\n          \n        }else{\n          \n          if(){\n            if(){\n              \n            }else{\n              \n            }\n          }\n        }\n        \n      case :\n        goto label\n      case :\n        \n        \n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n    }\n  }else{\n    if(){\n      if(){\n        if(){\n          return\n        }\n        call()\n        \n        if(){\n          return\n        }\n        if(){\n          return\n        }\n        returncall()\n      }\n      if(){\n        if(){\n          return\n        }\n        return\n      }\n      goto label\n    }\n    if(){\n      return\n    }\n    if(){\n      return\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 6.625,
          "base_ppl": 2.84375,
          "pr_ppl": 2.875,
          "source_ast_ppl": 6.71875,
          "base_ast_ppl": 4.53125,
          "pr_ast_ppl": 4.4375,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and maintains the same semantic behavior as the original code but with a cleaner, more standard loop structure.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate B's AST is closer to the source because it correctly uses if-else blocks without unnecessary nesting or goto labels, matching the source's structure and control flow more accurately.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-libxls_xls_isRecordTooSmall-O3.so",
        "function": "xls_isRecordTooSmall",
        "source_code": "int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1, const BYTE* buf) {\n    switch (bof1->id) {\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            return (bof1->size < 2 * sizeof(WORD));\n        case XLS_RECORD_CODEPAGE:\n            return (bof1->size < sizeof(WORD));\n\t\tcase XLS_RECORD_WINDOW1:\n            return (bof1->size < sizeof(WIND1));\n        case XLS_RECORD_SST:\n            return (bof1->size < offsetof(SST, strings));\n        case XLS_RECORD_BOUNDSHEET:\n            return (bof1->size < offsetof(BOUNDSHEET, name));\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n                return (bof1->size < sizeof(XF5));\n            }\n            return (bof1->size < sizeof(XF8));\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n            return (bof1->size < offsetof(FONT, name));\n        case XLS_RECORD_FORMAT:\n            return (bof1->size < offsetof(FORMAT, value));\n        case XLS_RECORD_STYLE:\n            {\n                struct {\n                    unsigned short idx;\n                    unsigned char ident;\n                    unsigned char lvl;\n                } *styl;\n                if(bof1->size < 2) {\n                    return 1;\n                }\n                styl = (void *)buf;\n                if(xlsShortVal(styl->idx) & 0x8000) {\n                    return bof1->size < 4;\n                } else {\n                    if(bof1->size < 3) return 1;\n                    return bof1->size < 3 + styl->ident;\n                }\n            }\n\t\tcase XLS_RECORD_1904:\n            return (bof1->size < sizeof(BYTE));\n        default:\n            break;\n    }\n    return 0;\n}\n",
        "function_base": "\nbool xls_isRecordTooSmall(long param_1,ushort *param_2,short *param_3)\n\n{\n  ushort uVar1;\n  short sVar2;\n  bool bVar3;\n  \n  uVar1 = *param_2;\n  if (uVar1 < 0xfc) {\n    bVar3 = false;\n    switch(uVar1) {\n    case 0x22:\n      bVar3 = param_2[1] == 0;\n      break;\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x41:\n      break;\n    case 0x31:\n      goto switchD_00101137_caseD_31;\n    case 0x3d:\n      bVar3 = param_2[1] < 0x12;\n      break;\n    case 0x42:\nswitchD_00101137_caseD_42:\n      bVar3 = param_2[1] < 2;\n      break;\n    default:\n      if (uVar1 == 0x85) {\n        bVar3 = param_2[1] < 6;\n      }\n      else {\n        bVar3 = false;\n        if (uVar1 == 0xe0) {\n          if (*(char *)(param_1 + 0xc) == '\\0') {\n            bVar3 = param_2[1] < 0x18;\n          }\n          else {\n            bVar3 = param_2[1] < 0x10;\n          }\n        }\n      }\n    }\n  }\n  else {\n    if (0x292 < uVar1) {\n      if (uVar1 == 0x293) {\n        if (param_2[1] < 2) {\n          return true;\n        }\n        sVar2 = xlsShortVal((int)*param_3);\n        uVar1 = param_2[1];\n        if (sVar2 < 0) {\n          return uVar1 < 4;\n        }\n        if (uVar1 < 3) {\n          return true;\n        }\n        return uVar1 < (ushort)(*(byte *)(param_3 + 1) + 3);\n      }\n      if (uVar1 != 0x41e) {\n        if (uVar1 != 0x809) {\n          return false;\n        }\n        return param_2[1] < 4;\n      }\n      goto switchD_00101137_caseD_42;\n    }\n    if (uVar1 == 0xfc) {\n      return param_2[1] < 8;\n    }\n    if (uVar1 != 0x231) {\n      return false;\n    }\nswitchD_00101137_caseD_31:\n    bVar3 = param_2[1] < 0xe;\n  }\n  return bVar3;\n}\n\n",
        "function_pr": "\nbool xls_isRecordTooSmall(long param_1,ushort *param_2,short *param_3)\n\n{\n  ushort uVar1;\n  short sVar2;\n  bool bVar3;\n  \n  uVar1 = *param_2;\n  if (uVar1 < 0xfc) {\n    bVar3 = false;\n    switch(uVar1) {\n    case 0x22:\n      bVar3 = param_2[1] == 0;\n      break;\n    default:\n      if (uVar1 == 0x85) {\n        bVar3 = param_2[1] < 6;\n      }\n      else {\n        bVar3 = false;\n        if (uVar1 == 0xe0) {\n          if (*(char *)(param_1 + 0xc) == '\\0') {\n            bVar3 = param_2[1] < 0x18;\n          }\n          else {\n            bVar3 = param_2[1] < 0x10;\n          }\n        }\n      }\n      break;\n    case 0x31:\n      goto switchD_00101137_caseD_31;\n    case 0x42:\nswitchD_00101137_caseD_42:\n      bVar3 = param_2[1] < 2;\n      break;\n    case 0x3d:\n      bVar3 = param_2[1] < 0x12;\n      break;\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x41:\n      break;\n    }\n  }\n  else {\n    if (0x292 < uVar1) {\n      if (uVar1 == 0x293) {\n        if (param_2[1] < 2) {\n          return true;\n        }\n        sVar2 = xlsShortVal((int)*param_3);\n        uVar1 = param_2[1];\n        if (sVar2 < 0) {\n          return uVar1 < 4;\n        }\n        if (uVar1 < 3) {\n          return true;\n        }\n        return uVar1 < (ushort)(*(byte *)(param_3 + 1) + 3);\n      }\n      if (uVar1 != 0x41e) {\n        if (uVar1 != 0x809) {\n          return false;\n        }\n        return param_2[1] < 4;\n      }\n      goto switchD_00101137_caseD_42;\n    }\n    if (uVar1 == 0xfc) {\n      return param_2[1] < 8;\n    }\n    if (uVar1 != 0x231) {\n      return false;\n    }\nswitchD_00101137_caseD_31:\n    bVar3 = param_2[1] < 0xe;\n  }\n  return bVar3;\n}\n\n",
        "source_ast": "{\n  switch(){\n    case :\n      \n      return\n    case :\n      return\n    case :\n      return\n    case :\n      return\n    case :\n      return\n    case :\n      if(){\n        return\n      }\n      return\n    case :\n    case :\n      return\n    case :\n      return\n    case :\n      {\n        \n        if(){\n          return\n        }\n        \n        if(call()){\n          return\n        }else{\n          if()return\n          return\n        }\n      }\n    case :\n      return\n    case :\n      \n      \n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  if(){\n    \n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        goto label\n      case :\n        \n        \n      case :\n        \n        \n      case :\n        \n        if(){\n          \n        }else{\n          \n          if(){\n            if(){\n              \n            }else{\n              \n            }\n          }\n        }\n    }\n  }else{\n    if(){\n      if(){\n        if(){\n          return\n        }\n        call()\n        \n        if(){\n          return\n        }\n        if(){\n          return\n        }\n        returncall()\n      }\n      if(){\n        if(){\n          return\n        }\n        return\n      }\n      goto label\n    }\n    if(){\n      return\n    }\n    if(){\n      return\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  if(){\n    \n    switch(){\n      case :\n        \n        \n      case :\n        \n        if(){\n          \n        }else{\n          \n          if(){\n            if(){\n              \n            }else{\n              \n            }\n          }\n        }\n        \n      case :\n        goto label\n      case :\n        \n        \n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n    }\n  }else{\n    if(){\n      if(){\n        if(){\n          return\n        }\n        call()\n        \n        if(){\n          return\n        }\n        if(){\n          return\n        }\n        returncall()\n      }\n      if(){\n        if(){\n          return\n        }\n        return\n      }\n      goto label\n    }\n    if(){\n      return\n    }\n    if(){\n      return\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 6.625,
          "base_ppl": 2.84375,
          "pr_ppl": 2.875,
          "source_ast_ppl": 6.71875,
          "base_ast_ppl": 4.53125,
          "pr_ast_ppl": 4.4375,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A matches the original code exactly in terms of functionality and control flow, making it the most semantically equivalent and human-readable option.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 3.234375,
          "pr_ppl": 3.203125,
          "source_ast_ppl": 5.125,
          "base_ast_ppl": 6.3125,
          "pr_ast_ppl": 6.3125,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A is chosen because it maintains the original code's structure, uses similar control flow and variable handling, and provides better readability while being functionally equivalent.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 5.0,
          "base_ppl": 3.359375,
          "pr_ppl": 3.390625,
          "source_ast_ppl": 8.375,
          "base_ast_ppl": 9.625,
          "pr_ast_ppl": 9.625,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 4.625,
          "pr_ppl": 4.9375,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 10.125,
          "pr_ast_ppl": 10.125,
          "delta_ppl": 0.3125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 4.625,
          "pr_ppl": 4.9375,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 10.125,
          "pr_ast_ppl": 10.125,
          "delta_ppl": 0.3125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            \n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 3.25,
          "base_ppl": 4.40625,
          "pr_ppl": 4.6875,
          "source_ast_ppl": 5.15625,
          "base_ast_ppl": 11.25,
          "pr_ast_ppl": 12.1875,
          "delta_ppl": 0.28125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            \n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 3.25,
          "base_ppl": 4.40625,
          "pr_ppl": 4.6875,
          "source_ast_ppl": 5.15625,
          "base_ast_ppl": 11.25,
          "pr_ast_ppl": 12.1875,
          "delta_ppl": 0.28125
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more human-readable and maintains the original code's structure and style, making it easier to understand for someone familiar with the source code. The refactored Candidate B, while functional, introduces a more procedural style and unconventional switch-case formatting that makes it harder to follow the control flow and variable assignments.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "Okay, so I'm trying to figure out which candidate, A or B, is topologically closer to the Source AST. The user gave me a bunch of code, but I need to compare the control flow skeletons of these candidates. Let's break this down step by step.\n\nFirst, I remember the criteria: topological shape, loop fidelity, and complexity penalty. The goal is to see which candidate matches the Source's structure better.\n\nLooking at the Source AST, I see a lot of loops and conditionals. It has for-loops, if-else statements, and some while loops. The structure seems a bit complex with multiple nesting levels, especially around the switch cases.\n\nNow, let's look at Candidate A. It starts with a do-while loop. Inside that, there's an if-else structure, and within the else, there's another do-while with a while loop. Then, inside that, there's a switch case with several cases. The code uses goto labels to jump around, which might be a problem because the Source doesn't have any goto statements. The Source uses if-else and for/while loops without goto, so this could be a complexity penalty for Candidate A.\n\nCandidate B also starts with a do-while loop and has similar if-else and do-while structures. However, in the part where it has the switch case, I notice that the cases are more varied. The Source had some cases without any conditions, like case : with just an empty switch. But in B, maybe the cases are more complex? Wait, looking closer, in B, after the do-while, the switch cases are either empty or have some if-else. But in the Source, there are cases like case : with if statements. Hmm, maybe B is handling the cases differently, but I'm not sure if that's a plus or minus.\n\nWait, another thing: the Source has a for-loop somewhere, but in the Candidates, I don't see any for-loop nodes. Both A and B use do-while and while loops instead. The Forced Decision says if both are bad, pick the one with correct loop types. But since neither A nor B have for-loops, maybe they both get penalized. But looking back, the Source has for-loops, and the Candidates use do-while. So, since the Source has ForLoop, the candidate with ForLoop would win. But neither A nor B have ForLoop; they have do-while, which is different.\n\nWait, but the Forced Decision says if both are bad, pick the one with correct loop types. Since neither A nor B have ForLoop, maybe they both get penalized for loop fidelity. So, the winner would be the one with correct nesting depth. Let me check the nesting.\n\nIn the Source, there are loops within loops. For example, the if()goto label is inside another if, which is inside a for-loop. The nesting depth there is significant. In Candidate A, the do-while is nested inside an else, which is inside another do-while. The nesting seems deeper. In Candidate B, it's similar but perhaps the switch cases don't add as much nesting.\n\nWait, maybe I should count the nesting levels. In the Source, the if()goto label is inside another if, which is inside a for-loop, which is inside an else, which is inside a do-while, which is inside another do-while. So that's four levels deep.\n\nIn Candidate A, the do-while is inside else, which is inside do-while, which is inside another do-while. That's three levels. Hmm, but the Source has four. So maybe Candidate A is one level less.\n\nCandidate B: do-while inside else, inside do-while, inside another do-while, same as A. So both have three levels, while the Source has four. So maybe the Source is deeper, but both Candidates are missing a level. But according to the Forced Decision, if both are bad, pick the one with correct loop types. Since neither has ForLoop, maybe they both get penalized. But the loop types are both do-while, which is different from the Source's for-loop. So maybe they both get penalties, but the winner is the one with correct nesting depth.\n\nWait, but the Forced Decision says to pick the one with correct loop types if both are bad. Since both Candidates don't have ForLoop, they both get penalized for loop type. But in the criteria, the winner is the one with correct loop types. Since both are incorrect, we move to the next criterion: nesting depth.\n\nSo, the Source has a deeper nesting. So between A and B, who has the deeper nesting? Let's see:\n\nSource: four levels.\n\nCandidate A: three levels.\n\nCandidate B: three levels.\n\nSo both have the same nesting depth, but less than the Source. So the winner would be the one with correct loop types, but since both are incorrect, we have to pick based on other criteria, like nesting depth. But since both have the same nesting depth, maybe the winner is the one that more accurately reflects the Source's structure.\n\nWait, looking back at the Source, it's using if-else and for/while loops, while the Candidates are using do-while and if-else. So the structure is somewhat similar but not exact.\n\nAnother thing: in the Source, there's a part where it has a switch with case : and then an if statement. In Candidate A, the switch is handled with do-while and if-else, which might not match the Source's structure. In Candidate B, the switch is also handled similarly. Maybe the switch part isn't the issue.\n\nWait, the main issue is that the Source has ForLoop, which neither Candidate has. So according to Forced Decision, if both are bad, pick the one with correct loop types. But since neither has ForLoop, perhaps they both get penalized. But then, the winner would be the one with correct nesting depth, which both have the same.\n\nHmm, maybe the difference lies in other parts. Let me look at the control flow.\n\nIn the Source, there's a part where it has if()goto label, which is inside an else block. In Candidate A, it's similar: else block with if()goto. In Candidate B, it's the same.\n\nAnother part: the Source has while() inside an if, which is inside another if. Candidate A has while() inside if()goto label, which is inside do-while. Not sure.\n\nWait, maybe the issue is that the Source uses ForLoop, which is a specific loop type. So since neither Candidate has ForLoop, they both have a loop fidelity issue. But the Forced Decision says to pick the one with correct loop types if both are bad. Since both are bad, we have to pick based on nesting depth, which they have the same. So maybe the winner is determined by other factors, like how the switch is handled or the call statements.\n\nLooking at the call statements: in the Source, after the switch, there are calls to call(, , , , , ) and call(, ). In Candidates, they have similar calls. Maybe that's not the issue.\n\nWait, perhaps the difference is in the structure around the loops. In the Source, the for-loop is followed by an if-else, which is inside another for-loop. In the Candidates, they have do-while loops, which are similar in structure.\n\nAnother point: the Source has some complex nesting with switch cases, which Candidates handle with do-while and if-else, which might not match.\n\nBut since both Candidates have the same loop fidelity issues (no ForLoop), and the same nesting depth, maybe the winner is determined by other factors. But according to the Forced Decision, if loop types are both incorrect, we pick the one with correct nesting depth. Since both have the same nesting depth, maybe the winner is the one that more closely follows the Source's structure in other aspects.\n\nAlternatively, maybe one of the Candidates has more unnecessary goto or label jumps, which would be a complexity penalty. In Candidate A, there's a goto label, which the Source doesn't have, while in Candidate B, the structure is similar but without the goto. Wait, looking back:\n\nIn the Source, there's a part like if()goto label, which jumps to label. In Candidate A, there's similar goto jumps. In Candidate B, I don't see any goto; instead, it uses if-else and while loops. So Candidate B might have a lower complexity penalty because it doesn't use goto.\n\nWait, no, in the Source, the if()goto label is inside an else, which is inside a for-loop. So the goto is used to jump to a label, which is a control flow change. In Candidate A, they have similar goto, which is okay. But in Candidate B, maybe they don't have any goto, which might make their control flow skeleton match the Source better in terms of using the correct constructs.\n\nWait, but the Source has a for-loop, which neither Candidate has. So according to Forced Decision, since both are bad, pick the one with correct loop types. But since neither has ForLoop, they both get penalized. So perhaps the winner is the one with more correct structural elements despite the loop type issue.\n\nAlternatively, maybe the winner is the one that has more accurate nesting, but both have the same. So perhaps the winner is the one that better reflects the Source's structure in other aspects, like switch handling or call statements.\n\nWait, in the Source, the switch case has if()elseif()else{}, but in the Candidates, they have similar structures. Maybe that's not the issue.\n\nAnother thought: the Source has some parts where it uses if()elseif()else{}, while the Candidates use if()else{}, which might be a difference. But I'm not sure if that"
        }
      },
      {
        "binary": "task-readstat_zsav_read_compressed_data-O0.so",
        "function": "zsav_read_compressed_data",
        "source_code": "readstat_error_t zsav_read_compressed_data(sav_ctx_t *ctx,\n        readstat_error_t (*row_handler)(unsigned char *, size_t, sav_ctx_t *)) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = ctx->io;\n    readstat_off_t data_offset = 0;\n\n    size_t uncompressed_row_len = ctx->var_offset * 8;\n    readstat_off_t uncompressed_offset = 0;\n    unsigned char *uncompressed_row = NULL;\n\n    uLongf uncompressed_block_len = 0;\n    unsigned char *compressed_block = NULL, *uncompressed_block = NULL;\n\n    struct sav_row_stream_s state = { \n        .missing_value = ctx->missing_double,\n        .bias = ctx->bias,\n        .bswap = ctx->bswap };\n\n    struct zheader zheader;\n    struct ztrailer ztrailer;\n    struct ztrailer_entry *ztrailer_entries = NULL;\n\n    int n_blocks = 0;\n    int block_i = 0;\n    int i;\n\n    if (io->read(&zheader, sizeof(struct zheader), io->io_ctx) < sizeof(struct zheader)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    zheader.zheader_ofs = ctx->bswap ? byteswap8(zheader.zheader_ofs) : zheader.zheader_ofs;\n    zheader.ztrailer_ofs = ctx->bswap ? byteswap8(zheader.ztrailer_ofs) : zheader.ztrailer_ofs;\n    zheader.ztrailer_len = ctx->bswap ? byteswap8(zheader.ztrailer_len) : zheader.ztrailer_len;\n\n    if (zheader.zheader_ofs != io->seek(0, READSTAT_SEEK_CUR, io->io_ctx) - sizeof(struct zheader)) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    n_blocks = (zheader.ztrailer_len - 24) / 24;\n\n    if (io->seek(zheader.ztrailer_ofs, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->read(&ztrailer, sizeof(struct ztrailer), io->io_ctx) < sizeof(struct ztrailer)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ztrailer.bias = ctx->bswap ? byteswap8(ztrailer.bias) : ztrailer.bias;\n    ztrailer.zero = ctx->bswap ? byteswap8(ztrailer.zero) : ztrailer.zero;\n    ztrailer.block_size = ctx->bswap ? byteswap4(ztrailer.block_size) : ztrailer.block_size;\n    ztrailer.n_blocks = ctx->bswap ? byteswap4(ztrailer.n_blocks) : ztrailer.n_blocks;\n\n    if (n_blocks != ztrailer.n_blocks) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    if (n_blocks && (ztrailer_entries = readstat_malloc(n_blocks * sizeof(struct ztrailer_entry))) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (io->read(ztrailer_entries, n_blocks * sizeof(struct ztrailer_entry), io->io_ctx) < \n            n_blocks * sizeof(struct ztrailer_entry)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    for (i=0; i<n_blocks; i++) {\n        struct ztrailer_entry *entry = &ztrailer_entries[i];\n\n        entry->uncompressed_ofs = ctx->bswap ? byteswap8(entry->uncompressed_ofs) : entry->uncompressed_ofs;\n        entry->compressed_ofs = ctx->bswap ? byteswap8(entry->compressed_ofs) : entry->compressed_ofs;\n        entry->uncompressed_size = ctx->bswap ? byteswap4(entry->uncompressed_size) : entry->uncompressed_size;\n        entry->compressed_size = ctx->bswap ? byteswap4(entry->compressed_size) : entry->compressed_size;\n    }\n\n    if (uncompressed_row_len && (uncompressed_row = readstat_malloc(uncompressed_row_len)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    while (1) {\n        if (block_i == n_blocks)\n            goto cleanup;\n\n        struct ztrailer_entry *entry = &ztrailer_entries[block_i];\n        if (io->seek(entry->compressed_ofs, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n            retval = READSTAT_ERROR_SEEK;\n            goto cleanup;\n        }\n        if ((compressed_block = readstat_realloc(compressed_block, entry->compressed_size)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if (io->read(compressed_block, entry->compressed_size, io->io_ctx) != entry->compressed_size) {\n            retval = READSTAT_ERROR_READ;\n            goto cleanup;\n        }\n\n        uncompressed_block_len = entry->uncompressed_size;\n        if ((uncompressed_block = readstat_realloc(uncompressed_block, uncompressed_block_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        int status = uncompress(uncompressed_block, &uncompressed_block_len,\n                compressed_block, entry->compressed_size);\n        if (status != Z_OK || uncompressed_block_len != entry->uncompressed_size) {\n            retval = READSTAT_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        block_i++;\n        state.status = SAV_ROW_STREAM_HAVE_DATA;\n        data_offset = 0;\n\n        while (state.status != SAV_ROW_STREAM_NEED_DATA) {\n            state.next_in = &uncompressed_block[data_offset];\n            state.avail_in = uncompressed_block_len - data_offset;\n\n            state.next_out = &uncompressed_row[uncompressed_offset];\n            state.avail_out = uncompressed_row_len - uncompressed_offset;\n\n            sav_decompress_row(&state);\n\n            uncompressed_offset = uncompressed_row_len - state.avail_out;\n            data_offset = uncompressed_block_len - state.avail_in;\n\n            if (state.status == SAV_ROW_STREAM_FINISHED_ROW) {\n                retval = row_handler(uncompressed_row, uncompressed_row_len, ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                uncompressed_offset = 0;\n            }\n\n            if (state.status == SAV_ROW_STREAM_FINISHED_ALL)\n                goto cleanup;\n            if (ctx->row_limit > 0 && ctx->current_row == ctx->row_limit)\n                goto cleanup;\n        }\n    }\n\ncleanup:\n    if (uncompressed_row)\n        free(uncompressed_row);\n    if (ztrailer_entries)\n        free(ztrailer_entries);\n    if (compressed_block)\n        free(compressed_block);\n    if (uncompressed_block)\n        free(uncompressed_block);\n\n    return retval;\n}\n",
        "function_base": "\nint zsav_read_compressed_data(long param_1,code *param_2)\n\n{\n  undefined1 auVar1 [16];\n  int iVar2;\n  int iVar3;\n  ulong uVar4;\n  long lVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined4 local_158;\n  undefined4 local_154;\n  undefined8 local_150;\n  undefined8 local_148;\n  int local_140;\n  undefined4 local_13c;\n  undefined8 local_138;\n  undefined8 local_130;\n  long local_120;\n  undefined8 local_118;\n  long local_110;\n  int local_ec;\n  int local_e8;\n  void *local_e0;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined4 local_c8;\n  int local_c4;\n  long local_c0;\n  undefined8 local_b8;\n  long local_b0;\n  long local_a8;\n  long local_a0;\n  long local_98;\n  long local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined1 auStack_78 [8];\n  undefined4 local_70;\n  uint local_6c;\n  int local_68;\n  void *local_60;\n  void *local_58;\n  long local_50;\n  void *local_48;\n  long local_40;\n  long local_38;\n  long local_30;\n  long local_28;\n  int local_1c;\n  code *local_18;\n  long local_10;\n  \n  local_1c = 0;\n  local_28 = *(long *)(param_1 + 0x48);\n  local_30 = 0;\n  local_38 = (long)(*(int *)(param_1 + 0x1ac) << 3);\n  local_40 = 0;\n  local_48 = (void *)0x0;\n  local_50 = 0;\n  local_58 = (void *)0x0;\n  local_60 = (void *)0x0;\n  local_a8 = 0;\n  local_a0 = 0;\n  local_98 = 0;\n  local_90 = 0;\n  local_88 = *(undefined8 *)(param_1 + 0x1f0);\n  local_80 = *(undefined8 *)(param_1 + 0x218);\n  local_18 = param_2;\n  local_10 = param_1;\n  memset(auStack_78,0,8);\n  local_70 = 0;\n  local_6c = (uint)(*(byte *)(local_10 + 0x22c) & 1);\n  local_68 = 0;\n  local_e0 = (void *)0x0;\n  local_e8 = 0;\n  uVar4 = (**(code **)(local_28 + 0x18))(&local_c0,0x18,*(undefined8 *)(local_28 + 0x28));\n  if (uVar4 < 0x18) {\n    local_1c = 2;\n  }\n  else {\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_110 = local_c0;\n    }\n    else {\n      local_110 = byteswap8(local_c0);\n    }\n    local_c0 = local_110;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_118 = local_b8;\n    }\n    else {\n      local_118 = byteswap8(local_b8);\n    }\n    local_b8 = local_118;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_120 = local_b0;\n    }\n    else {\n      local_120 = byteswap8(local_b0);\n    }\n    lVar6 = local_c0;\n    local_b0 = local_120;\n    lVar5 = (**(code **)(local_28 + 0x10))(0,1,*(undefined8 *)(local_28 + 0x28));\n    if (lVar6 == lVar5 + -0x18) {\n      auVar1._8_8_ = 0;\n      auVar1._0_8_ = local_b0 - 0x18;\n      iVar2 = SUB164(auVar1 / ZEXT816(0x18),0);\n      lVar6 = (**(code **)(local_28 + 0x10))(local_b8,0,*(undefined8 *)(local_28 + 0x28));\n      if (lVar6 == -1) {\n        local_1c = 0xf;\n      }\n      else {\n        uVar4 = (**(code **)(local_28 + 0x18))(&local_d8,0x18,*(undefined8 *)(local_28 + 0x28));\n        if (uVar4 < 0x18) {\n          local_1c = 2;\n        }\n        else {\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_130 = local_d8;\n          }\n          else {\n            local_130 = byteswap8(local_d8);\n          }\n          local_d8 = local_130;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_138 = local_d0;\n          }\n          else {\n            local_138 = byteswap8(local_d0);\n          }\n          local_d0 = local_138;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_13c = local_c8;\n          }\n          else {\n            local_13c = byteswap4(local_c8);\n          }\n          local_c8 = local_13c;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_140 = local_c4;\n          }\n          else {\n            local_140 = byteswap4(local_c4);\n          }\n          local_c4 = local_140;\n          if (iVar2 == local_140) {\n            if ((iVar2 == 0) ||\n               (local_e0 = (void *)readstat_malloc((long)iVar2 * 0x18), local_e0 != (void *)0x0)) {\n              uVar4 = (**(code **)(local_28 + 0x18))\n                                (local_e0,(long)iVar2 * 0x18,*(undefined8 *)(local_28 + 0x28));\n              if (uVar4 < (ulong)((long)iVar2 * 0x18)) {\n                local_1c = 2;\n              }\n              else {\n                for (local_ec = 0; local_ec < iVar2; local_ec = local_ec + 1) {\n                  puVar7 = (undefined8 *)((long)local_e0 + (long)local_ec * 0x18);\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_148 = *puVar7;\n                  }\n                  else {\n                    local_148 = byteswap8(*puVar7);\n                  }\n                  *puVar7 = local_148;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_150 = puVar7[1];\n                  }\n                  else {\n                    local_150 = byteswap8(puVar7[1]);\n                  }\n                  puVar7[1] = local_150;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_154 = *(undefined4 *)(puVar7 + 2);\n                  }\n                  else {\n                    local_154 = byteswap4(*(undefined4 *)(puVar7 + 2));\n                  }\n                  *(undefined4 *)(puVar7 + 2) = local_154;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_158 = *(undefined4 *)((long)puVar7 + 0x14);\n                  }\n                  else {\n                    local_158 = byteswap4(*(undefined4 *)((long)puVar7 + 0x14));\n                  }\n                  *(undefined4 *)((long)puVar7 + 0x14) = local_158;\n                }\n                if ((local_38 == 0) ||\n                   (local_48 = (void *)readstat_malloc(local_38), local_48 != (void *)0x0)) {\n                  while (local_e8 != iVar2) {\n                    lVar6 = (**(code **)(local_28 + 0x10))\n                                      (*(undefined8 *)((long)local_e0 + (long)local_e8 * 0x18 + 8),0\n                                       ,*(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 == -1) {\n                      local_1c = 0xf;\n                      break;\n                    }\n                    local_58 = (void *)readstat_realloc(local_58,(long)*(int *)((long)local_e0 +\n                                                                               (long)local_e8 * 0x18\n                                                                               + 0x14));\n                    if (local_58 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    lVar6 = (**(code **)(local_28 + 0x18))\n                                      (local_58,(long)*(int *)((long)local_e0 +\n                                                              (long)local_e8 * 0x18 + 0x14),\n                                       *(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)) {\n                      local_1c = 2;\n                      break;\n                    }\n                    local_50 = (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10);\n                    local_60 = (void *)readstat_realloc(local_60,local_50);\n                    if (local_60 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    iVar3 = uncompress(local_60,&local_50,local_58,\n                                       (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)\n                                      );\n                    if ((iVar3 != 0) ||\n                       (local_50 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10))) {\n                      local_1c = 5;\n                      break;\n                    }\n                    local_e8 = local_e8 + 1;\n                    local_68 = 1;\n                    local_30 = 0;\n                    while (local_68 != 0) {\n                      local_a8 = (long)local_60 + local_30;\n                      local_a0 = local_50 - local_30;\n                      local_98 = (long)local_48 + local_40;\n                      local_90 = local_38 - local_40;\n                      sav_decompress_row(&local_a8);\n                      local_40 = local_38 - local_90;\n                      local_30 = local_50 - local_a0;\n                      if (local_68 == 2) {\n                        local_1c = (*local_18)(local_48,local_38,local_10);\n                        if (local_1c != 0) goto LAB_00101a68;\n                        local_40 = 0;\n                      }\n                      if ((local_68 == 3) ||\n                         ((0 < *(int *)(local_10 + 0x1b8) &&\n                          (*(int *)(local_10 + 0x1c0) == *(int *)(local_10 + 0x1b8)))))\n                      goto LAB_00101a68;\n                    }\n                  }\n                }\n                else {\n                  local_1c = 3;\n                }\n              }\n            }\n            else {\n              local_1c = 3;\n            }\n          }\n          else {\n            local_1c = 5;\n          }\n        }\n      }\n    }\n    else {\n      local_1c = 5;\n    }\n  }\nLAB_00101a68:\n  if (local_48 != (void *)0x0) {\n    free(local_48);\n  }\n  if (local_e0 != (void *)0x0) {\n    free(local_e0);\n  }\n  if (local_58 != (void *)0x0) {\n    free(local_58);\n  }\n  if (local_60 != (void *)0x0) {\n    free(local_60);\n  }\n  return local_1c;\n}\n\n",
        "function_pr": "\nint zsav_read_compressed_data(long param_1,code *param_2)\n\n{\n  undefined auVar1 [16];\n  int iVar2;\n  int iVar3;\n  ulong uVar4;\n  long lVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined4 local_158;\n  undefined4 local_154;\n  undefined8 local_150;\n  undefined8 local_148;\n  int local_140;\n  undefined4 local_13c;\n  undefined8 local_138;\n  undefined8 local_130;\n  long local_120;\n  undefined8 local_118;\n  long local_110;\n  int local_ec;\n  int local_e8;\n  void *local_e0;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined4 local_c8;\n  int local_c4;\n  long local_c0;\n  undefined8 local_b8;\n  long local_b0;\n  long local_a8;\n  long local_a0;\n  long local_98;\n  long local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined auStack_78 [8];\n  undefined4 local_70;\n  uint local_6c;\n  int local_68;\n  void *local_60;\n  void *local_58;\n  long local_50;\n  void *local_48;\n  long local_40;\n  long local_38;\n  long local_30;\n  long local_28;\n  int local_1c;\n  code *local_18;\n  long local_10;\n  \n  local_1c = 0;\n  local_28 = *(long *)(param_1 + 0x48);\n  local_30 = 0;\n  local_38 = (long)(*(int *)(param_1 + 0x1ac) << 3);\n  local_40 = 0;\n  local_48 = (void *)0x0;\n  local_50 = 0;\n  local_58 = (void *)0x0;\n  local_60 = (void *)0x0;\n  local_a8 = 0;\n  local_a0 = 0;\n  local_98 = 0;\n  local_90 = 0;\n  local_88 = *(undefined8 *)(param_1 + 0x1f0);\n  local_80 = *(undefined8 *)(param_1 + 0x218);\n  local_18 = param_2;\n  local_10 = param_1;\n  memset(auStack_78,0,8);\n  local_70 = 0;\n  local_6c = (uint)(*(byte *)(local_10 + 0x22c) & 1);\n  local_68 = 0;\n  local_e0 = (void *)0x0;\n  local_e8 = 0;\n  uVar4 = (**(code **)(local_28 + 0x18))(&local_c0,0x18,*(undefined8 *)(local_28 + 0x28));\n  if (uVar4 < 0x18) {\n    local_1c = 2;\n  }\n  else {\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_110 = local_c0;\n    }\n    else {\n      local_110 = byteswap8(local_c0);\n    }\n    local_c0 = local_110;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_118 = local_b8;\n    }\n    else {\n      local_118 = byteswap8(local_b8);\n    }\n    local_b8 = local_118;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_120 = local_b0;\n    }\n    else {\n      local_120 = byteswap8(local_b0);\n    }\n    lVar6 = local_c0;\n    local_b0 = local_120;\n    lVar5 = (**(code **)(local_28 + 0x10))(0,1,*(undefined8 *)(local_28 + 0x28));\n    if (lVar6 == lVar5 + -0x18) {\n      auVar1._8_8_ = 0;\n      auVar1._0_8_ = local_b0 - 0x18;\n      iVar2 = SUB164(auVar1 / ZEXT816(0x18),0);\n      lVar6 = (**(code **)(local_28 + 0x10))(local_b8,0,*(undefined8 *)(local_28 + 0x28));\n      if (lVar6 == -1) {\n        local_1c = 0xf;\n      }\n      else {\n        uVar4 = (**(code **)(local_28 + 0x18))(&local_d8,0x18,*(undefined8 *)(local_28 + 0x28));\n        if (uVar4 < 0x18) {\n          local_1c = 2;\n        }\n        else {\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_130 = local_d8;\n          }\n          else {\n            local_130 = byteswap8(local_d8);\n          }\n          local_d8 = local_130;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_138 = local_d0;\n          }\n          else {\n            local_138 = byteswap8(local_d0);\n          }\n          local_d0 = local_138;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_13c = local_c8;\n          }\n          else {\n            local_13c = byteswap4(local_c8);\n          }\n          local_c8 = local_13c;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_140 = local_c4;\n          }\n          else {\n            local_140 = byteswap4(local_c4);\n          }\n          local_c4 = local_140;\n          if (iVar2 == local_140) {\n            if ((iVar2 == 0) ||\n               (local_e0 = (void *)readstat_malloc((long)iVar2 * 0x18), local_e0 != (void *)0x0)) {\n              uVar4 = (**(code **)(local_28 + 0x18))\n                                (local_e0,(long)iVar2 * 0x18,*(undefined8 *)(local_28 + 0x28));\n              if (uVar4 < (ulong)((long)iVar2 * 0x18)) {\n                local_1c = 2;\n              }\n              else {\n                for (local_ec = 0; local_ec < iVar2; local_ec = local_ec + 1) {\n                  puVar7 = (undefined8 *)((long)local_e0 + (long)local_ec * 0x18);\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_148 = *puVar7;\n                  }\n                  else {\n                    local_148 = byteswap8(*puVar7);\n                  }\n                  *puVar7 = local_148;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_150 = puVar7[1];\n                  }\n                  else {\n                    local_150 = byteswap8(puVar7[1]);\n                  }\n                  puVar7[1] = local_150;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_154 = *(undefined4 *)(puVar7 + 2);\n                  }\n                  else {\n                    local_154 = byteswap4(*(undefined4 *)(puVar7 + 2));\n                  }\n                  *(undefined4 *)(puVar7 + 2) = local_154;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_158 = *(undefined4 *)((long)puVar7 + 0x14);\n                  }\n                  else {\n                    local_158 = byteswap4(*(undefined4 *)((long)puVar7 + 0x14));\n                  }\n                  *(undefined4 *)((long)puVar7 + 0x14) = local_158;\n                }\n                if ((local_38 == 0) ||\n                   (local_48 = (void *)readstat_malloc(local_38), local_48 != (void *)0x0)) {\n                  while (local_e8 != iVar2) {\n                    lVar6 = (**(code **)(local_28 + 0x10))\n                                      (*(undefined8 *)((long)local_e0 + (long)local_e8 * 0x18 + 8),0\n                                       ,*(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 == -1) {\n                      local_1c = 0xf;\n                      break;\n                    }\n                    local_58 = (void *)readstat_realloc(local_58,(long)*(int *)((long)local_e0 +\n                                                                               (long)local_e8 * 0x18\n                                                                               + 0x14));\n                    if (local_58 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    lVar6 = (**(code **)(local_28 + 0x18))\n                                      (local_58,(long)*(int *)((long)local_e0 +\n                                                              (long)local_e8 * 0x18 + 0x14),\n                                       *(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)) {\n                      local_1c = 2;\n                      break;\n                    }\n                    local_50 = (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10);\n                    local_60 = (void *)readstat_realloc(local_60,local_50);\n                    if (local_60 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    iVar3 = uncompress(local_60,&local_50,local_58,\n                                       (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)\n                                      );\n                    if ((iVar3 != 0) ||\n                       (local_50 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10))) {\n                      local_1c = 5;\n                      break;\n                    }\n                    local_e8 = local_e8 + 1;\n                    local_68 = 1;\n                    local_30 = 0;\n                    while (local_68 != 0) {\n                      local_a8 = (long)local_60 + local_30;\n                      local_a0 = local_50 - local_30;\n                      local_98 = (long)local_48 + local_40;\n                      local_90 = local_38 - local_40;\n                      sav_decompress_row(&local_a8);\n                      local_40 = local_38 - local_90;\n                      local_30 = local_50 - local_a0;\n                      if (local_68 == 2) {\n                        local_1c = (*local_18)(local_48,local_38,local_10);\n                        if (local_1c != 0) goto LAB_00101a68;\n                        local_40 = 0;\n                      }\n                      if ((local_68 == 3) ||\n                         ((0 < *(int *)(local_10 + 0x1b8) &&\n                          (*(int *)(local_10 + 0x1c0) == *(int *)(local_10 + 0x1b8)))))\n                      goto LAB_00101a68;\n                    }\n                  }\n                }\n                else {\n                  local_1c = 3;\n                }\n              }\n            }\n            else {\n              local_1c = 3;\n            }\n          }\n          else {\n            local_1c = 5;\n          }\n        }\n      }\n    }\n    else {\n      local_1c = 5;\n    }\n  }\nLAB_00101a68:\n  if (local_48 != (void *)0x0) {\n    free(local_48);\n  }\n  if (local_e0 != (void *)0x0) {\n    free(local_e0);\n  }\n  if (local_58 != (void *)0x0) {\n    free(local_58);\n  }\n  if (local_60 != (void *)0x0) {\n    free(local_60);\n  }\n  return local_1c;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  if(){\n    \n    goto label\n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  for(;;){\n    \n    (? call(): )\n    (? call(): )\n    (? call(): )\n    (? call(): )\n  }\n  if(call()){\n    \n    goto label\n  }\n  while(){\n    if()goto label\n    \n    if(call(, , )){\n      \n      goto label\n    }\n    if(call(, )){\n      \n      goto label\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    \n    if(call(, )){\n      \n      goto label\n    }\n    call(, , , )\n    if(){\n      \n      goto label\n    }\n    \n    \n    \n    while(){\n      \n      \n      \n      \n      call()\n      \n      \n      if(){\n        call(, , )\n        if()goto label\n        \n      }\n      if()goto label\n      if()goto label\n    }\n  }\n  if()call()\n  if()call()\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, , )\n  \n  call()\n  \n  \n  \n  call(, , )\n  if(){\n    \n  }else{\n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    \n    call(, , )\n    if(){\n      \n      \n      call(call(), )\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          \n        }else{\n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            if(call()){\n              call(, , )\n              if(call()){\n                \n              }else{\n                for(;;){\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                }\n                if(call()){\n                  while(){\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    \n                    \n                    while(){\n                      \n                      \n                      \n                      \n                      call()\n                      \n                      \n                      if(){\n                        call(, , )\n                        if()goto label\n                        \n                      }\n                      if()goto label\n                    }\n                  }\n                }else{\n                  \n                }\n              }\n            }else{\n              \n            }\n          }else{\n            \n          }\n        }\n      }\n    }else{\n      \n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, , )\n  \n  call()\n  \n  \n  \n  call(, , )\n  if(){\n    \n  }else{\n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    \n    call(, , )\n    if(){\n      \n      \n      call(call(), )\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          \n        }else{\n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            if(call()){\n              call(, , )\n              if(call()){\n                \n              }else{\n                for(;;){\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                }\n                if(call()){\n                  while(){\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    \n                    \n                    while(){\n                      \n                      \n                      \n                      \n                      call()\n                      \n                      \n                      if(){\n                        call(, , )\n                        if()goto label\n                        \n                      }\n                      if()goto label\n                    }\n                  }\n                }else{\n                  \n                }\n              }\n            }else{\n              \n            }\n          }else{\n            \n          }\n        }\n      }\n    }else{\n      \n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.4375,
          "base_ppl": 2.46875,
          "pr_ppl": 2.46875,
          "source_ast_ppl": 5.625,
          "base_ast_ppl": 6.5625,
          "pr_ast_ppl": 6.5625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      \n      do{\n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n        }\n        if()goto label\n        \n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 8.375,
          "base_ppl": 3.390625,
          "pr_ppl": 3.4375,
          "source_ast_ppl": 70.0,
          "base_ast_ppl": 9.1875,
          "pr_ast_ppl": 9.3125,
          "delta_ppl": 0.046875
        },
        "llm_qualitative": {
          "motivation": "Candidate A perfectly mirrors the original source code with identical variable names, logic, and structure, making it the most human-readable and accurate.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "Alright, let's tackle this problem step by step. I'm comparing two ASTs, A and B, to determine which is topologically closer to the source. The source is an if statement followed by a do-while loop, which itself contains a for loop and some if statements. \n\nFirst, I'll look at the structure of the source. It starts with an if statement, then a do-while loop. Inside the loop, there's a for loop, which is used for incrementing a counter or something similar. The source uses a do-while loop and a for loop, which are control flow structures that involve nesting.\n\nNow, looking at candidate A. It starts with an if statement, then a do-while loop. Inside that loop, there's a switch statement. The switch has multiple cases, and in some cases, it uses goto labels to jump around. There's also a for loop inside the switch, but it's not directly nested within the do-while loop as in the source. Instead, the structure is more fragmented with goto jumps, which complicates things.\n\nCandidate B also starts with an if statement and a do-while loop. Inside, there's a switch with cases and some if statements that use goto labels. However, the structure seems similar to A but with some differences in how the switch cases are handled. There's a for loop inside the switch, but again, it's not clearly nested within the do-while loop like in the source.\n\nThe key here is the use of loops. The source has a do-while loop that contains a for loop. Both A and B have a do-while loop, but A has a for loop inside the do-while, while B's for loop is inside the switch. Wait, no, actually, both A and B have a for loop inside a switch inside the do-while. That might be a mistake. Let me re-examine.\n\nWait, in the source, the do-while loop contains a for loop. In candidate A, the do-while loop contains a switch, and inside the switch, there's a for loop. Similarly, in B, the do-while loop contains a switch with a for loop. So both have the same loop structure in terms of nesting: do-while containing a switch containing a for loop. But the source has do-while containing a for loop, which is different.\n\nWait, no. In the source, the do-while loop is the outermost loop, containing the for loop. In both A and B, the do-while loop is the outermost loop, containing a switch that has a for loop. So the loop structure in terms of nesting is similar. But the source has a for loop inside the do-while, which is correct. In A and B, the for loop is inside the switch, which is inside the do-while. So the loop structure is correct in terms of nesting.\n\nBut the source uses a for loop, while A and B are using a for loop inside a switch, which is a different structure. However, the problem statement says that loop fidelity is important. So if the source uses a for loop, then the candidate should have a for loop where possible. In A and B, the for loop is inside the switch, not directly under the do-while loop. So the loop is not directly nested as in the source.\n\nWait, no. In the source, the do-while loop contains the for loop. So the for loop is a direct child of the do-while. In A and B, the do-while loop contains a switch, which contains the for loop. So the for loop is two levels deep under the do-while, whereas in the source, it's directly under. So the loop structure is different.\n\nAdditionally, both A and B have a lot of goto labels, which are not present in the source. The source uses if statements to control the flow. So the use of goto in A and B adds unnecessary complexity and deviates from the source's structure.\n\nConsidering the criteria, loop fidelity is important. The source has a for loop, and both A and B have a for loop, so that's good. However, the nesting depth of the loops differs. In the source, the for loop is directly under the do-while. In A and B, the for loop is under the switch, which is under the do-while. So the nesting depth is two levels deeper in A and B compared to the source.\n\nAnother thing is that both A and B use goto, which is discouraged. The source uses if statements, which are more straightforward. So the source's structure is cleaner and more readable.\n\nLooking at the forced decision criteria, if both are bad, pick the one with the correct loop types. But both A and B have the correct loop types (for loop in the do-while), so we look at the nesting depth. The source has a correct loop structure, so the candidate with the correct nesting depth would be better.\n\nHowever, both A and B have the for loop inside the switch, which is not matching the source's structure. The source has the for loop directly under the do-while, while A and B have it under the switch. So neither perfectly matches the source's structure in terms of loop nesting.\n\nBut between A and B, they are identical in structure. Both have the same number of cases in the switch, same goto labels, same if statements. So they are structurally the same.\n\nGiven that both A and B are equally bad in terms of loop fidelity and structure, but A has a slightly better goto structure? Wait, no. Both have the same number of goto labels and similar control flow.\n\nBut the source doesn't use goto. So both A and B are adding unnecessary goto jumps, which makes their control flow less similar to the source.\n\nGiven the forced decision, if both are bad, pick the one with the correct loop types. Since both have the correct loop types, we then pick the one with correct nesting depth. But in both cases, the nesting depth is incorrect because the for loop is not directly under the do-while.\n\nWait, maybe I'm misunderstanding. The source has a do-while loop that contains a for loop. So the for loop is directly inside the do-while. In A and B, the do-while contains a switch, which contains the for loop. So the nesting depth is two levels deeper in A and B.\n\nBut the source has the for loop at the same level as the do-while. So the source's loop nesting is correct in terms of the for loop being directly under the do-while. But in A and B, the for loop is under the switch, which is under the do-while, making it two levels deeper.\n\nSo in terms of loop fidelity, the source has the correct nesting. A and B have the for loop but at a deeper level, which is not ideal.\n\nAdditionally, the source uses if statements, while A and B use goto, which is less clean.\n\nSo, both A and B are equally bad in terms of loop fidelity and structure because they both have the for loop at the wrong nesting depth and use goto instead of if.\n\nBut the forced decision says if both are bad, pick the one with correct loop types. Since both have correct loop types (for loop), we then look at nesting depth. But both have incorrect nesting depth. So maybe we have to choose based on other factors.\n\nAlternatively, perhaps I'm misunderstanding the loop fidelity. The source has a do-while loop, which is a while loop. But in A and B, they have a do-while loop as well. So loop fidelity is correct in terms of using do-while and for loops. So the loop types are correct.\n\nBut the structure of the loops is different. In the source, the for loop is directly under the do-while. In A and B, the for loop is under a switch, which is under the do-while. So the nesting depth is incorrect.\n\nAdditionally, both have goto, which is bad.\n\nSo, in terms of loop fidelity, both have correct loop types, but incorrect nesting. So the source's structure is better in terms of loop nesting.\n\nBut the forced decision says that if both are bad, pick the one with correct loop types. Since both have correct loop types, then we look at the next criteria, which is nesting depth. But both have incorrect nesting depth.\n\nWait, maybe the source's do-while is considered the outermost loop, and the for loop is the innermost loop. In A and B, the do-while is outermost, then switch, then for loop. So the source has the for loop at the same level as the do-while, but A and B have it nested deeper.\n\nTherefore, the source's loop structure is better because the for loop is directly under the do-while, whereas in A and B, it's under the switch.\n\nSo, in terms of topological shape, the source's AST is closer because the nesting depth matches. But A and B have the for loop under the switch, which is not matching the source's structure.\n\nAdditionally, both A and B have extra goto jumps, which are unnecessary.\n\nSo, considering all this, the source is the closest, but since we have to choose between A and B, and both are equally bad, perhaps we have to pick based on other factors.\n\nBut the problem says that if both are bad, pick the one with correct loop types, then correct nesting depth.\n\nSince both have correct loop types, then we look at nesting depth. But both have incorrect nesting depth. So maybe they are equally bad, but since the source uses if statements, and A and B use goto, perhaps A and B are worse because they use goto.\n\nBut the problem says that loop types are more important. So if both have correct loop types, then nesting depth is the next.\n\nBut both have incorrect nesting depth.\n\nWait, maybe"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      \n      do{\n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n        }\n        if()goto label\n        \n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 8.375,
          "base_ppl": 3.390625,
          "pr_ppl": 3.4375,
          "source_ast_ppl": 70.0,
          "base_ast_ppl": 9.1875,
          "pr_ast_ppl": 9.3125,
          "delta_ppl": 0.046875
        },
        "llm_qualitative": {
          "motivation": "Candidate A perfectly replicates the original code's semantic behavior, including bitwise operations and loop structure, making it the most accurate and human-readable choice.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "A recovered the for-loop while B used while-goto, which is unnecessary and adds complexity. A's structure is closer to the Source's AST structure without unnecessary complexity.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            if(){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            if(){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.25,
          "base_ppl": 3.4375,
          "pr_ppl": 3.4375,
          "source_ast_ppl": 5.15625,
          "base_ast_ppl": 9.3125,
          "pr_ast_ppl": 9.3125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more human-readable and maintains a structure closer to the original C code despite minor issues with formatting and variable naming conventions. Its code style is more procedural and easier to follow.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 3.828125,
          "pr_ppl": 3.828125,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 9.625,
          "pr_ast_ppl": 9.625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and standard because it uses camelCase variable naming consistently with conventional C practices, making the codebase easier to maintain and less cluttered with underscores which can be harder to read.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_por-O0.so",
        "function": "readstat_parse_por",
        "source_code": "readstat_error_t readstat_parse_por(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    unsigned char reverse_lookup[256];\n    char vanity[5][40];\n    char error_buf[1024];\n\n    por_ctx_t *ctx = por_ctx_init();\n    \n    ctx->handle = parser->handlers;\n    ctx->user_ctx = user_ctx;\n    ctx->io = io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (parser->output_encoding) {\n        if (strcmp(parser->output_encoding, \"UTF-8\") != 0)\n            ctx->converter = iconv_open(parser->output_encoding, \"UTF-8\");\n\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n    \n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n    \n    if (read_bytes(ctx, vanity, sizeof(vanity)) != sizeof(vanity)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    retval = readstat_convert(ctx->file_label, sizeof(ctx->file_label), vanity[1] + 20, 20, NULL);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if (read_bytes(ctx, reverse_lookup, sizeof(reverse_lookup)) != sizeof(reverse_lookup)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n    \n    ctx->space = reverse_lookup[126];\n\n    int i;\n\n    for (i=0; i<256; i++) {\n        if (por_ascii_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_ascii_lookup[i];\n        } else if (por_unicode_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_unicode_lookup[i];\n        }\n    }\n\n    ctx->byte2unicode[reverse_lookup[64]] = por_unicode_lookup[64];\n\n    unsigned char check[8];\n    char tr_check[8];\n    \n    if (read_bytes(ctx, check, sizeof(check)) != sizeof(check)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ssize_t encoded_len;\n\n    if ((encoded_len = por_utf8_encode(check, sizeof(check), tr_check, sizeof(tr_check), ctx->byte2unicode)) == -1) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error converting check string: %.*s\", (int)sizeof(check), check);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_CONVERT;\n        goto cleanup;\n    }\n\n    if (strncmp(\"SPSSPORT\", tr_check, encoded_len) != 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n    \n    ctx->var_offset = -1;\n    \n    char string[256];\n\n    retval = read_version_and_timestamp(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n\n    while (1) {\n        uint16_t tr_tag = read_tag(ctx);\n        switch (tr_tag) {\n            case '1': /* product ID */\n            case '2': /* author ID */\n            case '3': /* sub-product ID */\n                retval = read_string(ctx, string, sizeof(string));\n                break;\n            case '4': /* variable count */\n                retval = read_variable_count_record(ctx);\n                break;\n            case '5': /* precision */\n                retval = read_precision_record(ctx);\n                break;\n            case '6': /* case weight */\n                retval = read_case_weight_record(ctx);\n                break;\n            case '7': /* variable */\n                retval = read_variable_record(ctx);\n                break;\n            case '8': /* missing value */\n                retval = read_missing_value_record(ctx);\n                break;\n            case 'B': /* missing value range */\n                retval = read_missing_value_range_record(ctx);\n                break;\n            case '9': /* LO THRU x */\n                retval = read_missing_value_lo_range_record(ctx);\n                break;\n            case 'A': /* x THRU HI */\n                retval = read_missing_value_hi_range_record(ctx);\n                break;\n            case 'C': /* variable label */\n                retval = read_variable_label_record(ctx);\n                break;\n            case 'D': /* value label */\n                retval = read_value_label_record(ctx);\n                break;\n            case 'E': /* document record */\n                retval = read_document_record(ctx);\n                break;\n            case 'F': /* file data */\n                if (ctx->var_offset != ctx->var_count - 1) {\n                    retval = READSTAT_ERROR_COLUMN_COUNT_MISMATCH;\n                    goto cleanup;\n                }\n\n                retval = handle_variables(ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                if (ctx->handle.value) {\n                    retval = read_por_file_data(ctx);\n                }\n                goto cleanup;\n            default:\n                retval = READSTAT_ERROR_PARSE;\n                goto cleanup;\n        }\n        if (retval != READSTAT_OK)\n            break;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n    por_ctx_free(ctx);\n    \n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_por(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  iconv_t pvVar3;\n  long lVar4;\n  undefined1 local_738 [264];\n  size_t local_630;\n  char local_624 [8];\n  undefined1 local_61c [8];\n  int local_614;\n  void *local_610;\n  char local_608 [1024];\n  undefined1 local_208 [60];\n  undefined1 auStack_1cc [148];\n  byte local_138 [264];\n  undefined8 *local_30;\n  int local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_24 = 0;\n  local_30 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_610 = (void *)por_ctx_init();\n  memcpy(local_610,local_10,0x40);\n  *(undefined8 *)((long)local_610 + 0x48) = local_20;\n  *(undefined8 **)((long)local_610 + 0x58) = local_30;\n  *(int *)((long)local_610 + 0x2d0) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)local_610 + 0x2d4) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  if (*(long *)((long)local_10 + 0x50) != 0) {\n    iVar2 = strcmp(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n    if (iVar2 != 0) {\n      pvVar3 = iconv_open(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n      *(iconv_t *)((long)local_610 + 0x2a8) = pvVar3;\n    }\n    if (*(long *)((long)local_610 + 0x2a8) == -1) {\n      *(undefined8 *)((long)local_610 + 0x2a8) = 0;\n      local_24 = 7;\n      goto LAB_00101f5b;\n    }\n  }\n  iVar2 = (*(code *)*local_30)(local_18,local_30[5]);\n  if (iVar2 == -1) {\n    local_24 = 1;\n  }\n  else {\n    lVar4 = (*(code *)local_30[2])(0,2,local_30[5]);\n    *(long *)((long)local_610 + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_24 = 0xf;\n    }\n    else {\n      lVar4 = (*(code *)local_30[2])(0,0,local_30[5]);\n      if (lVar4 == -1) {\n        local_24 = 0xf;\n      }\n      else {\n        lVar4 = read_bytes(local_610,local_208,200);\n        if (lVar4 == 200) {\n          local_24 = readstat_convert((long)local_610 + 0x89,0x15,auStack_1cc,0x14,0);\n          if (local_24 == 0) {\n            lVar4 = read_bytes(local_610,local_138,0x100);\n            if (lVar4 == 0x100) {\n              *(byte *)((long)local_610 + 0x60) = local_138[0x7e];\n              for (local_614 = 0; local_614 < 0x100; local_614 = local_614 + 1) {\n                if (PTR_por_ascii_lookup_00105fe8[local_614] == '\\0') {\n                  if (*(short *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2) != 0) {\n                    *(undefined2 *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                         *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2);\n                  }\n                }\n                else {\n                  *(short *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                       (short)(char)PTR_por_ascii_lookup_00105fe8[local_614];\n                }\n              }\n              *(undefined2 *)((long)local_610 + (ulong)local_138[0x40] * 2 + 0x9e) =\n                   *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + 0x80);\n              lVar4 = read_bytes(local_610,local_61c,8);\n              if (lVar4 == 8) {\n                local_630 = por_utf8_encode(local_61c,8,local_624,8,(long)local_610 + 0x9e);\n                if (local_630 == 0xffffffffffffffff) {\n                  if (*(long *)((long)local_610 + 0x30) != 0) {\n                    snprintf(local_608,0x400,\"Error converting check string: %.*s\",8,local_61c);\n                    (**(code **)((long)local_610 + 0x30))\n                              (local_608,*(undefined8 *)((long)local_610 + 0x48));\n                  }\n                  local_24 = 0x10;\n                }\n                else {\n                  iVar2 = strncmp(\"SPSSPORT\",local_624,local_630);\n                  if (iVar2 == 0) {\n                    *(undefined4 *)((long)local_610 + 0x2cc) = 0xffffffff;\n                    local_24 = read_version_and_timestamp(local_610);\n                    if (local_24 == 0) {\n                      local_24 = 0;\n                      do {\n                        uVar1 = read_tag(local_610);\n                        switch(uVar1) {\n                        case 0x31:\n                        case 0x32:\n                        case 0x33:\n                          local_24 = read_string(local_610,local_738,0x100);\n                          break;\n                        case 0x34:\n                          local_24 = read_variable_count_record(local_610);\n                          break;\n                        case 0x35:\n                          local_24 = read_precision_record(local_610);\n                          break;\n                        case 0x36:\n                          local_24 = read_case_weight_record(local_610);\n                          break;\n                        case 0x37:\n                          local_24 = read_variable_record(local_610);\n                          break;\n                        case 0x38:\n                          local_24 = read_missing_value_record(local_610);\n                          break;\n                        case 0x39:\n                          local_24 = read_missing_value_lo_range_record(local_610);\n                          break;\n                        default:\n                          local_24 = 5;\n                          goto LAB_00101f5b;\n                        case 0x41:\n                          local_24 = read_missing_value_hi_range_record(local_610);\n                          break;\n                        case 0x42:\n                          local_24 = read_missing_value_range_record(local_610);\n                          break;\n                        case 0x43:\n                          local_24 = read_variable_label_record(local_610);\n                          break;\n                        case 0x44:\n                          local_24 = read_value_label_record(local_610);\n                          break;\n                        case 0x45:\n                          local_24 = read_document_record(local_610);\n                          break;\n                        case 0x46:\n                          if (*(int *)((long)local_610 + 0x2cc) ==\n                              *(int *)((long)local_610 + 0x2c8) + -1) {\n                            local_24 = handle_variables(local_610);\n                            if ((local_24 == 0) && (*(long *)((long)local_610 + 0x20) != 0)) {\n                              local_24 = read_por_file_data(local_610);\n                            }\n                          }\n                          else {\n                            local_24 = 8;\n                          }\n                          goto LAB_00101f5b;\n                        }\n                      } while (local_24 == 0);\n                    }\n                  }\n                  else {\n                    local_24 = 5;\n                  }\n                }\n              }\n              else {\n                local_24 = 2;\n              }\n            }\n            else {\n              local_24 = 2;\n            }\n          }\n        }\n        else {\n          local_24 = 2;\n        }\n      }\n    }\n  }\nLAB_00101f5b:\n  (*(code *)local_30[1])(local_30[5]);\n  por_ctx_free(local_610);\n  return local_24;\n}\n\n",
        "function_pr": "\nint readstat_parse_por(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  iconv_t pvVar3;\n  long lVar4;\n  undefined local_738 [264];\n  size_t local_630;\n  char local_624 [8];\n  undefined local_61c [8];\n  int local_614;\n  void *local_610;\n  char local_608 [1024];\n  undefined local_208 [60];\n  undefined auStack_1cc [148];\n  byte local_138 [264];\n  undefined8 *local_30;\n  int local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_24 = 0;\n  local_30 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_610 = (void *)por_ctx_init();\n  memcpy(local_610,local_10,0x40);\n  *(undefined8 *)((long)local_610 + 0x48) = local_20;\n  *(undefined8 **)((long)local_610 + 0x58) = local_30;\n  *(int *)((long)local_610 + 0x2d0) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)local_610 + 0x2d4) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  if (*(long *)((long)local_10 + 0x50) != 0) {\n    iVar2 = strcmp(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n    if (iVar2 != 0) {\n      pvVar3 = iconv_open(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n      *(iconv_t *)((long)local_610 + 0x2a8) = pvVar3;\n    }\n    if (*(long *)((long)local_610 + 0x2a8) == -1) {\n      *(undefined8 *)((long)local_610 + 0x2a8) = 0;\n      local_24 = 7;\n      goto LAB_00101f5b;\n    }\n  }\n  iVar2 = (*(code *)*local_30)(local_18,local_30[5]);\n  if (iVar2 == -1) {\n    local_24 = 1;\n  }\n  else {\n    lVar4 = (*(code *)local_30[2])(0,2,local_30[5]);\n    *(long *)((long)local_610 + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_24 = 0xf;\n    }\n    else {\n      lVar4 = (*(code *)local_30[2])(0,0,local_30[5]);\n      if (lVar4 == -1) {\n        local_24 = 0xf;\n      }\n      else {\n        lVar4 = read_bytes(local_610,local_208,200);\n        if (lVar4 == 200) {\n          local_24 = readstat_convert((long)local_610 + 0x89,0x15,auStack_1cc,0x14,0);\n          if (local_24 == 0) {\n            lVar4 = read_bytes(local_610,local_138,0x100);\n            if (lVar4 == 0x100) {\n              *(byte *)((long)local_610 + 0x60) = local_138[0x7e];\n              for (local_614 = 0; local_614 < 0x100; local_614 = local_614 + 1) {\n                if (PTR_por_ascii_lookup_00105fe8[local_614] == '\\0') {\n                  if (*(short *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2) != 0) {\n                    *(undefined2 *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                         *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2);\n                  }\n                }\n                else {\n                  *(short *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                       (short)(char)PTR_por_ascii_lookup_00105fe8[local_614];\n                }\n              }\n              *(undefined2 *)((long)local_610 + (ulong)local_138[0x40] * 2 + 0x9e) =\n                   *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + 0x80);\n              lVar4 = read_bytes(local_610,local_61c,8);\n              if (lVar4 == 8) {\n                local_630 = por_utf8_encode(local_61c,8,local_624,8,(long)local_610 + 0x9e);\n                if (local_630 == 0xffffffffffffffff) {\n                  if (*(long *)((long)local_610 + 0x30) != 0) {\n                    snprintf(local_608,0x400,\"Error converting check string: %.*s\",8,local_61c);\n                    (**(code **)((long)local_610 + 0x30))\n                              (local_608,*(undefined8 *)((long)local_610 + 0x48));\n                  }\n                  local_24 = 0x10;\n                }\n                else {\n                  iVar2 = strncmp(\"SPSSPORT\",local_624,local_630);\n                  if (iVar2 == 0) {\n                    *(undefined4 *)((long)local_610 + 0x2cc) = 0xffffffff;\n                    local_24 = read_version_and_timestamp(local_610);\n                    if (local_24 == 0) {\n                      local_24 = 0;\n                      do {\n                        uVar1 = read_tag(local_610);\n                        switch(uVar1) {\n                        case 0x31:\n                        case 0x32:\n                        case 0x33:\n                          local_24 = read_string(local_610,local_738,0x100);\n                          break;\n                        case 0x34:\n                          local_24 = read_variable_count_record(local_610);\n                          break;\n                        case 0x35:\n                          local_24 = read_precision_record(local_610);\n                          break;\n                        case 0x36:\n                          local_24 = read_case_weight_record(local_610);\n                          break;\n                        case 0x37:\n                          local_24 = read_variable_record(local_610);\n                          break;\n                        case 0x38:\n                          local_24 = read_missing_value_record(local_610);\n                          break;\n                        case 0x42:\n                          local_24 = read_missing_value_range_record(local_610);\n                          break;\n                        case 0x39:\n                          local_24 = read_missing_value_lo_range_record(local_610);\n                          break;\n                        case 0x41:\n                          local_24 = read_missing_value_hi_range_record(local_610);\n                          break;\n                        case 0x43:\n                          local_24 = read_variable_label_record(local_610);\n                          break;\n                        case 0x44:\n                          local_24 = read_value_label_record(local_610);\n                          break;\n                        case 0x45:\n                          local_24 = read_document_record(local_610);\n                          break;\n                        case 0x46:\n                          if (*(int *)((long)local_610 + 0x2cc) ==\n                              *(int *)((long)local_610 + 0x2c8) + -1) {\n                            local_24 = handle_variables(local_610);\n                            if ((local_24 == 0) && (*(long *)((long)local_610 + 0x20) != 0)) {\n                              local_24 = read_por_file_data(local_610);\n                            }\n                          }\n                          else {\n                            local_24 = 8;\n                          }\n                          goto LAB_00101f5b;\n                        default:\n                          local_24 = 5;\n                          goto LAB_00101f5b;\n                        }\n                      } while (local_24 == 0);\n                    }\n                  }\n                  else {\n                    local_24 = 5;\n                  }\n                }\n              }\n              else {\n                local_24 = 2;\n              }\n            }\n            else {\n              local_24 = 2;\n            }\n          }\n        }\n        else {\n          local_24 = 2;\n        }\n      }\n    }\n  }\nLAB_00101f5b:\n  (*(code *)local_30[1])(local_30[5]);\n  por_ctx_free(local_610);\n  return local_24;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  if()\n  if(){\n    if(call(, ))call(, )\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , , , )\n  if()goto label\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  for(;;){\n    if(){\n      \n    }elseif(){\n      \n    }\n  }\n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , , , )){\n    if(){\n      call(, , , , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  call()\n  if()goto label\n  while(){\n    call()\n    switch(){\n      case :\n      \n      case :\n      \n      case :\n        \n        call(, , )\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        if(){\n          \n          goto label\n        }\n        call()\n        if()goto label\n        if(){\n          call()\n        }\n        goto label\n      case :\n        \n        \n        goto label\n    }\n    if()\n  }\n  call()\n  call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, , )\n  \n  \n  \n  if(){\n    \n  }\n  if(){\n    call(, )\n    if(){\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n    }else{\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          call(, , , , )\n          if(){\n            call(, , )\n            if(){\n              \n              for(;;){\n                if(){\n                  if(){\n                    \n                  }\n                }else{\n                  \n                }\n              }\n              \n              call(, , )\n              if(){\n                call(, , , , )\n                if(){\n                  if(){\n                    call(, , , , )\n                    call(, )\n                  }\n                  \n                }else{\n                  call(, , )\n                  if(){\n                    \n                    call()\n                    if(){\n                      \n                      do{\n                        call()\n                        switch(){\n                          case :\n                          case :\n                          case :\n                            call(, , )\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            \n                            \n                            goto label\n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            if(){\n                              call()\n                              if(){\n                                call()\n                              }\n                            }else{\n                              \n                            }\n                            goto label\n                        }\n                      }while()\n                    }\n                  }else{\n                    \n                  }\n                }\n              }else{\n                \n              }\n            }else{\n              \n            }\n          }\n        }else{\n          \n        }\n      }\n    }\n  }\n  call()\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, , )\n  \n  \n  \n  if(){\n    \n  }\n  if(){\n    call(, )\n    if(){\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n    }else{\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          call(, , , , )\n          if(){\n            call(, , )\n            if(){\n              \n              for(;;){\n                if(){\n                  if(){\n                    \n                  }\n                }else{\n                  \n                }\n              }\n              \n              call(, , )\n              if(){\n                call(, , , , )\n                if(){\n                  if(){\n                    call(, , , , )\n                    call(, )\n                  }\n                  \n                }else{\n                  call(, , )\n                  if(){\n                    \n                    call()\n                    if(){\n                      \n                      do{\n                        call()\n                        switch(){\n                          case :\n                          case :\n                          case :\n                            call(, , )\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            if(){\n                              call()\n                              if(){\n                                call()\n                              }\n                            }else{\n                              \n                            }\n                            goto label\n                          case :\n                            \n                            \n                            goto label\n                        }\n                      }while()\n                    }\n                  }else{\n                    \n                  }\n                }\n              }else{\n                \n              }\n            }else{\n              \n            }\n          }\n        }else{\n          \n        }\n      }\n    }\n  }\n  call()\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 5.28125,
          "base_ppl": 3.75,
          "pr_ppl": 3.75,
          "source_ast_ppl": 4.78125,
          "base_ast_ppl": 5.375,
          "pr_ast_ppl": 5.3125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "motivation": "A recovered the for-loop while B used while-goto, which is not present in the Source. Additionally, A maintains the correct nesting depth and structure, whereas B introduces unnecessary complexity with do-while loops.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_ctx_init-O0.so",
        "function": "dta_ctx_init",
        "source_code": "readstat_error_t dta_ctx_init(dta_ctx_t *ctx, uint32_t nvar, uint64_t nobs,\n        unsigned char byteorder, unsigned char ds_format,\n        const char *input_encoding, const char *output_encoding) {\n    readstat_error_t retval = READSTAT_OK;\n    int machine_byteorder = DTA_HILO;\n    if (ds_format < DTA_MIN_VERSION || ds_format > DTA_MAX_VERSION)\n        return READSTAT_ERROR_UNSUPPORTED_FILE_FORMAT_VERSION;\n\n    if (machine_is_little_endian()) {\n        machine_byteorder = DTA_LOHI;\n    }\n\n    ctx->bswap = (byteorder != machine_byteorder);\n    ctx->ds_format = ds_format;\n    ctx->endianness = byteorder == DTA_LOHI ? READSTAT_ENDIAN_LITTLE : READSTAT_ENDIAN_BIG;\n\n    ctx->nvar = nvar;\n    ctx->nobs = nobs;\n\n    if (ctx->nvar) {\n        if ((ctx->variables = readstat_calloc(ctx->nvar, sizeof(readstat_variable_t *))) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n    }\n\n    ctx->machine_is_twos_complement = READSTAT_MACHINE_IS_TWOS_COMPLEMENT;\n\n    if (ds_format < 105) {\n        ctx->fmtlist_entry_len = 7;\n    } else if (ds_format < 114) {\n        ctx->fmtlist_entry_len = 12;\n    } else if (ds_format < 118) {\n        ctx->fmtlist_entry_len = 49;\n    } else {\n        ctx->fmtlist_entry_len = 57;\n    }\n    \n    if (ds_format >= 117) {\n        ctx->typlist_version = 117;\n    } else if (ds_format >= 111) {\n        ctx->typlist_version = 111;\n    } else {\n        ctx->typlist_version = 0;\n    }\n\n    if (ds_format >= 118) {\n        ctx->data_label_len_len = 2;\n        ctx->strl_v_len = 2;\n        ctx->strl_o_len = 6;\n    } else if (ds_format >= 117) {\n        ctx->data_label_len_len = 1;\n        ctx->strl_v_len = 4;\n        ctx->strl_o_len = 4;\n    }\n\n    if (ds_format < 105) {\n        ctx->expansion_len_len = 0;\n    } else if (ds_format < 110) {\n        ctx->expansion_len_len = 2;\n    } else {\n        ctx->expansion_len_len = 4;\n    }\n    \n    if (ds_format < 110) {\n        ctx->lbllist_entry_len = 9;\n        ctx->variable_name_len = 9;\n        ctx->ch_metadata_len = 9;\n    } else if (ds_format < 118) {\n        ctx->lbllist_entry_len = 33;\n        ctx->variable_name_len = 33;\n        ctx->ch_metadata_len = 33;\n    } else {\n        ctx->lbllist_entry_len = 129;\n        ctx->variable_name_len = 129;\n        ctx->ch_metadata_len = 129;\n    }\n\n    if (ds_format < 108) {\n        ctx->variable_labels_entry_len = 32;\n        ctx->data_label_len = 32;\n    } else if (ds_format < 118) {\n        ctx->variable_labels_entry_len = 81;\n        ctx->data_label_len = 81;\n    } else {\n        ctx->variable_labels_entry_len = 321;\n        ctx->data_label_len = 321;\n    }\n\n    if (ds_format < 105) {\n        ctx->timestamp_len = 0;\n        ctx->value_label_table_len_len = 2;\n        ctx->value_label_table_labname_len = 12;\n        ctx->value_label_table_padding_len = 2;\n    } else {\n        ctx->timestamp_len = 18;\n        ctx->value_label_table_len_len = 4;\n        if (ds_format < 118) {\n            ctx->value_label_table_labname_len = 33;\n        } else {\n            ctx->value_label_table_labname_len = 129;\n        }\n        ctx->value_label_table_padding_len = 3;\n    }\n\n    if (ds_format < 117) {\n        ctx->typlist_entry_len = 1;\n        ctx->file_is_xmlish = 0;\n    } else {\n        ctx->typlist_entry_len = 2;\n        ctx->file_is_xmlish = 1;\n    }\n\n    if (ds_format < 113) {\n        ctx->max_int8 = DTA_OLD_MAX_INT8;\n        ctx->max_int16 = DTA_OLD_MAX_INT16;\n        ctx->max_int32 = DTA_OLD_MAX_INT32;\n        ctx->max_float = DTA_OLD_MAX_FLOAT;\n        ctx->max_double = DTA_OLD_MAX_DOUBLE;\n    } else {\n        ctx->max_int8 = DTA_113_MAX_INT8;\n        ctx->max_int16 = DTA_113_MAX_INT16;\n        ctx->max_int32 = DTA_113_MAX_INT32;\n        ctx->max_float = DTA_113_MAX_FLOAT;\n        ctx->max_double = DTA_113_MAX_DOUBLE;\n\n        ctx->supports_tagged_missing = 1;\n    }\n\n    if (output_encoding) {\n        if (input_encoding) {\n            ctx->converter = iconv_open(output_encoding, input_encoding);\n        } else if (ds_format < 118) {\n            ctx->converter = iconv_open(output_encoding, \"WINDOWS-1252\");\n        } else if (strcmp(output_encoding, \"UTF-8\") != 0) {\n            ctx->converter = iconv_open(output_encoding, \"UTF-8\");\n        }\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n\n    if (ds_format < 119) {\n        ctx->srtlist_len = (ctx->nvar + 1) * sizeof(int16_t);\n    } else {\n        ctx->srtlist_len = (ctx->nvar + 1) * sizeof(int32_t);\n    }\n\n    if ((ctx->srtlist = readstat_malloc(ctx->srtlist_len)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->nvar > 0) {\n        ctx->typlist_len = ctx->nvar * sizeof(uint16_t);\n        ctx->varlist_len = ctx->variable_name_len * ctx->nvar * sizeof(char);\n        ctx->fmtlist_len = ctx->fmtlist_entry_len * ctx->nvar * sizeof(char);\n        ctx->lbllist_len = ctx->lbllist_entry_len * ctx->nvar * sizeof(char);\n        ctx->variable_labels_len = ctx->variable_labels_entry_len * ctx->nvar * sizeof(char);\n\n        if ((ctx->typlist = readstat_malloc(ctx->typlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->varlist = readstat_malloc(ctx->varlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->fmtlist = readstat_malloc(ctx->fmtlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->lbllist = readstat_malloc(ctx->lbllist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->variable_labels = readstat_malloc(ctx->variable_labels_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n    }\n\n    ctx->initialized = 1;\n\ncleanup:\n    return retval;\n}\n",
        "function_base": "\nundefined4\ndta_ctx_init(long param_1,undefined4 param_2,undefined8 param_3,char param_4,byte param_5,\n            char *param_6,char *param_7)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  iconv_t pvVar4;\n  undefined4 uVar5;\n  \n  cVar1 = '\\x01';\n  if ((param_5 < 0x68) || (0x77 < param_5)) {\n    return 0x18;\n  }\n  iVar2 = machine_is_little_endian();\n  if (iVar2 != 0) {\n    cVar1 = '\\x02';\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfe | param_4 != cVar1;\n  *(uint *)(param_1 + 0x108) = (uint)param_5;\n  uVar5 = 2;\n  if (param_4 == '\\x02') {\n    uVar5 = 1;\n  }\n  *(undefined4 *)(param_1 + 0x170) = uVar5;\n  *(undefined4 *)(param_1 + 0x10c) = param_2;\n  *(undefined8 *)(param_1 + 0x110) = param_3;\n  if (*(int *)(param_1 + 0x10c) != 0) {\n    lVar3 = readstat_calloc((long)*(int *)(param_1 + 0x10c),8);\n    *(long *)(param_1 + 0x168) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfd;\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xa0) = 7;\n  }\n  else if (param_5 < 0x72) {\n    *(undefined8 *)(param_1 + 0xa0) = 0xc;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa0) = 0x31;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa0) = 0x39;\n  }\n  if (param_5 < 0x75) {\n    if (param_5 < 0x6f) {\n      *(undefined1 *)(param_1 + 0x28) = 0;\n    }\n    else {\n      *(undefined1 *)(param_1 + 0x28) = 0x6f;\n    }\n  }\n  else {\n    *(undefined1 *)(param_1 + 0x28) = 0x75;\n  }\n  if (param_5 < 0x76) {\n    if (0x74 < param_5) {\n      *(undefined8 *)(param_1 + 0x10) = 1;\n      *(undefined8 *)(param_1 + 0xe0) = 4;\n      *(undefined8 *)(param_1 + 0xe8) = 4;\n    }\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x10) = 2;\n    *(undefined8 *)(param_1 + 0xe0) = 2;\n    *(undefined8 *)(param_1 + 0xe8) = 6;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xb8) = 0;\n  }\n  else if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xb8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb8) = 4;\n  }\n  if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xa8) = 9;\n    *(undefined8 *)(param_1 + 0x98) = 9;\n    *(undefined8 *)(param_1 + 0xc0) = 9;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa8) = 0x21;\n    *(undefined8 *)(param_1 + 0x98) = 0x21;\n    *(undefined8 *)(param_1 + 0xc0) = 0x21;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa8) = 0x81;\n    *(undefined8 *)(param_1 + 0x98) = 0x81;\n    *(undefined8 *)(param_1 + 0xc0) = 0x81;\n  }\n  if (param_5 < 0x6c) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x20;\n    *(undefined8 *)(param_1 + 8) = 0x20;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x51;\n    *(undefined8 *)(param_1 + 8) = 0x51;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb0) = 0x141;\n    *(undefined8 *)(param_1 + 8) = 0x141;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n    *(undefined8 *)(param_1 + 200) = 2;\n    *(undefined8 *)(param_1 + 0xd0) = 0xc;\n    *(undefined8 *)(param_1 + 0xd8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x20) = 0x12;\n    *(undefined8 *)(param_1 + 200) = 4;\n    if (param_5 < 0x76) {\n      *(undefined8 *)(param_1 + 0xd0) = 0x21;\n    }\n    else {\n      *(undefined8 *)(param_1 + 0xd0) = 0x81;\n    }\n    *(undefined8 *)(param_1 + 0xd8) = 3;\n  }\n  if (param_5 < 0x75) {\n    *(undefined8 *)(param_1 + 0x30) = 1;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x30) = 2;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb | 4;\n  }\n  if (param_5 < 0x71) {\n    *(undefined1 *)(param_1 + 0x139) = 0x7e;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7ffe;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7ffffffe;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n  }\n  else {\n    *(undefined1 *)(param_1 + 0x139) = 100;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7fe4;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7fffffe4;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xf7 | 8;\n  }\n  if (param_7 != (char *)0x0) {\n    if (param_6 == (char *)0x0) {\n      if (param_5 < 0x76) {\n        pvVar4 = iconv_open(param_7,\"WINDOWS-1252\");\n        *(iconv_t *)(param_1 + 0x178) = pvVar4;\n      }\n      else {\n        iVar2 = strcmp(param_7,\"UTF-8\");\n        if (iVar2 != 0) {\n          pvVar4 = iconv_open(param_7,\"UTF-8\");\n          *(iconv_t *)(param_1 + 0x178) = pvVar4;\n        }\n      }\n    }\n    else {\n      pvVar4 = iconv_open(param_7,param_6);\n      *(iconv_t *)(param_1 + 0x178) = pvVar4;\n    }\n    if (*(long *)(param_1 + 0x178) == -1) {\n      *(undefined8 *)(param_1 + 0x178) = 0;\n      return 7;\n    }\n  }\n  if (param_5 < 0x77) {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 1;\n  }\n  else {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 2;\n  }\n  lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x60));\n  *(long *)(param_1 + 0x58) = lVar3;\n  if (lVar3 == 0) {\n    return 3;\n  }\n  if (0 < *(int *)(param_1 + 0x10c)) {\n    *(long *)(param_1 + 0x40) = (long)*(int *)(param_1 + 0x10c) << 1;\n    *(long *)(param_1 + 0x50) = *(long *)(param_1 + 0x98) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x70) = *(long *)(param_1 + 0xa0) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x80) = *(long *)(param_1 + 0xa8) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x90) = *(long *)(param_1 + 0xb0) * (long)*(int *)(param_1 + 0x10c);\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x40));\n    *(long *)(param_1 + 0x38) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x50));\n    *(long *)(param_1 + 0x48) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x70));\n    *(long *)(param_1 + 0x68) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x80));\n    *(long *)(param_1 + 0x78) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x90));\n    *(long *)(param_1 + 0x88) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(undefined4 *)(param_1 + 0x1d8) = 1;\n  return 0;\n}\n\n",
        "function_pr": "\nundefined4\ndta_ctx_init(long param_1,undefined4 param_2,undefined8 param_3,char param_4,byte param_5,\n            char *param_6,char *param_7)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  iconv_t pvVar4;\n  undefined4 uVar5;\n  \n  cVar1 = '\\x01';\n  if ((param_5 < 0x68) || (0x77 < param_5)) {\n    return 0x18;\n  }\n  iVar2 = machine_is_little_endian();\n  if (iVar2 != 0) {\n    cVar1 = '\\x02';\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfe | param_4 != cVar1;\n  *(uint *)(param_1 + 0x108) = (uint)param_5;\n  uVar5 = 2;\n  if (param_4 == '\\x02') {\n    uVar5 = 1;\n  }\n  *(undefined4 *)(param_1 + 0x170) = uVar5;\n  *(undefined4 *)(param_1 + 0x10c) = param_2;\n  *(undefined8 *)(param_1 + 0x110) = param_3;\n  if (*(int *)(param_1 + 0x10c) != 0) {\n    lVar3 = readstat_calloc((long)*(int *)(param_1 + 0x10c),8);\n    *(long *)(param_1 + 0x168) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfd;\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xa0) = 7;\n  }\n  else if (param_5 < 0x72) {\n    *(undefined8 *)(param_1 + 0xa0) = 0xc;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa0) = 0x31;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa0) = 0x39;\n  }\n  if (param_5 < 0x75) {\n    if (param_5 < 0x6f) {\n      *(undefined *)(param_1 + 0x28) = 0;\n    }\n    else {\n      *(undefined *)(param_1 + 0x28) = 0x6f;\n    }\n  }\n  else {\n    *(undefined *)(param_1 + 0x28) = 0x75;\n  }\n  if (param_5 < 0x76) {\n    if (0x74 < param_5) {\n      *(undefined8 *)(param_1 + 0x10) = 1;\n      *(undefined8 *)(param_1 + 0xe0) = 4;\n      *(undefined8 *)(param_1 + 0xe8) = 4;\n    }\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x10) = 2;\n    *(undefined8 *)(param_1 + 0xe0) = 2;\n    *(undefined8 *)(param_1 + 0xe8) = 6;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xb8) = 0;\n  }\n  else if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xb8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb8) = 4;\n  }\n  if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xa8) = 9;\n    *(undefined8 *)(param_1 + 0x98) = 9;\n    *(undefined8 *)(param_1 + 0xc0) = 9;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa8) = 0x21;\n    *(undefined8 *)(param_1 + 0x98) = 0x21;\n    *(undefined8 *)(param_1 + 0xc0) = 0x21;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa8) = 0x81;\n    *(undefined8 *)(param_1 + 0x98) = 0x81;\n    *(undefined8 *)(param_1 + 0xc0) = 0x81;\n  }\n  if (param_5 < 0x6c) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x20;\n    *(undefined8 *)(param_1 + 8) = 0x20;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x51;\n    *(undefined8 *)(param_1 + 8) = 0x51;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb0) = 0x141;\n    *(undefined8 *)(param_1 + 8) = 0x141;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n    *(undefined8 *)(param_1 + 200) = 2;\n    *(undefined8 *)(param_1 + 0xd0) = 0xc;\n    *(undefined8 *)(param_1 + 0xd8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x20) = 0x12;\n    *(undefined8 *)(param_1 + 200) = 4;\n    if (param_5 < 0x76) {\n      *(undefined8 *)(param_1 + 0xd0) = 0x21;\n    }\n    else {\n      *(undefined8 *)(param_1 + 0xd0) = 0x81;\n    }\n    *(undefined8 *)(param_1 + 0xd8) = 3;\n  }\n  if (param_5 < 0x75) {\n    *(undefined8 *)(param_1 + 0x30) = 1;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x30) = 2;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb | 4;\n  }\n  if (param_5 < 0x71) {\n    *(undefined *)(param_1 + 0x139) = 0x7e;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7ffe;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7ffffffe;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n  }\n  else {\n    *(undefined *)(param_1 + 0x139) = 100;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7fe4;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7fffffe4;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xf7 | 8;\n  }\n  if (param_7 != (char *)0x0) {\n    if (param_6 == (char *)0x0) {\n      if (param_5 < 0x76) {\n        pvVar4 = iconv_open(param_7,\"WINDOWS-1252\");\n        *(iconv_t *)(param_1 + 0x178) = pvVar4;\n      }\n      else {\n        iVar2 = strcmp(param_7,\"UTF-8\");\n        if (iVar2 != 0) {\n          pvVar4 = iconv_open(param_7,\"UTF-8\");\n          *(iconv_t *)(param_1 + 0x178) = pvVar4;\n        }\n      }\n    }\n    else {\n      pvVar4 = iconv_open(param_7,param_6);\n      *(iconv_t *)(param_1 + 0x178) = pvVar4;\n    }\n    if (*(long *)(param_1 + 0x178) == -1) {\n      *(undefined8 *)(param_1 + 0x178) = 0;\n      return 7;\n    }\n  }\n  if (param_5 < 0x77) {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 1;\n  }\n  else {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 2;\n  }\n  lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x60));\n  *(long *)(param_1 + 0x58) = lVar3;\n  if (lVar3 == 0) {\n    return 3;\n  }\n  if (0 < *(int *)(param_1 + 0x10c)) {\n    *(long *)(param_1 + 0x40) = (long)*(int *)(param_1 + 0x10c) << 1;\n    *(long *)(param_1 + 0x50) = *(long *)(param_1 + 0x98) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x70) = *(long *)(param_1 + 0xa0) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x80) = *(long *)(param_1 + 0xa8) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x90) = *(long *)(param_1 + 0xb0) * (long)*(int *)(param_1 + 0x10c);\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x40));\n    *(long *)(param_1 + 0x38) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x50));\n    *(long *)(param_1 + 0x48) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x70));\n    *(long *)(param_1 + 0x68) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x80));\n    *(long *)(param_1 + 0x78) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x90));\n    *(long *)(param_1 + 0x88) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(undefined4 *)(param_1 + 0x1d8) = 1;\n  return 0;\n}\n\n",
        "source_ast": "{\n  \n  \n  if()return\n  if(call()){\n    \n  }\n  \n  \n  (? : )\n  \n  \n  if(){\n    if(call(, )){\n      \n      goto label\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      call(, )\n    }elseif(){\n      call(, )\n    }elseif(call(, )){\n      call(, )\n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(){\n    \n    \n    \n    \n    \n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  call()\n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    call(, )\n    \n    if(){\n      return\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    if(){\n      \n    }else{\n      \n    }\n  }else{\n    \n  }\n  if(){\n    if(){\n      \n      \n      \n    }\n  }else{\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      if(){\n        call(, )\n        \n      }else{\n        call(, )\n        if(){\n          call(, )\n          \n        }\n      }\n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      return\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  call()\n  \n  if(){\n    return\n  }\n  if(){\n    \n    \n    \n    \n    \n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n  }\n  \n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  call()\n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    call(, )\n    \n    if(){\n      return\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    if(){\n      \n    }else{\n      \n    }\n  }else{\n    \n  }\n  if(){\n    if(){\n      \n      \n      \n    }\n  }else{\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      if(){\n        call(, )\n        \n      }else{\n        call(, )\n        if(){\n          call(, )\n          \n        }\n      }\n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      return\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  call()\n  \n  if(){\n    return\n  }\n  if(){\n    \n    \n    \n    \n    \n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n  }\n  \n  return\n}",
        "metrics": {
          "source_ppl": 2.71875,
          "base_ppl": 2.0625,
          "pr_ppl": 2.078125,
          "source_ast_ppl": 8.125,
          "base_ast_ppl": 5.65625,
          "pr_ast_ppl": 5.65625,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      }
    ],
    "llama3.1": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 10:\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n          case :\n            \n            goto label\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 2.34375,
          "pr_ppl": 2.359375,
          "source_ast_ppl": 2.4375,
          "base_ast_ppl": 2.328125,
          "pr_ast_ppl": 2.328125,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 10:\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n          case :\n            \n            goto label\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 2.34375,
          "pr_ppl": 2.359375,
          "source_ast_ppl": 2.4375,
          "base_ast_ppl": 2.328125,
          "pr_ast_ppl": 2.328125,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate due to its clear and structured control flow, concise variable names, and proper use of switch statements, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "A recovered the for-loop while B used while-goto.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_signextend-O0.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "source_ast": "{\n  if(){\n    switch(){\n      \n      case :\n        call(, , )\n        \n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if()call(, , )\n        return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  if(){\n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if(){\n          call(, , )\n        }\n        return\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  if(){\n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if(){\n          call(, , )\n        }\n        return\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.390625,
          "base_ppl": 2.40625,
          "pr_ppl": 2.515625,
          "source_ast_ppl": 2.03125,
          "base_ast_ppl": 2.078125,
          "pr_ast_ppl": 2.078125,
          "delta_ppl": 0.109375
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and idiomatic C due to its use of standard switch-case statements and clear variable type casts, despite having a minor bug, whereas Candidate A has the same logic with minor inaccuracies but uses a less conventional switch-case ordering.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "A recovered the for-loop structure while B used while-goto.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_signextend-O2.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,byte *param_2,long param_3)\n\n{\n  if ((*param_2 & 8) == 0) {\n    switch(param_2[6]) {\n    case 1:\n      return (long)(char)param_3;\n    case 2:\n    case 7:\n    case 10:\n      return (long)(short)param_3;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      return (long)(int)param_3;\n    default:\n      param_3 = -1;\n      if ((*(byte *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\");\n        return -1;\n      }\n    }\n  }\n  return param_3;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,byte *param_2,long param_3)\n\n{\n  if ((*param_2 & 8) == 0) {\n    switch(param_2[6]) {\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      return (long)(int)param_3;\n    case 2:\n    case 7:\n    case 10:\n      return (long)(short)param_3;\n    case 1:\n      return (long)(char)param_3;\n    default:\n      param_3 = -1;\n      if ((*(byte *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\");\n        return -1;\n      }\n    }\n  }\n  return param_3;\n}\n\n",
        "source_ast": "{\n  if(){\n    switch(){\n      \n      case :\n        call(, , )\n        \n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if()call(, , )\n        return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  if(){\n    switch(){\n      case :\n        return\n      case :\n      case :\n      case :\n        return\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        return\n      case :\n        \n        \n        if(){\n          call(, )\n          return\n        }\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  if(){\n    switch(){\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        return\n      case :\n      case :\n      case :\n        return\n      case :\n        return\n      case :\n        \n        \n        if(){\n          call(, )\n          return\n        }\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.390625,
          "base_ppl": 1.890625,
          "pr_ppl": 1.9296875,
          "source_ast_ppl": 2.03125,
          "base_ast_ppl": 1.96875,
          "pr_ast_ppl": 2.046875,
          "delta_ppl": 0.0390625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its clear and concise use of standard loops and conditionals, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "### Winner: A\n\n### Motivation: Candidate A recovered the ForLoop while Candidate B used WhileLoop with Goto, and both have the same nesting depth.\n\n### Analysis:\n\n- **Topological Shape**: Both candidates have the same nesting depth and sequence of blocks, so they tie in this category.\n- **Loop Fidelity**: Candidate A has a `ForLoop` while Candidate B has a `WhileLoop` with a `Goto`, which is less desirable.\n- **Complexity Penalty**: Candidate B has an additional unnecessary `Goto` which incurs a penalty.\n\nTherefore, Candidate A is the winner due to its recovery of the `ForLoop` and its lack of unnecessary complexity."
        }
      },
      {
        "binary": "task-file_file_signextend-O3.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,byte *param_2,long param_3)\n\n{\n  if ((*param_2 & 8) == 0) {\n    switch(param_2[6]) {\n    case 1:\n      return (long)(char)param_3;\n    case 2:\n    case 7:\n    case 10:\n      return (long)(short)param_3;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      return (long)(int)param_3;\n    default:\n      param_3 = -1;\n      if ((*(byte *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\");\n        return -1;\n      }\n    }\n  }\n  return param_3;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,byte *param_2,long param_3)\n\n{\n  if ((*param_2 & 8) == 0) {\n    switch(param_2[6]) {\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      return (long)(int)param_3;\n    case 2:\n    case 7:\n    case 10:\n      return (long)(short)param_3;\n    case 1:\n      return (long)(char)param_3;\n    default:\n      param_3 = -1;\n      if ((*(byte *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\");\n        return -1;\n      }\n    }\n  }\n  return param_3;\n}\n\n",
        "source_ast": "{\n  if(){\n    switch(){\n      \n      case :\n        call(, , )\n        \n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if()call(, , )\n        return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  if(){\n    switch(){\n      case :\n        return\n      case :\n      case :\n      case :\n        return\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        return\n      case :\n        \n        \n        if(){\n          call(, )\n          return\n        }\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  if(){\n    switch(){\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        return\n      case :\n      case :\n      case :\n        return\n      case :\n        return\n      case :\n        \n        \n        if(){\n          call(, )\n          return\n        }\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.390625,
          "base_ppl": 1.890625,
          "pr_ppl": 1.9296875,
          "source_ast_ppl": 2.03125,
          "base_ast_ppl": 1.96875,
          "pr_ast_ppl": 2.046875,
          "delta_ppl": 0.0390625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses standard C constructs like switch statements and avoids the use of goto, making it more human-readable and idiomatic.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 2.28125,
          "pr_ppl": 2.28125,
          "source_ast_ppl": 2.4375,
          "base_ast_ppl": 2.5625,
          "pr_ast_ppl": 2.5625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate due to its clear and structured control flow, proper use of loops, and idiomatic C syntax, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n            break;\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              call(, , )\n              \n              \n            case :\n              call(, , )\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.0625,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.96875,
          "pr_ast_ppl": 2.96875,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "motivation": "A recovered the for-loop while B used while-goto",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n            break;\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              call(, , )\n              \n              \n            case :\n              call(, , )\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.0625,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.96875,
          "pr_ast_ppl": 2.96875,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate as it uses a cleaner and more standard control flow structure, while maintaining semantic equivalence with the original code.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "### Winner: A\n\n### Motivation: \nCandidate A is closer to the source because it recovered the `ForLoop` shape while Candidate B used `WhileLoop` with `Goto` statements, which is less desirable.\n\n### Reasoning:\n\n1. **Topological Shape**: Both candidates have the same nesting depth and sequence of blocks. However, Candidate A's nesting depth is slightly more complex due to the additional `do-while` loops, but this is offset by the presence of the `ForLoop` shape.\n\n2. **Loop Fidelity**: Candidate A correctly identifies the `ForLoop` shape in the `while` block, while Candidate B uses a `WhileLoop` with `Goto` statements.\n\n3. **Complexity Penalty**: Candidate A adds unnecessary `Goto` statements in the `do-while` loops, but this is balanced by the correct `ForLoop` shape. Candidate B's use of `Goto` statements in the `WhileLoop` is a greater complexity penalty.\n\n### Winner: A"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                \n                \n              case :\n                call(, , )\n                \n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                \n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 2.328125,
          "pr_ppl": 2.296875,
          "source_ast_ppl": 3.59375,
          "base_ast_ppl": 3.78125,
          "pr_ast_ppl": 3.75,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "motivation": "A recovered the for-loop while B used while-goto",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                \n                \n              case :\n                call(, , )\n                \n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                \n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 2.359375,
          "pr_ppl": 2.328125,
          "source_ast_ppl": 3.59375,
          "base_ast_ppl": 3.78125,
          "pr_ast_ppl": 3.75,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is preferred because it uses standard loops and clean logic, making it more human-readable and easier to understand, even though it has minor inaccuracies.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "A recovered the for-loop while B used while-goto",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-libxls_xls_isRecordTooSmall-O2.so",
        "function": "xls_isRecordTooSmall",
        "source_code": "int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1, const BYTE* buf) {\n    switch (bof1->id) {\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            return (bof1->size < 2 * sizeof(WORD));\n        case XLS_RECORD_CODEPAGE:\n            return (bof1->size < sizeof(WORD));\n\t\tcase XLS_RECORD_WINDOW1:\n            return (bof1->size < sizeof(WIND1));\n        case XLS_RECORD_SST:\n            return (bof1->size < offsetof(SST, strings));\n        case XLS_RECORD_BOUNDSHEET:\n            return (bof1->size < offsetof(BOUNDSHEET, name));\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n                return (bof1->size < sizeof(XF5));\n            }\n            return (bof1->size < sizeof(XF8));\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n            return (bof1->size < offsetof(FONT, name));\n        case XLS_RECORD_FORMAT:\n            return (bof1->size < offsetof(FORMAT, value));\n        case XLS_RECORD_STYLE:\n            {\n                struct {\n                    unsigned short idx;\n                    unsigned char ident;\n                    unsigned char lvl;\n                } *styl;\n                if(bof1->size < 2) {\n                    return 1;\n                }\n                styl = (void *)buf;\n                if(xlsShortVal(styl->idx) & 0x8000) {\n                    return bof1->size < 4;\n                } else {\n                    if(bof1->size < 3) return 1;\n                    return bof1->size < 3 + styl->ident;\n                }\n            }\n\t\tcase XLS_RECORD_1904:\n            return (bof1->size < sizeof(BYTE));\n        default:\n            break;\n    }\n    return 0;\n}\n",
        "function_base": "\nbool xls_isRecordTooSmall(long param_1,ushort *param_2,short *param_3)\n\n{\n  ushort uVar1;\n  short sVar2;\n  bool bVar3;\n  \n  uVar1 = *param_2;\n  if (uVar1 < 0xfc) {\n    bVar3 = false;\n    switch(uVar1) {\n    case 0x22:\n      bVar3 = param_2[1] == 0;\n      break;\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x41:\n      break;\n    case 0x31:\n      goto switchD_00101137_caseD_31;\n    case 0x3d:\n      bVar3 = param_2[1] < 0x12;\n      break;\n    case 0x42:\nswitchD_00101137_caseD_42:\n      bVar3 = param_2[1] < 2;\n      break;\n    default:\n      if (uVar1 == 0x85) {\n        bVar3 = param_2[1] < 6;\n      }\n      else {\n        bVar3 = false;\n        if (uVar1 == 0xe0) {\n          if (*(char *)(param_1 + 0xc) == '\\0') {\n            bVar3 = param_2[1] < 0x18;\n          }\n          else {\n            bVar3 = param_2[1] < 0x10;\n          }\n        }\n      }\n    }\n  }\n  else {\n    if (0x292 < uVar1) {\n      if (uVar1 == 0x293) {\n        if (param_2[1] < 2) {\n          return true;\n        }\n        sVar2 = xlsShortVal((int)*param_3);\n        uVar1 = param_2[1];\n        if (sVar2 < 0) {\n          return uVar1 < 4;\n        }\n        if (uVar1 < 3) {\n          return true;\n        }\n        return uVar1 < (ushort)(*(byte *)(param_3 + 1) + 3);\n      }\n      if (uVar1 != 0x41e) {\n        if (uVar1 != 0x809) {\n          return false;\n        }\n        return param_2[1] < 4;\n      }\n      goto switchD_00101137_caseD_42;\n    }\n    if (uVar1 == 0xfc) {\n      return param_2[1] < 8;\n    }\n    if (uVar1 != 0x231) {\n      return false;\n    }\nswitchD_00101137_caseD_31:\n    bVar3 = param_2[1] < 0xe;\n  }\n  return bVar3;\n}\n\n",
        "function_pr": "\nbool xls_isRecordTooSmall(long param_1,ushort *param_2,short *param_3)\n\n{\n  ushort uVar1;\n  short sVar2;\n  bool bVar3;\n  \n  uVar1 = *param_2;\n  if (uVar1 < 0xfc) {\n    bVar3 = false;\n    switch(uVar1) {\n    case 0x22:\n      bVar3 = param_2[1] == 0;\n      break;\n    default:\n      if (uVar1 == 0x85) {\n        bVar3 = param_2[1] < 6;\n      }\n      else {\n        bVar3 = false;\n        if (uVar1 == 0xe0) {\n          if (*(char *)(param_1 + 0xc) == '\\0') {\n            bVar3 = param_2[1] < 0x18;\n          }\n          else {\n            bVar3 = param_2[1] < 0x10;\n          }\n        }\n      }\n      break;\n    case 0x31:\n      goto switchD_00101137_caseD_31;\n    case 0x42:\nswitchD_00101137_caseD_42:\n      bVar3 = param_2[1] < 2;\n      break;\n    case 0x3d:\n      bVar3 = param_2[1] < 0x12;\n      break;\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x41:\n      break;\n    }\n  }\n  else {\n    if (0x292 < uVar1) {\n      if (uVar1 == 0x293) {\n        if (param_2[1] < 2) {\n          return true;\n        }\n        sVar2 = xlsShortVal((int)*param_3);\n        uVar1 = param_2[1];\n        if (sVar2 < 0) {\n          return uVar1 < 4;\n        }\n        if (uVar1 < 3) {\n          return true;\n        }\n        return uVar1 < (ushort)(*(byte *)(param_3 + 1) + 3);\n      }\n      if (uVar1 != 0x41e) {\n        if (uVar1 != 0x809) {\n          return false;\n        }\n        return param_2[1] < 4;\n      }\n      goto switchD_00101137_caseD_42;\n    }\n    if (uVar1 == 0xfc) {\n      return param_2[1] < 8;\n    }\n    if (uVar1 != 0x231) {\n      return false;\n    }\nswitchD_00101137_caseD_31:\n    bVar3 = param_2[1] < 0xe;\n  }\n  return bVar3;\n}\n\n",
        "source_ast": "{\n  switch(){\n    case :\n      \n      return\n    case :\n      return\n    case :\n      return\n    case :\n      return\n    case :\n      return\n    case :\n      if(){\n        return\n      }\n      return\n    case :\n    case :\n      return\n    case :\n      return\n    case :\n      {\n        \n        if(){\n          return\n        }\n        \n        if(call()){\n          return\n        }else{\n          if()return\n          return\n        }\n      }\n    case :\n      return\n    case :\n      \n      \n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  if(){\n    \n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        goto label\n      case :\n        \n        \n      case :\n        \n        \n      case :\n        \n        if(){\n          \n        }else{\n          \n          if(){\n            if(){\n              \n            }else{\n              \n            }\n          }\n        }\n    }\n  }else{\n    if(){\n      if(){\n        if(){\n          return\n        }\n        call()\n        \n        if(){\n          return\n        }\n        if(){\n          return\n        }\n        returncall()\n      }\n      if(){\n        if(){\n          return\n        }\n        return\n      }\n      goto label\n    }\n    if(){\n      return\n    }\n    if(){\n      return\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  if(){\n    \n    switch(){\n      case :\n        \n        \n      case :\n        \n        if(){\n          \n        }else{\n          \n          if(){\n            if(){\n              \n            }else{\n              \n            }\n          }\n        }\n        \n      case :\n        goto label\n      case :\n        \n        \n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n    }\n  }else{\n    if(){\n      if(){\n        if(){\n          return\n        }\n        call()\n        \n        if(){\n          return\n        }\n        if(){\n          return\n        }\n        returncall()\n      }\n      if(){\n        if(){\n          return\n        }\n        return\n      }\n      goto label\n    }\n    if(){\n      return\n    }\n    if(){\n      return\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.515625,
          "base_ppl": 2.09375,
          "pr_ppl": 2.09375,
          "source_ast_ppl": 3.921875,
          "base_ast_ppl": 2.640625,
          "pr_ast_ppl": 2.546875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate, with a clear and structured control flow, whereas Candidate A and the ground truth have spaghetti code with excessive use of `goto` and complex `switch` statements.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "A recovered the for-loop while B used while-goto",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-libxls_xls_isRecordTooSmall-O3.so",
        "function": "xls_isRecordTooSmall",
        "source_code": "int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1, const BYTE* buf) {\n    switch (bof1->id) {\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            return (bof1->size < 2 * sizeof(WORD));\n        case XLS_RECORD_CODEPAGE:\n            return (bof1->size < sizeof(WORD));\n\t\tcase XLS_RECORD_WINDOW1:\n            return (bof1->size < sizeof(WIND1));\n        case XLS_RECORD_SST:\n            return (bof1->size < offsetof(SST, strings));\n        case XLS_RECORD_BOUNDSHEET:\n            return (bof1->size < offsetof(BOUNDSHEET, name));\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n                return (bof1->size < sizeof(XF5));\n            }\n            return (bof1->size < sizeof(XF8));\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n            return (bof1->size < offsetof(FONT, name));\n        case XLS_RECORD_FORMAT:\n            return (bof1->size < offsetof(FORMAT, value));\n        case XLS_RECORD_STYLE:\n            {\n                struct {\n                    unsigned short idx;\n                    unsigned char ident;\n                    unsigned char lvl;\n                } *styl;\n                if(bof1->size < 2) {\n                    return 1;\n                }\n                styl = (void *)buf;\n                if(xlsShortVal(styl->idx) & 0x8000) {\n                    return bof1->size < 4;\n                } else {\n                    if(bof1->size < 3) return 1;\n                    return bof1->size < 3 + styl->ident;\n                }\n            }\n\t\tcase XLS_RECORD_1904:\n            return (bof1->size < sizeof(BYTE));\n        default:\n            break;\n    }\n    return 0;\n}\n",
        "function_base": "\nbool xls_isRecordTooSmall(long param_1,ushort *param_2,short *param_3)\n\n{\n  ushort uVar1;\n  short sVar2;\n  bool bVar3;\n  \n  uVar1 = *param_2;\n  if (uVar1 < 0xfc) {\n    bVar3 = false;\n    switch(uVar1) {\n    case 0x22:\n      bVar3 = param_2[1] == 0;\n      break;\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x41:\n      break;\n    case 0x31:\n      goto switchD_00101137_caseD_31;\n    case 0x3d:\n      bVar3 = param_2[1] < 0x12;\n      break;\n    case 0x42:\nswitchD_00101137_caseD_42:\n      bVar3 = param_2[1] < 2;\n      break;\n    default:\n      if (uVar1 == 0x85) {\n        bVar3 = param_2[1] < 6;\n      }\n      else {\n        bVar3 = false;\n        if (uVar1 == 0xe0) {\n          if (*(char *)(param_1 + 0xc) == '\\0') {\n            bVar3 = param_2[1] < 0x18;\n          }\n          else {\n            bVar3 = param_2[1] < 0x10;\n          }\n        }\n      }\n    }\n  }\n  else {\n    if (0x292 < uVar1) {\n      if (uVar1 == 0x293) {\n        if (param_2[1] < 2) {\n          return true;\n        }\n        sVar2 = xlsShortVal((int)*param_3);\n        uVar1 = param_2[1];\n        if (sVar2 < 0) {\n          return uVar1 < 4;\n        }\n        if (uVar1 < 3) {\n          return true;\n        }\n        return uVar1 < (ushort)(*(byte *)(param_3 + 1) + 3);\n      }\n      if (uVar1 != 0x41e) {\n        if (uVar1 != 0x809) {\n          return false;\n        }\n        return param_2[1] < 4;\n      }\n      goto switchD_00101137_caseD_42;\n    }\n    if (uVar1 == 0xfc) {\n      return param_2[1] < 8;\n    }\n    if (uVar1 != 0x231) {\n      return false;\n    }\nswitchD_00101137_caseD_31:\n    bVar3 = param_2[1] < 0xe;\n  }\n  return bVar3;\n}\n\n",
        "function_pr": "\nbool xls_isRecordTooSmall(long param_1,ushort *param_2,short *param_3)\n\n{\n  ushort uVar1;\n  short sVar2;\n  bool bVar3;\n  \n  uVar1 = *param_2;\n  if (uVar1 < 0xfc) {\n    bVar3 = false;\n    switch(uVar1) {\n    case 0x22:\n      bVar3 = param_2[1] == 0;\n      break;\n    default:\n      if (uVar1 == 0x85) {\n        bVar3 = param_2[1] < 6;\n      }\n      else {\n        bVar3 = false;\n        if (uVar1 == 0xe0) {\n          if (*(char *)(param_1 + 0xc) == '\\0') {\n            bVar3 = param_2[1] < 0x18;\n          }\n          else {\n            bVar3 = param_2[1] < 0x10;\n          }\n        }\n      }\n      break;\n    case 0x31:\n      goto switchD_00101137_caseD_31;\n    case 0x42:\nswitchD_00101137_caseD_42:\n      bVar3 = param_2[1] < 2;\n      break;\n    case 0x3d:\n      bVar3 = param_2[1] < 0x12;\n      break;\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x41:\n      break;\n    }\n  }\n  else {\n    if (0x292 < uVar1) {\n      if (uVar1 == 0x293) {\n        if (param_2[1] < 2) {\n          return true;\n        }\n        sVar2 = xlsShortVal((int)*param_3);\n        uVar1 = param_2[1];\n        if (sVar2 < 0) {\n          return uVar1 < 4;\n        }\n        if (uVar1 < 3) {\n          return true;\n        }\n        return uVar1 < (ushort)(*(byte *)(param_3 + 1) + 3);\n      }\n      if (uVar1 != 0x41e) {\n        if (uVar1 != 0x809) {\n          return false;\n        }\n        return param_2[1] < 4;\n      }\n      goto switchD_00101137_caseD_42;\n    }\n    if (uVar1 == 0xfc) {\n      return param_2[1] < 8;\n    }\n    if (uVar1 != 0x231) {\n      return false;\n    }\nswitchD_00101137_caseD_31:\n    bVar3 = param_2[1] < 0xe;\n  }\n  return bVar3;\n}\n\n",
        "source_ast": "{\n  switch(){\n    case :\n      \n      return\n    case :\n      return\n    case :\n      return\n    case :\n      return\n    case :\n      return\n    case :\n      if(){\n        return\n      }\n      return\n    case :\n    case :\n      return\n    case :\n      return\n    case :\n      {\n        \n        if(){\n          return\n        }\n        \n        if(call()){\n          return\n        }else{\n          if()return\n          return\n        }\n      }\n    case :\n      return\n    case :\n      \n      \n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  if(){\n    \n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        goto label\n      case :\n        \n        \n      case :\n        \n        \n      case :\n        \n        if(){\n          \n        }else{\n          \n          if(){\n            if(){\n              \n            }else{\n              \n            }\n          }\n        }\n    }\n  }else{\n    if(){\n      if(){\n        if(){\n          return\n        }\n        call()\n        \n        if(){\n          return\n        }\n        if(){\n          return\n        }\n        returncall()\n      }\n      if(){\n        if(){\n          return\n        }\n        return\n      }\n      goto label\n    }\n    if(){\n      return\n    }\n    if(){\n      return\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  if(){\n    \n    switch(){\n      case :\n        \n        \n      case :\n        \n        if(){\n          \n        }else{\n          \n          if(){\n            if(){\n              \n            }else{\n              \n            }\n          }\n        }\n        \n      case :\n        goto label\n      case :\n        \n        \n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n    }\n  }else{\n    if(){\n      if(){\n        if(){\n          return\n        }\n        call()\n        \n        if(){\n          return\n        }\n        if(){\n          return\n        }\n        returncall()\n      }\n      if(){\n        if(){\n          return\n        }\n        return\n      }\n      goto label\n    }\n    if(){\n      return\n    }\n    if(){\n      return\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.515625,
          "base_ppl": 2.09375,
          "pr_ppl": 2.09375,
          "source_ast_ppl": 3.921875,
          "base_ast_ppl": 2.640625,
          "pr_ast_ppl": 2.546875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more human-readable due to its consistent switch-case structure, despite minor inaccuracies, making it easier to understand and maintain.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate A recovered the correct ForLoop structure, while Candidate B used unnecessary nesting and Goto statements.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.03125,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.84375,
          "pr_ast_ppl": 2.84375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B's use of a more traditional control flow and explicit looping structure makes it more human-readable and easier to understand, even though it has minor inaccuracies in variable type recovery.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 2.046875,
          "pr_ppl": 2.046875,
          "source_ast_ppl": 3.59375,
          "base_ast_ppl": 3.40625,
          "pr_ast_ppl": 3.40625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and idiomatic, with a clear use of standard control structures and functions, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 2.734375,
          "pr_ppl": 2.890625,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 3.796875,
          "pr_ast_ppl": 3.796875,
          "delta_ppl": 0.15625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its use of standard loops and cleaner logic, even if it has minor inaccuracies.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 2.734375,
          "pr_ppl": 2.890625,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 3.796875,
          "pr_ast_ppl": 3.796875,
          "delta_ppl": 0.15625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate because it uses a clear and standard while loop structure, whereas Candidate A uses a do-while loop with a goto statement, which is less conventional and harder to understand.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            \n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.8671875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.78125,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 4.28125,
          "pr_ast_ppl": 4.34375,
          "delta_ppl": 0.140625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its clear and structured control flow, using standard loops and conditional statements, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "A recovered the while-loop and had the correct nesting depth, while B used goto and added unnecessary complexity.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            \n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.8671875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.78125,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 4.28125,
          "pr_ast_ppl": 4.34375,
          "delta_ppl": 0.140625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is the winner because it uses standard loops and a clear, structured approach to parse the date string, making it more human-readable and easier to understand, even though it has minor inaccuracies.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_zsav_read_compressed_data-O0.so",
        "function": "zsav_read_compressed_data",
        "source_code": "readstat_error_t zsav_read_compressed_data(sav_ctx_t *ctx,\n        readstat_error_t (*row_handler)(unsigned char *, size_t, sav_ctx_t *)) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = ctx->io;\n    readstat_off_t data_offset = 0;\n\n    size_t uncompressed_row_len = ctx->var_offset * 8;\n    readstat_off_t uncompressed_offset = 0;\n    unsigned char *uncompressed_row = NULL;\n\n    uLongf uncompressed_block_len = 0;\n    unsigned char *compressed_block = NULL, *uncompressed_block = NULL;\n\n    struct sav_row_stream_s state = { \n        .missing_value = ctx->missing_double,\n        .bias = ctx->bias,\n        .bswap = ctx->bswap };\n\n    struct zheader zheader;\n    struct ztrailer ztrailer;\n    struct ztrailer_entry *ztrailer_entries = NULL;\n\n    int n_blocks = 0;\n    int block_i = 0;\n    int i;\n\n    if (io->read(&zheader, sizeof(struct zheader), io->io_ctx) < sizeof(struct zheader)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    zheader.zheader_ofs = ctx->bswap ? byteswap8(zheader.zheader_ofs) : zheader.zheader_ofs;\n    zheader.ztrailer_ofs = ctx->bswap ? byteswap8(zheader.ztrailer_ofs) : zheader.ztrailer_ofs;\n    zheader.ztrailer_len = ctx->bswap ? byteswap8(zheader.ztrailer_len) : zheader.ztrailer_len;\n\n    if (zheader.zheader_ofs != io->seek(0, READSTAT_SEEK_CUR, io->io_ctx) - sizeof(struct zheader)) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    n_blocks = (zheader.ztrailer_len - 24) / 24;\n\n    if (io->seek(zheader.ztrailer_ofs, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->read(&ztrailer, sizeof(struct ztrailer), io->io_ctx) < sizeof(struct ztrailer)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ztrailer.bias = ctx->bswap ? byteswap8(ztrailer.bias) : ztrailer.bias;\n    ztrailer.zero = ctx->bswap ? byteswap8(ztrailer.zero) : ztrailer.zero;\n    ztrailer.block_size = ctx->bswap ? byteswap4(ztrailer.block_size) : ztrailer.block_size;\n    ztrailer.n_blocks = ctx->bswap ? byteswap4(ztrailer.n_blocks) : ztrailer.n_blocks;\n\n    if (n_blocks != ztrailer.n_blocks) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    if (n_blocks && (ztrailer_entries = readstat_malloc(n_blocks * sizeof(struct ztrailer_entry))) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (io->read(ztrailer_entries, n_blocks * sizeof(struct ztrailer_entry), io->io_ctx) < \n            n_blocks * sizeof(struct ztrailer_entry)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    for (i=0; i<n_blocks; i++) {\n        struct ztrailer_entry *entry = &ztrailer_entries[i];\n\n        entry->uncompressed_ofs = ctx->bswap ? byteswap8(entry->uncompressed_ofs) : entry->uncompressed_ofs;\n        entry->compressed_ofs = ctx->bswap ? byteswap8(entry->compressed_ofs) : entry->compressed_ofs;\n        entry->uncompressed_size = ctx->bswap ? byteswap4(entry->uncompressed_size) : entry->uncompressed_size;\n        entry->compressed_size = ctx->bswap ? byteswap4(entry->compressed_size) : entry->compressed_size;\n    }\n\n    if (uncompressed_row_len && (uncompressed_row = readstat_malloc(uncompressed_row_len)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    while (1) {\n        if (block_i == n_blocks)\n            goto cleanup;\n\n        struct ztrailer_entry *entry = &ztrailer_entries[block_i];\n        if (io->seek(entry->compressed_ofs, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n            retval = READSTAT_ERROR_SEEK;\n            goto cleanup;\n        }\n        if ((compressed_block = readstat_realloc(compressed_block, entry->compressed_size)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if (io->read(compressed_block, entry->compressed_size, io->io_ctx) != entry->compressed_size) {\n            retval = READSTAT_ERROR_READ;\n            goto cleanup;\n        }\n\n        uncompressed_block_len = entry->uncompressed_size;\n        if ((uncompressed_block = readstat_realloc(uncompressed_block, uncompressed_block_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        int status = uncompress(uncompressed_block, &uncompressed_block_len,\n                compressed_block, entry->compressed_size);\n        if (status != Z_OK || uncompressed_block_len != entry->uncompressed_size) {\n            retval = READSTAT_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        block_i++;\n        state.status = SAV_ROW_STREAM_HAVE_DATA;\n        data_offset = 0;\n\n        while (state.status != SAV_ROW_STREAM_NEED_DATA) {\n            state.next_in = &uncompressed_block[data_offset];\n            state.avail_in = uncompressed_block_len - data_offset;\n\n            state.next_out = &uncompressed_row[uncompressed_offset];\n            state.avail_out = uncompressed_row_len - uncompressed_offset;\n\n            sav_decompress_row(&state);\n\n            uncompressed_offset = uncompressed_row_len - state.avail_out;\n            data_offset = uncompressed_block_len - state.avail_in;\n\n            if (state.status == SAV_ROW_STREAM_FINISHED_ROW) {\n                retval = row_handler(uncompressed_row, uncompressed_row_len, ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                uncompressed_offset = 0;\n            }\n\n            if (state.status == SAV_ROW_STREAM_FINISHED_ALL)\n                goto cleanup;\n            if (ctx->row_limit > 0 && ctx->current_row == ctx->row_limit)\n                goto cleanup;\n        }\n    }\n\ncleanup:\n    if (uncompressed_row)\n        free(uncompressed_row);\n    if (ztrailer_entries)\n        free(ztrailer_entries);\n    if (compressed_block)\n        free(compressed_block);\n    if (uncompressed_block)\n        free(uncompressed_block);\n\n    return retval;\n}\n",
        "function_base": "\nint zsav_read_compressed_data(long param_1,code *param_2)\n\n{\n  undefined1 auVar1 [16];\n  int iVar2;\n  int iVar3;\n  ulong uVar4;\n  long lVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined4 local_158;\n  undefined4 local_154;\n  undefined8 local_150;\n  undefined8 local_148;\n  int local_140;\n  undefined4 local_13c;\n  undefined8 local_138;\n  undefined8 local_130;\n  long local_120;\n  undefined8 local_118;\n  long local_110;\n  int local_ec;\n  int local_e8;\n  void *local_e0;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined4 local_c8;\n  int local_c4;\n  long local_c0;\n  undefined8 local_b8;\n  long local_b0;\n  long local_a8;\n  long local_a0;\n  long local_98;\n  long local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined1 auStack_78 [8];\n  undefined4 local_70;\n  uint local_6c;\n  int local_68;\n  void *local_60;\n  void *local_58;\n  long local_50;\n  void *local_48;\n  long local_40;\n  long local_38;\n  long local_30;\n  long local_28;\n  int local_1c;\n  code *local_18;\n  long local_10;\n  \n  local_1c = 0;\n  local_28 = *(long *)(param_1 + 0x48);\n  local_30 = 0;\n  local_38 = (long)(*(int *)(param_1 + 0x1ac) << 3);\n  local_40 = 0;\n  local_48 = (void *)0x0;\n  local_50 = 0;\n  local_58 = (void *)0x0;\n  local_60 = (void *)0x0;\n  local_a8 = 0;\n  local_a0 = 0;\n  local_98 = 0;\n  local_90 = 0;\n  local_88 = *(undefined8 *)(param_1 + 0x1f0);\n  local_80 = *(undefined8 *)(param_1 + 0x218);\n  local_18 = param_2;\n  local_10 = param_1;\n  memset(auStack_78,0,8);\n  local_70 = 0;\n  local_6c = (uint)(*(byte *)(local_10 + 0x22c) & 1);\n  local_68 = 0;\n  local_e0 = (void *)0x0;\n  local_e8 = 0;\n  uVar4 = (**(code **)(local_28 + 0x18))(&local_c0,0x18,*(undefined8 *)(local_28 + 0x28));\n  if (uVar4 < 0x18) {\n    local_1c = 2;\n  }\n  else {\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_110 = local_c0;\n    }\n    else {\n      local_110 = byteswap8(local_c0);\n    }\n    local_c0 = local_110;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_118 = local_b8;\n    }\n    else {\n      local_118 = byteswap8(local_b8);\n    }\n    local_b8 = local_118;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_120 = local_b0;\n    }\n    else {\n      local_120 = byteswap8(local_b0);\n    }\n    lVar6 = local_c0;\n    local_b0 = local_120;\n    lVar5 = (**(code **)(local_28 + 0x10))(0,1,*(undefined8 *)(local_28 + 0x28));\n    if (lVar6 == lVar5 + -0x18) {\n      auVar1._8_8_ = 0;\n      auVar1._0_8_ = local_b0 - 0x18;\n      iVar2 = SUB164(auVar1 / ZEXT816(0x18),0);\n      lVar6 = (**(code **)(local_28 + 0x10))(local_b8,0,*(undefined8 *)(local_28 + 0x28));\n      if (lVar6 == -1) {\n        local_1c = 0xf;\n      }\n      else {\n        uVar4 = (**(code **)(local_28 + 0x18))(&local_d8,0x18,*(undefined8 *)(local_28 + 0x28));\n        if (uVar4 < 0x18) {\n          local_1c = 2;\n        }\n        else {\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_130 = local_d8;\n          }\n          else {\n            local_130 = byteswap8(local_d8);\n          }\n          local_d8 = local_130;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_138 = local_d0;\n          }\n          else {\n            local_138 = byteswap8(local_d0);\n          }\n          local_d0 = local_138;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_13c = local_c8;\n          }\n          else {\n            local_13c = byteswap4(local_c8);\n          }\n          local_c8 = local_13c;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_140 = local_c4;\n          }\n          else {\n            local_140 = byteswap4(local_c4);\n          }\n          local_c4 = local_140;\n          if (iVar2 == local_140) {\n            if ((iVar2 == 0) ||\n               (local_e0 = (void *)readstat_malloc((long)iVar2 * 0x18), local_e0 != (void *)0x0)) {\n              uVar4 = (**(code **)(local_28 + 0x18))\n                                (local_e0,(long)iVar2 * 0x18,*(undefined8 *)(local_28 + 0x28));\n              if (uVar4 < (ulong)((long)iVar2 * 0x18)) {\n                local_1c = 2;\n              }\n              else {\n                for (local_ec = 0; local_ec < iVar2; local_ec = local_ec + 1) {\n                  puVar7 = (undefined8 *)((long)local_e0 + (long)local_ec * 0x18);\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_148 = *puVar7;\n                  }\n                  else {\n                    local_148 = byteswap8(*puVar7);\n                  }\n                  *puVar7 = local_148;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_150 = puVar7[1];\n                  }\n                  else {\n                    local_150 = byteswap8(puVar7[1]);\n                  }\n                  puVar7[1] = local_150;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_154 = *(undefined4 *)(puVar7 + 2);\n                  }\n                  else {\n                    local_154 = byteswap4(*(undefined4 *)(puVar7 + 2));\n                  }\n                  *(undefined4 *)(puVar7 + 2) = local_154;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_158 = *(undefined4 *)((long)puVar7 + 0x14);\n                  }\n                  else {\n                    local_158 = byteswap4(*(undefined4 *)((long)puVar7 + 0x14));\n                  }\n                  *(undefined4 *)((long)puVar7 + 0x14) = local_158;\n                }\n                if ((local_38 == 0) ||\n                   (local_48 = (void *)readstat_malloc(local_38), local_48 != (void *)0x0)) {\n                  while (local_e8 != iVar2) {\n                    lVar6 = (**(code **)(local_28 + 0x10))\n                                      (*(undefined8 *)((long)local_e0 + (long)local_e8 * 0x18 + 8),0\n                                       ,*(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 == -1) {\n                      local_1c = 0xf;\n                      break;\n                    }\n                    local_58 = (void *)readstat_realloc(local_58,(long)*(int *)((long)local_e0 +\n                                                                               (long)local_e8 * 0x18\n                                                                               + 0x14));\n                    if (local_58 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    lVar6 = (**(code **)(local_28 + 0x18))\n                                      (local_58,(long)*(int *)((long)local_e0 +\n                                                              (long)local_e8 * 0x18 + 0x14),\n                                       *(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)) {\n                      local_1c = 2;\n                      break;\n                    }\n                    local_50 = (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10);\n                    local_60 = (void *)readstat_realloc(local_60,local_50);\n                    if (local_60 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    iVar3 = uncompress(local_60,&local_50,local_58,\n                                       (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)\n                                      );\n                    if ((iVar3 != 0) ||\n                       (local_50 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10))) {\n                      local_1c = 5;\n                      break;\n                    }\n                    local_e8 = local_e8 + 1;\n                    local_68 = 1;\n                    local_30 = 0;\n                    while (local_68 != 0) {\n                      local_a8 = (long)local_60 + local_30;\n                      local_a0 = local_50 - local_30;\n                      local_98 = (long)local_48 + local_40;\n                      local_90 = local_38 - local_40;\n                      sav_decompress_row(&local_a8);\n                      local_40 = local_38 - local_90;\n                      local_30 = local_50 - local_a0;\n                      if (local_68 == 2) {\n                        local_1c = (*local_18)(local_48,local_38,local_10);\n                        if (local_1c != 0) goto LAB_00101a68;\n                        local_40 = 0;\n                      }\n                      if ((local_68 == 3) ||\n                         ((0 < *(int *)(local_10 + 0x1b8) &&\n                          (*(int *)(local_10 + 0x1c0) == *(int *)(local_10 + 0x1b8)))))\n                      goto LAB_00101a68;\n                    }\n                  }\n                }\n                else {\n                  local_1c = 3;\n                }\n              }\n            }\n            else {\n              local_1c = 3;\n            }\n          }\n          else {\n            local_1c = 5;\n          }\n        }\n      }\n    }\n    else {\n      local_1c = 5;\n    }\n  }\nLAB_00101a68:\n  if (local_48 != (void *)0x0) {\n    free(local_48);\n  }\n  if (local_e0 != (void *)0x0) {\n    free(local_e0);\n  }\n  if (local_58 != (void *)0x0) {\n    free(local_58);\n  }\n  if (local_60 != (void *)0x0) {\n    free(local_60);\n  }\n  return local_1c;\n}\n\n",
        "function_pr": "\nint zsav_read_compressed_data(long param_1,code *param_2)\n\n{\n  undefined auVar1 [16];\n  int iVar2;\n  int iVar3;\n  ulong uVar4;\n  long lVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined4 local_158;\n  undefined4 local_154;\n  undefined8 local_150;\n  undefined8 local_148;\n  int local_140;\n  undefined4 local_13c;\n  undefined8 local_138;\n  undefined8 local_130;\n  long local_120;\n  undefined8 local_118;\n  long local_110;\n  int local_ec;\n  int local_e8;\n  void *local_e0;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined4 local_c8;\n  int local_c4;\n  long local_c0;\n  undefined8 local_b8;\n  long local_b0;\n  long local_a8;\n  long local_a0;\n  long local_98;\n  long local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined auStack_78 [8];\n  undefined4 local_70;\n  uint local_6c;\n  int local_68;\n  void *local_60;\n  void *local_58;\n  long local_50;\n  void *local_48;\n  long local_40;\n  long local_38;\n  long local_30;\n  long local_28;\n  int local_1c;\n  code *local_18;\n  long local_10;\n  \n  local_1c = 0;\n  local_28 = *(long *)(param_1 + 0x48);\n  local_30 = 0;\n  local_38 = (long)(*(int *)(param_1 + 0x1ac) << 3);\n  local_40 = 0;\n  local_48 = (void *)0x0;\n  local_50 = 0;\n  local_58 = (void *)0x0;\n  local_60 = (void *)0x0;\n  local_a8 = 0;\n  local_a0 = 0;\n  local_98 = 0;\n  local_90 = 0;\n  local_88 = *(undefined8 *)(param_1 + 0x1f0);\n  local_80 = *(undefined8 *)(param_1 + 0x218);\n  local_18 = param_2;\n  local_10 = param_1;\n  memset(auStack_78,0,8);\n  local_70 = 0;\n  local_6c = (uint)(*(byte *)(local_10 + 0x22c) & 1);\n  local_68 = 0;\n  local_e0 = (void *)0x0;\n  local_e8 = 0;\n  uVar4 = (**(code **)(local_28 + 0x18))(&local_c0,0x18,*(undefined8 *)(local_28 + 0x28));\n  if (uVar4 < 0x18) {\n    local_1c = 2;\n  }\n  else {\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_110 = local_c0;\n    }\n    else {\n      local_110 = byteswap8(local_c0);\n    }\n    local_c0 = local_110;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_118 = local_b8;\n    }\n    else {\n      local_118 = byteswap8(local_b8);\n    }\n    local_b8 = local_118;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_120 = local_b0;\n    }\n    else {\n      local_120 = byteswap8(local_b0);\n    }\n    lVar6 = local_c0;\n    local_b0 = local_120;\n    lVar5 = (**(code **)(local_28 + 0x10))(0,1,*(undefined8 *)(local_28 + 0x28));\n    if (lVar6 == lVar5 + -0x18) {\n      auVar1._8_8_ = 0;\n      auVar1._0_8_ = local_b0 - 0x18;\n      iVar2 = SUB164(auVar1 / ZEXT816(0x18),0);\n      lVar6 = (**(code **)(local_28 + 0x10))(local_b8,0,*(undefined8 *)(local_28 + 0x28));\n      if (lVar6 == -1) {\n        local_1c = 0xf;\n      }\n      else {\n        uVar4 = (**(code **)(local_28 + 0x18))(&local_d8,0x18,*(undefined8 *)(local_28 + 0x28));\n        if (uVar4 < 0x18) {\n          local_1c = 2;\n        }\n        else {\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_130 = local_d8;\n          }\n          else {\n            local_130 = byteswap8(local_d8);\n          }\n          local_d8 = local_130;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_138 = local_d0;\n          }\n          else {\n            local_138 = byteswap8(local_d0);\n          }\n          local_d0 = local_138;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_13c = local_c8;\n          }\n          else {\n            local_13c = byteswap4(local_c8);\n          }\n          local_c8 = local_13c;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_140 = local_c4;\n          }\n          else {\n            local_140 = byteswap4(local_c4);\n          }\n          local_c4 = local_140;\n          if (iVar2 == local_140) {\n            if ((iVar2 == 0) ||\n               (local_e0 = (void *)readstat_malloc((long)iVar2 * 0x18), local_e0 != (void *)0x0)) {\n              uVar4 = (**(code **)(local_28 + 0x18))\n                                (local_e0,(long)iVar2 * 0x18,*(undefined8 *)(local_28 + 0x28));\n              if (uVar4 < (ulong)((long)iVar2 * 0x18)) {\n                local_1c = 2;\n              }\n              else {\n                for (local_ec = 0; local_ec < iVar2; local_ec = local_ec + 1) {\n                  puVar7 = (undefined8 *)((long)local_e0 + (long)local_ec * 0x18);\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_148 = *puVar7;\n                  }\n                  else {\n                    local_148 = byteswap8(*puVar7);\n                  }\n                  *puVar7 = local_148;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_150 = puVar7[1];\n                  }\n                  else {\n                    local_150 = byteswap8(puVar7[1]);\n                  }\n                  puVar7[1] = local_150;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_154 = *(undefined4 *)(puVar7 + 2);\n                  }\n                  else {\n                    local_154 = byteswap4(*(undefined4 *)(puVar7 + 2));\n                  }\n                  *(undefined4 *)(puVar7 + 2) = local_154;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_158 = *(undefined4 *)((long)puVar7 + 0x14);\n                  }\n                  else {\n                    local_158 = byteswap4(*(undefined4 *)((long)puVar7 + 0x14));\n                  }\n                  *(undefined4 *)((long)puVar7 + 0x14) = local_158;\n                }\n                if ((local_38 == 0) ||\n                   (local_48 = (void *)readstat_malloc(local_38), local_48 != (void *)0x0)) {\n                  while (local_e8 != iVar2) {\n                    lVar6 = (**(code **)(local_28 + 0x10))\n                                      (*(undefined8 *)((long)local_e0 + (long)local_e8 * 0x18 + 8),0\n                                       ,*(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 == -1) {\n                      local_1c = 0xf;\n                      break;\n                    }\n                    local_58 = (void *)readstat_realloc(local_58,(long)*(int *)((long)local_e0 +\n                                                                               (long)local_e8 * 0x18\n                                                                               + 0x14));\n                    if (local_58 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    lVar6 = (**(code **)(local_28 + 0x18))\n                                      (local_58,(long)*(int *)((long)local_e0 +\n                                                              (long)local_e8 * 0x18 + 0x14),\n                                       *(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)) {\n                      local_1c = 2;\n                      break;\n                    }\n                    local_50 = (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10);\n                    local_60 = (void *)readstat_realloc(local_60,local_50);\n                    if (local_60 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    iVar3 = uncompress(local_60,&local_50,local_58,\n                                       (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)\n                                      );\n                    if ((iVar3 != 0) ||\n                       (local_50 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10))) {\n                      local_1c = 5;\n                      break;\n                    }\n                    local_e8 = local_e8 + 1;\n                    local_68 = 1;\n                    local_30 = 0;\n                    while (local_68 != 0) {\n                      local_a8 = (long)local_60 + local_30;\n                      local_a0 = local_50 - local_30;\n                      local_98 = (long)local_48 + local_40;\n                      local_90 = local_38 - local_40;\n                      sav_decompress_row(&local_a8);\n                      local_40 = local_38 - local_90;\n                      local_30 = local_50 - local_a0;\n                      if (local_68 == 2) {\n                        local_1c = (*local_18)(local_48,local_38,local_10);\n                        if (local_1c != 0) goto LAB_00101a68;\n                        local_40 = 0;\n                      }\n                      if ((local_68 == 3) ||\n                         ((0 < *(int *)(local_10 + 0x1b8) &&\n                          (*(int *)(local_10 + 0x1c0) == *(int *)(local_10 + 0x1b8)))))\n                      goto LAB_00101a68;\n                    }\n                  }\n                }\n                else {\n                  local_1c = 3;\n                }\n              }\n            }\n            else {\n              local_1c = 3;\n            }\n          }\n          else {\n            local_1c = 5;\n          }\n        }\n      }\n    }\n    else {\n      local_1c = 5;\n    }\n  }\nLAB_00101a68:\n  if (local_48 != (void *)0x0) {\n    free(local_48);\n  }\n  if (local_e0 != (void *)0x0) {\n    free(local_e0);\n  }\n  if (local_58 != (void *)0x0) {\n    free(local_58);\n  }\n  if (local_60 != (void *)0x0) {\n    free(local_60);\n  }\n  return local_1c;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  if(){\n    \n    goto label\n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  for(;;){\n    \n    (? call(): )\n    (? call(): )\n    (? call(): )\n    (? call(): )\n  }\n  if(call()){\n    \n    goto label\n  }\n  while(){\n    if()goto label\n    \n    if(call(, , )){\n      \n      goto label\n    }\n    if(call(, )){\n      \n      goto label\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    \n    if(call(, )){\n      \n      goto label\n    }\n    call(, , , )\n    if(){\n      \n      goto label\n    }\n    \n    \n    \n    while(){\n      \n      \n      \n      \n      call()\n      \n      \n      if(){\n        call(, , )\n        if()goto label\n        \n      }\n      if()goto label\n      if()goto label\n    }\n  }\n  if()call()\n  if()call()\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, , )\n  \n  call()\n  \n  \n  \n  call(, , )\n  if(){\n    \n  }else{\n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    \n    call(, , )\n    if(){\n      \n      \n      call(call(), )\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          \n        }else{\n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            if(call()){\n              call(, , )\n              if(call()){\n                \n              }else{\n                for(;;){\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                }\n                if(call()){\n                  while(){\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    \n                    \n                    while(){\n                      \n                      \n                      \n                      \n                      call()\n                      \n                      \n                      if(){\n                        call(, , )\n                        if()goto label\n                        \n                      }\n                      if()goto label\n                    }\n                  }\n                }else{\n                  \n                }\n              }\n            }else{\n              \n            }\n          }else{\n            \n          }\n        }\n      }\n    }else{\n      \n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, , )\n  \n  call()\n  \n  \n  \n  call(, , )\n  if(){\n    \n  }else{\n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    \n    call(, , )\n    if(){\n      \n      \n      call(call(), )\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          \n        }else{\n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            if(call()){\n              call(, , )\n              if(call()){\n                \n              }else{\n                for(;;){\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                }\n                if(call()){\n                  while(){\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    \n                    \n                    while(){\n                      \n                      \n                      \n                      \n                      call()\n                      \n                      \n                      if(){\n                        call(, , )\n                        if()goto label\n                        \n                      }\n                      if()goto label\n                    }\n                  }\n                }else{\n                  \n                }\n              }\n            }else{\n              \n            }\n          }else{\n            \n          }\n        }\n      }\n    }else{\n      \n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.9609375,
          "base_ppl": 1.7265625,
          "pr_ppl": 1.71875,
          "source_ast_ppl": 2.84375,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.46875,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate due to its clear and structured control flow, proper use of standard loops, and concise variable names, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      \n      do{\n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n        }\n        if()goto label\n        \n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.859375,
          "base_ppl": 2.09375,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 13.8125,
          "base_ast_ppl": 3.890625,
          "pr_ast_ppl": 3.859375,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      \n      do{\n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n        }\n        if()goto label\n        \n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.859375,
          "base_ppl": 2.09375,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 13.8125,
          "base_ast_ppl": 3.890625,
          "pr_ast_ppl": 3.859375,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate as it uses standard loop structures and clear logic, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "### Comparison of Control Flow Skeletons\n\n### Winner: Candidate A\n\n### Motivation: \nCandidate A correctly identifies the `ForLoop` while Candidate B uses `WhileLoop` with a `goto`."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            if(){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            if(){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8671875,
          "base_ppl": 2.25,
          "pr_ppl": 2.25,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 3.78125,
          "pr_ast_ppl": 3.78125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B has a more linear and structured approach to the logic, avoiding the use of `goto` statements and making the control flow easier to follow, making it a more human-readable and preferred choice.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 2.359375,
          "pr_ppl": 2.34375,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 3.625,
          "pr_ast_ppl": 3.625,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its use of standard control structures and clear variable names, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_por-O0.so",
        "function": "readstat_parse_por",
        "source_code": "readstat_error_t readstat_parse_por(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    unsigned char reverse_lookup[256];\n    char vanity[5][40];\n    char error_buf[1024];\n\n    por_ctx_t *ctx = por_ctx_init();\n    \n    ctx->handle = parser->handlers;\n    ctx->user_ctx = user_ctx;\n    ctx->io = io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (parser->output_encoding) {\n        if (strcmp(parser->output_encoding, \"UTF-8\") != 0)\n            ctx->converter = iconv_open(parser->output_encoding, \"UTF-8\");\n\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n    \n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n    \n    if (read_bytes(ctx, vanity, sizeof(vanity)) != sizeof(vanity)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    retval = readstat_convert(ctx->file_label, sizeof(ctx->file_label), vanity[1] + 20, 20, NULL);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if (read_bytes(ctx, reverse_lookup, sizeof(reverse_lookup)) != sizeof(reverse_lookup)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n    \n    ctx->space = reverse_lookup[126];\n\n    int i;\n\n    for (i=0; i<256; i++) {\n        if (por_ascii_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_ascii_lookup[i];\n        } else if (por_unicode_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_unicode_lookup[i];\n        }\n    }\n\n    ctx->byte2unicode[reverse_lookup[64]] = por_unicode_lookup[64];\n\n    unsigned char check[8];\n    char tr_check[8];\n    \n    if (read_bytes(ctx, check, sizeof(check)) != sizeof(check)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ssize_t encoded_len;\n\n    if ((encoded_len = por_utf8_encode(check, sizeof(check), tr_check, sizeof(tr_check), ctx->byte2unicode)) == -1) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error converting check string: %.*s\", (int)sizeof(check), check);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_CONVERT;\n        goto cleanup;\n    }\n\n    if (strncmp(\"SPSSPORT\", tr_check, encoded_len) != 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n    \n    ctx->var_offset = -1;\n    \n    char string[256];\n\n    retval = read_version_and_timestamp(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n\n    while (1) {\n        uint16_t tr_tag = read_tag(ctx);\n        switch (tr_tag) {\n            case '1': /* product ID */\n            case '2': /* author ID */\n            case '3': /* sub-product ID */\n                retval = read_string(ctx, string, sizeof(string));\n                break;\n            case '4': /* variable count */\n                retval = read_variable_count_record(ctx);\n                break;\n            case '5': /* precision */\n                retval = read_precision_record(ctx);\n                break;\n            case '6': /* case weight */\n                retval = read_case_weight_record(ctx);\n                break;\n            case '7': /* variable */\n                retval = read_variable_record(ctx);\n                break;\n            case '8': /* missing value */\n                retval = read_missing_value_record(ctx);\n                break;\n            case 'B': /* missing value range */\n                retval = read_missing_value_range_record(ctx);\n                break;\n            case '9': /* LO THRU x */\n                retval = read_missing_value_lo_range_record(ctx);\n                break;\n            case 'A': /* x THRU HI */\n                retval = read_missing_value_hi_range_record(ctx);\n                break;\n            case 'C': /* variable label */\n                retval = read_variable_label_record(ctx);\n                break;\n            case 'D': /* value label */\n                retval = read_value_label_record(ctx);\n                break;\n            case 'E': /* document record */\n                retval = read_document_record(ctx);\n                break;\n            case 'F': /* file data */\n                if (ctx->var_offset != ctx->var_count - 1) {\n                    retval = READSTAT_ERROR_COLUMN_COUNT_MISMATCH;\n                    goto cleanup;\n                }\n\n                retval = handle_variables(ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                if (ctx->handle.value) {\n                    retval = read_por_file_data(ctx);\n                }\n                goto cleanup;\n            default:\n                retval = READSTAT_ERROR_PARSE;\n                goto cleanup;\n        }\n        if (retval != READSTAT_OK)\n            break;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n    por_ctx_free(ctx);\n    \n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_por(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  iconv_t pvVar3;\n  long lVar4;\n  undefined1 local_738 [264];\n  size_t local_630;\n  char local_624 [8];\n  undefined1 local_61c [8];\n  int local_614;\n  void *local_610;\n  char local_608 [1024];\n  undefined1 local_208 [60];\n  undefined1 auStack_1cc [148];\n  byte local_138 [264];\n  undefined8 *local_30;\n  int local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_24 = 0;\n  local_30 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_610 = (void *)por_ctx_init();\n  memcpy(local_610,local_10,0x40);\n  *(undefined8 *)((long)local_610 + 0x48) = local_20;\n  *(undefined8 **)((long)local_610 + 0x58) = local_30;\n  *(int *)((long)local_610 + 0x2d0) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)local_610 + 0x2d4) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  if (*(long *)((long)local_10 + 0x50) != 0) {\n    iVar2 = strcmp(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n    if (iVar2 != 0) {\n      pvVar3 = iconv_open(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n      *(iconv_t *)((long)local_610 + 0x2a8) = pvVar3;\n    }\n    if (*(long *)((long)local_610 + 0x2a8) == -1) {\n      *(undefined8 *)((long)local_610 + 0x2a8) = 0;\n      local_24 = 7;\n      goto LAB_00101f5b;\n    }\n  }\n  iVar2 = (*(code *)*local_30)(local_18,local_30[5]);\n  if (iVar2 == -1) {\n    local_24 = 1;\n  }\n  else {\n    lVar4 = (*(code *)local_30[2])(0,2,local_30[5]);\n    *(long *)((long)local_610 + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_24 = 0xf;\n    }\n    else {\n      lVar4 = (*(code *)local_30[2])(0,0,local_30[5]);\n      if (lVar4 == -1) {\n        local_24 = 0xf;\n      }\n      else {\n        lVar4 = read_bytes(local_610,local_208,200);\n        if (lVar4 == 200) {\n          local_24 = readstat_convert((long)local_610 + 0x89,0x15,auStack_1cc,0x14,0);\n          if (local_24 == 0) {\n            lVar4 = read_bytes(local_610,local_138,0x100);\n            if (lVar4 == 0x100) {\n              *(byte *)((long)local_610 + 0x60) = local_138[0x7e];\n              for (local_614 = 0; local_614 < 0x100; local_614 = local_614 + 1) {\n                if (PTR_por_ascii_lookup_00105fe8[local_614] == '\\0') {\n                  if (*(short *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2) != 0) {\n                    *(undefined2 *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                         *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2);\n                  }\n                }\n                else {\n                  *(short *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                       (short)(char)PTR_por_ascii_lookup_00105fe8[local_614];\n                }\n              }\n              *(undefined2 *)((long)local_610 + (ulong)local_138[0x40] * 2 + 0x9e) =\n                   *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + 0x80);\n              lVar4 = read_bytes(local_610,local_61c,8);\n              if (lVar4 == 8) {\n                local_630 = por_utf8_encode(local_61c,8,local_624,8,(long)local_610 + 0x9e);\n                if (local_630 == 0xffffffffffffffff) {\n                  if (*(long *)((long)local_610 + 0x30) != 0) {\n                    snprintf(local_608,0x400,\"Error converting check string: %.*s\",8,local_61c);\n                    (**(code **)((long)local_610 + 0x30))\n                              (local_608,*(undefined8 *)((long)local_610 + 0x48));\n                  }\n                  local_24 = 0x10;\n                }\n                else {\n                  iVar2 = strncmp(\"SPSSPORT\",local_624,local_630);\n                  if (iVar2 == 0) {\n                    *(undefined4 *)((long)local_610 + 0x2cc) = 0xffffffff;\n                    local_24 = read_version_and_timestamp(local_610);\n                    if (local_24 == 0) {\n                      local_24 = 0;\n                      do {\n                        uVar1 = read_tag(local_610);\n                        switch(uVar1) {\n                        case 0x31:\n                        case 0x32:\n                        case 0x33:\n                          local_24 = read_string(local_610,local_738,0x100);\n                          break;\n                        case 0x34:\n                          local_24 = read_variable_count_record(local_610);\n                          break;\n                        case 0x35:\n                          local_24 = read_precision_record(local_610);\n                          break;\n                        case 0x36:\n                          local_24 = read_case_weight_record(local_610);\n                          break;\n                        case 0x37:\n                          local_24 = read_variable_record(local_610);\n                          break;\n                        case 0x38:\n                          local_24 = read_missing_value_record(local_610);\n                          break;\n                        case 0x39:\n                          local_24 = read_missing_value_lo_range_record(local_610);\n                          break;\n                        default:\n                          local_24 = 5;\n                          goto LAB_00101f5b;\n                        case 0x41:\n                          local_24 = read_missing_value_hi_range_record(local_610);\n                          break;\n                        case 0x42:\n                          local_24 = read_missing_value_range_record(local_610);\n                          break;\n                        case 0x43:\n                          local_24 = read_variable_label_record(local_610);\n                          break;\n                        case 0x44:\n                          local_24 = read_value_label_record(local_610);\n                          break;\n                        case 0x45:\n                          local_24 = read_document_record(local_610);\n                          break;\n                        case 0x46:\n                          if (*(int *)((long)local_610 + 0x2cc) ==\n                              *(int *)((long)local_610 + 0x2c8) + -1) {\n                            local_24 = handle_variables(local_610);\n                            if ((local_24 == 0) && (*(long *)((long)local_610 + 0x20) != 0)) {\n                              local_24 = read_por_file_data(local_610);\n                            }\n                          }\n                          else {\n                            local_24 = 8;\n                          }\n                          goto LAB_00101f5b;\n                        }\n                      } while (local_24 == 0);\n                    }\n                  }\n                  else {\n                    local_24 = 5;\n                  }\n                }\n              }\n              else {\n                local_24 = 2;\n              }\n            }\n            else {\n              local_24 = 2;\n            }\n          }\n        }\n        else {\n          local_24 = 2;\n        }\n      }\n    }\n  }\nLAB_00101f5b:\n  (*(code *)local_30[1])(local_30[5]);\n  por_ctx_free(local_610);\n  return local_24;\n}\n\n",
        "function_pr": "\nint readstat_parse_por(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  iconv_t pvVar3;\n  long lVar4;\n  undefined local_738 [264];\n  size_t local_630;\n  char local_624 [8];\n  undefined local_61c [8];\n  int local_614;\n  void *local_610;\n  char local_608 [1024];\n  undefined local_208 [60];\n  undefined auStack_1cc [148];\n  byte local_138 [264];\n  undefined8 *local_30;\n  int local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_24 = 0;\n  local_30 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_610 = (void *)por_ctx_init();\n  memcpy(local_610,local_10,0x40);\n  *(undefined8 *)((long)local_610 + 0x48) = local_20;\n  *(undefined8 **)((long)local_610 + 0x58) = local_30;\n  *(int *)((long)local_610 + 0x2d0) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)local_610 + 0x2d4) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  if (*(long *)((long)local_10 + 0x50) != 0) {\n    iVar2 = strcmp(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n    if (iVar2 != 0) {\n      pvVar3 = iconv_open(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n      *(iconv_t *)((long)local_610 + 0x2a8) = pvVar3;\n    }\n    if (*(long *)((long)local_610 + 0x2a8) == -1) {\n      *(undefined8 *)((long)local_610 + 0x2a8) = 0;\n      local_24 = 7;\n      goto LAB_00101f5b;\n    }\n  }\n  iVar2 = (*(code *)*local_30)(local_18,local_30[5]);\n  if (iVar2 == -1) {\n    local_24 = 1;\n  }\n  else {\n    lVar4 = (*(code *)local_30[2])(0,2,local_30[5]);\n    *(long *)((long)local_610 + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_24 = 0xf;\n    }\n    else {\n      lVar4 = (*(code *)local_30[2])(0,0,local_30[5]);\n      if (lVar4 == -1) {\n        local_24 = 0xf;\n      }\n      else {\n        lVar4 = read_bytes(local_610,local_208,200);\n        if (lVar4 == 200) {\n          local_24 = readstat_convert((long)local_610 + 0x89,0x15,auStack_1cc,0x14,0);\n          if (local_24 == 0) {\n            lVar4 = read_bytes(local_610,local_138,0x100);\n            if (lVar4 == 0x100) {\n              *(byte *)((long)local_610 + 0x60) = local_138[0x7e];\n              for (local_614 = 0; local_614 < 0x100; local_614 = local_614 + 1) {\n                if (PTR_por_ascii_lookup_00105fe8[local_614] == '\\0') {\n                  if (*(short *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2) != 0) {\n                    *(undefined2 *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                         *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2);\n                  }\n                }\n                else {\n                  *(short *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                       (short)(char)PTR_por_ascii_lookup_00105fe8[local_614];\n                }\n              }\n              *(undefined2 *)((long)local_610 + (ulong)local_138[0x40] * 2 + 0x9e) =\n                   *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + 0x80);\n              lVar4 = read_bytes(local_610,local_61c,8);\n              if (lVar4 == 8) {\n                local_630 = por_utf8_encode(local_61c,8,local_624,8,(long)local_610 + 0x9e);\n                if (local_630 == 0xffffffffffffffff) {\n                  if (*(long *)((long)local_610 + 0x30) != 0) {\n                    snprintf(local_608,0x400,\"Error converting check string: %.*s\",8,local_61c);\n                    (**(code **)((long)local_610 + 0x30))\n                              (local_608,*(undefined8 *)((long)local_610 + 0x48));\n                  }\n                  local_24 = 0x10;\n                }\n                else {\n                  iVar2 = strncmp(\"SPSSPORT\",local_624,local_630);\n                  if (iVar2 == 0) {\n                    *(undefined4 *)((long)local_610 + 0x2cc) = 0xffffffff;\n                    local_24 = read_version_and_timestamp(local_610);\n                    if (local_24 == 0) {\n                      local_24 = 0;\n                      do {\n                        uVar1 = read_tag(local_610);\n                        switch(uVar1) {\n                        case 0x31:\n                        case 0x32:\n                        case 0x33:\n                          local_24 = read_string(local_610,local_738,0x100);\n                          break;\n                        case 0x34:\n                          local_24 = read_variable_count_record(local_610);\n                          break;\n                        case 0x35:\n                          local_24 = read_precision_record(local_610);\n                          break;\n                        case 0x36:\n                          local_24 = read_case_weight_record(local_610);\n                          break;\n                        case 0x37:\n                          local_24 = read_variable_record(local_610);\n                          break;\n                        case 0x38:\n                          local_24 = read_missing_value_record(local_610);\n                          break;\n                        case 0x42:\n                          local_24 = read_missing_value_range_record(local_610);\n                          break;\n                        case 0x39:\n                          local_24 = read_missing_value_lo_range_record(local_610);\n                          break;\n                        case 0x41:\n                          local_24 = read_missing_value_hi_range_record(local_610);\n                          break;\n                        case 0x43:\n                          local_24 = read_variable_label_record(local_610);\n                          break;\n                        case 0x44:\n                          local_24 = read_value_label_record(local_610);\n                          break;\n                        case 0x45:\n                          local_24 = read_document_record(local_610);\n                          break;\n                        case 0x46:\n                          if (*(int *)((long)local_610 + 0x2cc) ==\n                              *(int *)((long)local_610 + 0x2c8) + -1) {\n                            local_24 = handle_variables(local_610);\n                            if ((local_24 == 0) && (*(long *)((long)local_610 + 0x20) != 0)) {\n                              local_24 = read_por_file_data(local_610);\n                            }\n                          }\n                          else {\n                            local_24 = 8;\n                          }\n                          goto LAB_00101f5b;\n                        default:\n                          local_24 = 5;\n                          goto LAB_00101f5b;\n                        }\n                      } while (local_24 == 0);\n                    }\n                  }\n                  else {\n                    local_24 = 5;\n                  }\n                }\n              }\n              else {\n                local_24 = 2;\n              }\n            }\n            else {\n              local_24 = 2;\n            }\n          }\n        }\n        else {\n          local_24 = 2;\n        }\n      }\n    }\n  }\nLAB_00101f5b:\n  (*(code *)local_30[1])(local_30[5]);\n  por_ctx_free(local_610);\n  return local_24;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  if()\n  if(){\n    if(call(, ))call(, )\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , , , )\n  if()goto label\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  for(;;){\n    if(){\n      \n    }elseif(){\n      \n    }\n  }\n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , , , )){\n    if(){\n      call(, , , , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  call()\n  if()goto label\n  while(){\n    call()\n    switch(){\n      case :\n      \n      case :\n      \n      case :\n        \n        call(, , )\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        if(){\n          \n          goto label\n        }\n        call()\n        if()goto label\n        if(){\n          call()\n        }\n        goto label\n      case :\n        \n        \n        goto label\n    }\n    if()\n  }\n  call()\n  call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, , )\n  \n  \n  \n  if(){\n    \n  }\n  if(){\n    call(, )\n    if(){\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n    }else{\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          call(, , , , )\n          if(){\n            call(, , )\n            if(){\n              \n              for(;;){\n                if(){\n                  if(){\n                    \n                  }\n                }else{\n                  \n                }\n              }\n              \n              call(, , )\n              if(){\n                call(, , , , )\n                if(){\n                  if(){\n                    call(, , , , )\n                    call(, )\n                  }\n                  \n                }else{\n                  call(, , )\n                  if(){\n                    \n                    call()\n                    if(){\n                      \n                      do{\n                        call()\n                        switch(){\n                          case :\n                          case :\n                          case :\n                            call(, , )\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            \n                            \n                            goto label\n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            if(){\n                              call()\n                              if(){\n                                call()\n                              }\n                            }else{\n                              \n                            }\n                            goto label\n                        }\n                      }while()\n                    }\n                  }else{\n                    \n                  }\n                }\n              }else{\n                \n              }\n            }else{\n              \n            }\n          }\n        }else{\n          \n        }\n      }\n    }\n  }\n  call()\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, , )\n  \n  \n  \n  if(){\n    \n  }\n  if(){\n    call(, )\n    if(){\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n    }else{\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          call(, , , , )\n          if(){\n            call(, , )\n            if(){\n              \n              for(;;){\n                if(){\n                  if(){\n                    \n                  }\n                }else{\n                  \n                }\n              }\n              \n              call(, , )\n              if(){\n                call(, , , , )\n                if(){\n                  if(){\n                    call(, , , , )\n                    call(, )\n                  }\n                  \n                }else{\n                  call(, , )\n                  if(){\n                    \n                    call()\n                    if(){\n                      \n                      do{\n                        call()\n                        switch(){\n                          case :\n                          case :\n                          case :\n                            call(, , )\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            if(){\n                              call()\n                              if(){\n                                call()\n                              }\n                            }else{\n                              \n                            }\n                            goto label\n                          case :\n                            \n                            \n                            goto label\n                        }\n                      }while()\n                    }\n                  }else{\n                    \n                  }\n                }\n              }else{\n                \n              }\n            }else{\n              \n            }\n          }\n        }else{\n          \n        }\n      }\n    }\n  }\n  call()\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.296875,
          "pr_ppl": 2.296875,
          "source_ast_ppl": 2.703125,
          "base_ast_ppl": 2.734375,
          "pr_ast_ppl": 2.71875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "motivation": "A recovered the for-loop while B used while-goto",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_ctx_init-O0.so",
        "function": "dta_ctx_init",
        "source_code": "readstat_error_t dta_ctx_init(dta_ctx_t *ctx, uint32_t nvar, uint64_t nobs,\n        unsigned char byteorder, unsigned char ds_format,\n        const char *input_encoding, const char *output_encoding) {\n    readstat_error_t retval = READSTAT_OK;\n    int machine_byteorder = DTA_HILO;\n    if (ds_format < DTA_MIN_VERSION || ds_format > DTA_MAX_VERSION)\n        return READSTAT_ERROR_UNSUPPORTED_FILE_FORMAT_VERSION;\n\n    if (machine_is_little_endian()) {\n        machine_byteorder = DTA_LOHI;\n    }\n\n    ctx->bswap = (byteorder != machine_byteorder);\n    ctx->ds_format = ds_format;\n    ctx->endianness = byteorder == DTA_LOHI ? READSTAT_ENDIAN_LITTLE : READSTAT_ENDIAN_BIG;\n\n    ctx->nvar = nvar;\n    ctx->nobs = nobs;\n\n    if (ctx->nvar) {\n        if ((ctx->variables = readstat_calloc(ctx->nvar, sizeof(readstat_variable_t *))) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n    }\n\n    ctx->machine_is_twos_complement = READSTAT_MACHINE_IS_TWOS_COMPLEMENT;\n\n    if (ds_format < 105) {\n        ctx->fmtlist_entry_len = 7;\n    } else if (ds_format < 114) {\n        ctx->fmtlist_entry_len = 12;\n    } else if (ds_format < 118) {\n        ctx->fmtlist_entry_len = 49;\n    } else {\n        ctx->fmtlist_entry_len = 57;\n    }\n    \n    if (ds_format >= 117) {\n        ctx->typlist_version = 117;\n    } else if (ds_format >= 111) {\n        ctx->typlist_version = 111;\n    } else {\n        ctx->typlist_version = 0;\n    }\n\n    if (ds_format >= 118) {\n        ctx->data_label_len_len = 2;\n        ctx->strl_v_len = 2;\n        ctx->strl_o_len = 6;\n    } else if (ds_format >= 117) {\n        ctx->data_label_len_len = 1;\n        ctx->strl_v_len = 4;\n        ctx->strl_o_len = 4;\n    }\n\n    if (ds_format < 105) {\n        ctx->expansion_len_len = 0;\n    } else if (ds_format < 110) {\n        ctx->expansion_len_len = 2;\n    } else {\n        ctx->expansion_len_len = 4;\n    }\n    \n    if (ds_format < 110) {\n        ctx->lbllist_entry_len = 9;\n        ctx->variable_name_len = 9;\n        ctx->ch_metadata_len = 9;\n    } else if (ds_format < 118) {\n        ctx->lbllist_entry_len = 33;\n        ctx->variable_name_len = 33;\n        ctx->ch_metadata_len = 33;\n    } else {\n        ctx->lbllist_entry_len = 129;\n        ctx->variable_name_len = 129;\n        ctx->ch_metadata_len = 129;\n    }\n\n    if (ds_format < 108) {\n        ctx->variable_labels_entry_len = 32;\n        ctx->data_label_len = 32;\n    } else if (ds_format < 118) {\n        ctx->variable_labels_entry_len = 81;\n        ctx->data_label_len = 81;\n    } else {\n        ctx->variable_labels_entry_len = 321;\n        ctx->data_label_len = 321;\n    }\n\n    if (ds_format < 105) {\n        ctx->timestamp_len = 0;\n        ctx->value_label_table_len_len = 2;\n        ctx->value_label_table_labname_len = 12;\n        ctx->value_label_table_padding_len = 2;\n    } else {\n        ctx->timestamp_len = 18;\n        ctx->value_label_table_len_len = 4;\n        if (ds_format < 118) {\n            ctx->value_label_table_labname_len = 33;\n        } else {\n            ctx->value_label_table_labname_len = 129;\n        }\n        ctx->value_label_table_padding_len = 3;\n    }\n\n    if (ds_format < 117) {\n        ctx->typlist_entry_len = 1;\n        ctx->file_is_xmlish = 0;\n    } else {\n        ctx->typlist_entry_len = 2;\n        ctx->file_is_xmlish = 1;\n    }\n\n    if (ds_format < 113) {\n        ctx->max_int8 = DTA_OLD_MAX_INT8;\n        ctx->max_int16 = DTA_OLD_MAX_INT16;\n        ctx->max_int32 = DTA_OLD_MAX_INT32;\n        ctx->max_float = DTA_OLD_MAX_FLOAT;\n        ctx->max_double = DTA_OLD_MAX_DOUBLE;\n    } else {\n        ctx->max_int8 = DTA_113_MAX_INT8;\n        ctx->max_int16 = DTA_113_MAX_INT16;\n        ctx->max_int32 = DTA_113_MAX_INT32;\n        ctx->max_float = DTA_113_MAX_FLOAT;\n        ctx->max_double = DTA_113_MAX_DOUBLE;\n\n        ctx->supports_tagged_missing = 1;\n    }\n\n    if (output_encoding) {\n        if (input_encoding) {\n            ctx->converter = iconv_open(output_encoding, input_encoding);\n        } else if (ds_format < 118) {\n            ctx->converter = iconv_open(output_encoding, \"WINDOWS-1252\");\n        } else if (strcmp(output_encoding, \"UTF-8\") != 0) {\n            ctx->converter = iconv_open(output_encoding, \"UTF-8\");\n        }\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n\n    if (ds_format < 119) {\n        ctx->srtlist_len = (ctx->nvar + 1) * sizeof(int16_t);\n    } else {\n        ctx->srtlist_len = (ctx->nvar + 1) * sizeof(int32_t);\n    }\n\n    if ((ctx->srtlist = readstat_malloc(ctx->srtlist_len)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->nvar > 0) {\n        ctx->typlist_len = ctx->nvar * sizeof(uint16_t);\n        ctx->varlist_len = ctx->variable_name_len * ctx->nvar * sizeof(char);\n        ctx->fmtlist_len = ctx->fmtlist_entry_len * ctx->nvar * sizeof(char);\n        ctx->lbllist_len = ctx->lbllist_entry_len * ctx->nvar * sizeof(char);\n        ctx->variable_labels_len = ctx->variable_labels_entry_len * ctx->nvar * sizeof(char);\n\n        if ((ctx->typlist = readstat_malloc(ctx->typlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->varlist = readstat_malloc(ctx->varlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->fmtlist = readstat_malloc(ctx->fmtlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->lbllist = readstat_malloc(ctx->lbllist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->variable_labels = readstat_malloc(ctx->variable_labels_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n    }\n\n    ctx->initialized = 1;\n\ncleanup:\n    return retval;\n}\n",
        "function_base": "\nundefined4\ndta_ctx_init(long param_1,undefined4 param_2,undefined8 param_3,char param_4,byte param_5,\n            char *param_6,char *param_7)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  iconv_t pvVar4;\n  undefined4 uVar5;\n  \n  cVar1 = '\\x01';\n  if ((param_5 < 0x68) || (0x77 < param_5)) {\n    return 0x18;\n  }\n  iVar2 = machine_is_little_endian();\n  if (iVar2 != 0) {\n    cVar1 = '\\x02';\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfe | param_4 != cVar1;\n  *(uint *)(param_1 + 0x108) = (uint)param_5;\n  uVar5 = 2;\n  if (param_4 == '\\x02') {\n    uVar5 = 1;\n  }\n  *(undefined4 *)(param_1 + 0x170) = uVar5;\n  *(undefined4 *)(param_1 + 0x10c) = param_2;\n  *(undefined8 *)(param_1 + 0x110) = param_3;\n  if (*(int *)(param_1 + 0x10c) != 0) {\n    lVar3 = readstat_calloc((long)*(int *)(param_1 + 0x10c),8);\n    *(long *)(param_1 + 0x168) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfd;\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xa0) = 7;\n  }\n  else if (param_5 < 0x72) {\n    *(undefined8 *)(param_1 + 0xa0) = 0xc;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa0) = 0x31;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa0) = 0x39;\n  }\n  if (param_5 < 0x75) {\n    if (param_5 < 0x6f) {\n      *(undefined1 *)(param_1 + 0x28) = 0;\n    }\n    else {\n      *(undefined1 *)(param_1 + 0x28) = 0x6f;\n    }\n  }\n  else {\n    *(undefined1 *)(param_1 + 0x28) = 0x75;\n  }\n  if (param_5 < 0x76) {\n    if (0x74 < param_5) {\n      *(undefined8 *)(param_1 + 0x10) = 1;\n      *(undefined8 *)(param_1 + 0xe0) = 4;\n      *(undefined8 *)(param_1 + 0xe8) = 4;\n    }\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x10) = 2;\n    *(undefined8 *)(param_1 + 0xe0) = 2;\n    *(undefined8 *)(param_1 + 0xe8) = 6;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xb8) = 0;\n  }\n  else if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xb8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb8) = 4;\n  }\n  if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xa8) = 9;\n    *(undefined8 *)(param_1 + 0x98) = 9;\n    *(undefined8 *)(param_1 + 0xc0) = 9;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa8) = 0x21;\n    *(undefined8 *)(param_1 + 0x98) = 0x21;\n    *(undefined8 *)(param_1 + 0xc0) = 0x21;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa8) = 0x81;\n    *(undefined8 *)(param_1 + 0x98) = 0x81;\n    *(undefined8 *)(param_1 + 0xc0) = 0x81;\n  }\n  if (param_5 < 0x6c) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x20;\n    *(undefined8 *)(param_1 + 8) = 0x20;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x51;\n    *(undefined8 *)(param_1 + 8) = 0x51;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb0) = 0x141;\n    *(undefined8 *)(param_1 + 8) = 0x141;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n    *(undefined8 *)(param_1 + 200) = 2;\n    *(undefined8 *)(param_1 + 0xd0) = 0xc;\n    *(undefined8 *)(param_1 + 0xd8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x20) = 0x12;\n    *(undefined8 *)(param_1 + 200) = 4;\n    if (param_5 < 0x76) {\n      *(undefined8 *)(param_1 + 0xd0) = 0x21;\n    }\n    else {\n      *(undefined8 *)(param_1 + 0xd0) = 0x81;\n    }\n    *(undefined8 *)(param_1 + 0xd8) = 3;\n  }\n  if (param_5 < 0x75) {\n    *(undefined8 *)(param_1 + 0x30) = 1;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x30) = 2;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb | 4;\n  }\n  if (param_5 < 0x71) {\n    *(undefined1 *)(param_1 + 0x139) = 0x7e;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7ffe;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7ffffffe;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n  }\n  else {\n    *(undefined1 *)(param_1 + 0x139) = 100;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7fe4;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7fffffe4;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xf7 | 8;\n  }\n  if (param_7 != (char *)0x0) {\n    if (param_6 == (char *)0x0) {\n      if (param_5 < 0x76) {\n        pvVar4 = iconv_open(param_7,\"WINDOWS-1252\");\n        *(iconv_t *)(param_1 + 0x178) = pvVar4;\n      }\n      else {\n        iVar2 = strcmp(param_7,\"UTF-8\");\n        if (iVar2 != 0) {\n          pvVar4 = iconv_open(param_7,\"UTF-8\");\n          *(iconv_t *)(param_1 + 0x178) = pvVar4;\n        }\n      }\n    }\n    else {\n      pvVar4 = iconv_open(param_7,param_6);\n      *(iconv_t *)(param_1 + 0x178) = pvVar4;\n    }\n    if (*(long *)(param_1 + 0x178) == -1) {\n      *(undefined8 *)(param_1 + 0x178) = 0;\n      return 7;\n    }\n  }\n  if (param_5 < 0x77) {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 1;\n  }\n  else {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 2;\n  }\n  lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x60));\n  *(long *)(param_1 + 0x58) = lVar3;\n  if (lVar3 == 0) {\n    return 3;\n  }\n  if (0 < *(int *)(param_1 + 0x10c)) {\n    *(long *)(param_1 + 0x40) = (long)*(int *)(param_1 + 0x10c) << 1;\n    *(long *)(param_1 + 0x50) = *(long *)(param_1 + 0x98) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x70) = *(long *)(param_1 + 0xa0) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x80) = *(long *)(param_1 + 0xa8) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x90) = *(long *)(param_1 + 0xb0) * (long)*(int *)(param_1 + 0x10c);\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x40));\n    *(long *)(param_1 + 0x38) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x50));\n    *(long *)(param_1 + 0x48) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x70));\n    *(long *)(param_1 + 0x68) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x80));\n    *(long *)(param_1 + 0x78) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x90));\n    *(long *)(param_1 + 0x88) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(undefined4 *)(param_1 + 0x1d8) = 1;\n  return 0;\n}\n\n",
        "function_pr": "\nundefined4\ndta_ctx_init(long param_1,undefined4 param_2,undefined8 param_3,char param_4,byte param_5,\n            char *param_6,char *param_7)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  iconv_t pvVar4;\n  undefined4 uVar5;\n  \n  cVar1 = '\\x01';\n  if ((param_5 < 0x68) || (0x77 < param_5)) {\n    return 0x18;\n  }\n  iVar2 = machine_is_little_endian();\n  if (iVar2 != 0) {\n    cVar1 = '\\x02';\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfe | param_4 != cVar1;\n  *(uint *)(param_1 + 0x108) = (uint)param_5;\n  uVar5 = 2;\n  if (param_4 == '\\x02') {\n    uVar5 = 1;\n  }\n  *(undefined4 *)(param_1 + 0x170) = uVar5;\n  *(undefined4 *)(param_1 + 0x10c) = param_2;\n  *(undefined8 *)(param_1 + 0x110) = param_3;\n  if (*(int *)(param_1 + 0x10c) != 0) {\n    lVar3 = readstat_calloc((long)*(int *)(param_1 + 0x10c),8);\n    *(long *)(param_1 + 0x168) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfd;\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xa0) = 7;\n  }\n  else if (param_5 < 0x72) {\n    *(undefined8 *)(param_1 + 0xa0) = 0xc;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa0) = 0x31;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa0) = 0x39;\n  }\n  if (param_5 < 0x75) {\n    if (param_5 < 0x6f) {\n      *(undefined *)(param_1 + 0x28) = 0;\n    }\n    else {\n      *(undefined *)(param_1 + 0x28) = 0x6f;\n    }\n  }\n  else {\n    *(undefined *)(param_1 + 0x28) = 0x75;\n  }\n  if (param_5 < 0x76) {\n    if (0x74 < param_5) {\n      *(undefined8 *)(param_1 + 0x10) = 1;\n      *(undefined8 *)(param_1 + 0xe0) = 4;\n      *(undefined8 *)(param_1 + 0xe8) = 4;\n    }\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x10) = 2;\n    *(undefined8 *)(param_1 + 0xe0) = 2;\n    *(undefined8 *)(param_1 + 0xe8) = 6;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xb8) = 0;\n  }\n  else if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xb8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb8) = 4;\n  }\n  if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xa8) = 9;\n    *(undefined8 *)(param_1 + 0x98) = 9;\n    *(undefined8 *)(param_1 + 0xc0) = 9;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa8) = 0x21;\n    *(undefined8 *)(param_1 + 0x98) = 0x21;\n    *(undefined8 *)(param_1 + 0xc0) = 0x21;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa8) = 0x81;\n    *(undefined8 *)(param_1 + 0x98) = 0x81;\n    *(undefined8 *)(param_1 + 0xc0) = 0x81;\n  }\n  if (param_5 < 0x6c) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x20;\n    *(undefined8 *)(param_1 + 8) = 0x20;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x51;\n    *(undefined8 *)(param_1 + 8) = 0x51;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb0) = 0x141;\n    *(undefined8 *)(param_1 + 8) = 0x141;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n    *(undefined8 *)(param_1 + 200) = 2;\n    *(undefined8 *)(param_1 + 0xd0) = 0xc;\n    *(undefined8 *)(param_1 + 0xd8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x20) = 0x12;\n    *(undefined8 *)(param_1 + 200) = 4;\n    if (param_5 < 0x76) {\n      *(undefined8 *)(param_1 + 0xd0) = 0x21;\n    }\n    else {\n      *(undefined8 *)(param_1 + 0xd0) = 0x81;\n    }\n    *(undefined8 *)(param_1 + 0xd8) = 3;\n  }\n  if (param_5 < 0x75) {\n    *(undefined8 *)(param_1 + 0x30) = 1;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x30) = 2;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb | 4;\n  }\n  if (param_5 < 0x71) {\n    *(undefined *)(param_1 + 0x139) = 0x7e;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7ffe;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7ffffffe;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n  }\n  else {\n    *(undefined *)(param_1 + 0x139) = 100;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7fe4;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7fffffe4;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xf7 | 8;\n  }\n  if (param_7 != (char *)0x0) {\n    if (param_6 == (char *)0x0) {\n      if (param_5 < 0x76) {\n        pvVar4 = iconv_open(param_7,\"WINDOWS-1252\");\n        *(iconv_t *)(param_1 + 0x178) = pvVar4;\n      }\n      else {\n        iVar2 = strcmp(param_7,\"UTF-8\");\n        if (iVar2 != 0) {\n          pvVar4 = iconv_open(param_7,\"UTF-8\");\n          *(iconv_t *)(param_1 + 0x178) = pvVar4;\n        }\n      }\n    }\n    else {\n      pvVar4 = iconv_open(param_7,param_6);\n      *(iconv_t *)(param_1 + 0x178) = pvVar4;\n    }\n    if (*(long *)(param_1 + 0x178) == -1) {\n      *(undefined8 *)(param_1 + 0x178) = 0;\n      return 7;\n    }\n  }\n  if (param_5 < 0x77) {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 1;\n  }\n  else {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 2;\n  }\n  lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x60));\n  *(long *)(param_1 + 0x58) = lVar3;\n  if (lVar3 == 0) {\n    return 3;\n  }\n  if (0 < *(int *)(param_1 + 0x10c)) {\n    *(long *)(param_1 + 0x40) = (long)*(int *)(param_1 + 0x10c) << 1;\n    *(long *)(param_1 + 0x50) = *(long *)(param_1 + 0x98) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x70) = *(long *)(param_1 + 0xa0) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x80) = *(long *)(param_1 + 0xa8) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x90) = *(long *)(param_1 + 0xb0) * (long)*(int *)(param_1 + 0x10c);\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x40));\n    *(long *)(param_1 + 0x38) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x50));\n    *(long *)(param_1 + 0x48) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x70));\n    *(long *)(param_1 + 0x68) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x80));\n    *(long *)(param_1 + 0x78) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x90));\n    *(long *)(param_1 + 0x88) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(undefined4 *)(param_1 + 0x1d8) = 1;\n  return 0;\n}\n\n",
        "source_ast": "{\n  \n  \n  if()return\n  if(call()){\n    \n  }\n  \n  \n  (? : )\n  \n  \n  if(){\n    if(call(, )){\n      \n      goto label\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      call(, )\n    }elseif(){\n      call(, )\n    }elseif(call(, )){\n      call(, )\n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(){\n    \n    \n    \n    \n    \n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  call()\n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    call(, )\n    \n    if(){\n      return\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    if(){\n      \n    }else{\n      \n    }\n  }else{\n    \n  }\n  if(){\n    if(){\n      \n      \n      \n    }\n  }else{\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      if(){\n        call(, )\n        \n      }else{\n        call(, )\n        if(){\n          call(, )\n          \n        }\n      }\n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      return\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  call()\n  \n  if(){\n    return\n  }\n  if(){\n    \n    \n    \n    \n    \n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n  }\n  \n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  call()\n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    call(, )\n    \n    if(){\n      return\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    if(){\n      \n    }else{\n      \n    }\n  }else{\n    \n  }\n  if(){\n    if(){\n      \n      \n      \n    }\n  }else{\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      if(){\n        call(, )\n        \n      }else{\n        call(, )\n        if(){\n          call(, )\n          \n        }\n      }\n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      return\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  call()\n  \n  if(){\n    return\n  }\n  if(){\n    \n    \n    \n    \n    \n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n  }\n  \n  return\n}",
        "metrics": {
          "source_ppl": 2.0,
          "base_ppl": 1.5625,
          "pr_ppl": 1.5625,
          "source_ast_ppl": 3.109375,
          "base_ast_ppl": 2.625,
          "pr_ast_ppl": 2.625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate due to its clear and structured control flow, logical variable naming, and adherence to standard C idioms, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      }
    ],
    "gemma2": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 10:\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n          case :\n            \n            goto label\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 2.015625,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.015625,
          "pr_ast_ppl": 2.0,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "Error",
          "motivation": "\tif (320);\n\n\n\n    if (u_ is_31)\n\n\n    if (u)\n\n\n\n    if (u)\n\n\n\n    break;\n\n\n\n\t}\n    if (u)\n\n\n\n    break;\n    }\n  return;\n  if (u)\n    break;\n    if (u)\n    break;\n    if (u)\n    break;\n\n    if (u)\n\n\n\n    break;\n    if (u)\n\n\n* 32 = 0x33\n\n**_33** = 0x33)\n * 34\n * 343\n\n\n* 343\n* 3433\n\n3433\n\n\n\n// 3434\n\n\n\n3433\n* 3433\n3434\n\n34343430.33\n33,34343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434344);\n\n3434343434343434343434343434343434343434343434434343434343434343434343434343434343434343434343443434344343434344344343443434344343443434343443434434344344343443443434434344343443434555);\n\n6343434343434343434343434343434343443434343434343434434343434344343434434434434434343443434434434434344343434434344343434343443434344344343434345);\n\n34434534343434344343434343434343443434344344343443443443434434344345556364556660);\n\n3636)\n\n\n******\n)\n\n\n\nif(u)\n\n\n\n)\n5143456434344343434434434343443434343434343434343434345668)\n)\n444\n\n),);\n55444366)\n34666\n),\n0434634436655636)\n360054343434343434343434343434343434343434556667)\n**1)**,\n\n\n\n**434**\n\n\n1),\n)\n4"
        },
        "llm_ast": {
          "motivation": "Both candidates incorrectly handle the nesting and flow of the Source's code, introducing numerous `goto` statements and excessive nesting. However, Candidate A at least attempts to maintain the `ForLoop` structure in the main loop, while Candidate B incorrectly uses `WhileLoop`.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 10:\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n          case :\n            \n            goto label\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 2.015625,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.015625,
          "pr_ast_ppl": 2.0,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "Error",
          "motivation": "`3f`\n\n\n\nif(u)\n\n**end_s_u_340_332)\n\n\n**4**\n\n\n\nif(u)\nif (u)\n\n}\n\n\n\nif (0x03)\n\n\n\nif (0)\n\n\n}\n\n\n\n;\n\n\n\nif (0)\n\n\n\nbreak;\n\nif (0)\n\n;\nif (0)\n\nif (0)\nif (0x30)\n\n\n_333.\nif (0)\n\n\nif (0x0003)\nif (0)\nif (0)\nif (0)\nif (0)\nif (0)\nif (0)\n\n**3**\n\nif (0)\nif (0)\n\n\n\nif (0)\n\nif (0)\nif (0)\n\n```\n\n\nThe above 30033030033)\n\n\n\nif (0)\n\nif (0)\n\n\n\nreturn 0;\n}\n\n**3**\n\nreturn 0;\n\n}\n\nreturn 0;\n\n\n\nreturn 0;\n\nreturn 0;\n\n\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\n\n\nif (0)\n\n\n* **10**\n\nif (0)\n\n\n\nreturn 0;\n\nif (0)\n\n\n\nreturn 0;\n\n\n\nreturn 0;\n\n\n\nreturn 0;\n\n\n\nreturn 0;\n\n\n\nreturn 0;\n\n\n\nreturn 0;\n\n\n\nreturn 0;\n\nif (0)\n\nreturn 0;\n\n\nif (0)\n\nreturn 0;\n\n\n\nreturn 0;\n\n\n\nif (0)\n\n\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\n\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\n\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\n\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0; return 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0; return 0;\n\nreturn 0; return 0; return 0; return 0; return 0; return 0;\nreturn 0; return 0; return 0; return 0; return 0;\n\nreturn 0; return 0; return 0; return 0; return 0; return 0; return 0; return 0; return 0; return 0; return 0;\nreturn 0;\n\nreturn 0; return 0; return 0; return 0; return 0; return 0; return 0;\nreturn 0; return 0;\nreturn 0; return 0;\nreturn 0; return 0;\nreturn 0; return 0;\nreturn 0;\nreturn 0; return 0; return 0; return 0;\nreturn 0;\nreturn 0; return 0; return 0;\nreturn 0;\nreturn 0; return 0; return 0; return 0; return 0;\nreturn 0; return 0; return 0; return 0;\nreturn 0; return 0; return 0; return 0; return 0; return 0;\nreturn 0; return 0;\nreturn 0; return 0;\nreturn 0; return 0; return 0; return 0; return 0; return 0;\nreturn 0; return 0;\nreturn 0; return 0;\nreturn 0; return 0;\nreturn 0; return 0;\nreturn 0; return 0; return 0;\nreturn 0;\nreturn 0;\nreturn 0; return 0; return 0; return 0;\nreturn 0;\nreturn 0; return 0; return 0;\nreturn 0;\nreturn 0; return 0;\nreturn 0;\nreturn 0; return 0; return 0; return 0; return 0; return 0; return 0; return 0; return 0; return 0;\nreturn 0; return 0; return 0;\nreturn 0; return 0;\nreturn 0; return 0; return 0; return 0;\nreturn 0;\nreturn 0; return 0;\nreturn 0; return 0; return 0; return 0; return 0;\nreturn 0; return 0;\nreturn 0;\nreturn 0; return 0;\nreturn 0; return 0; return 0; return 0; return 0;\nreturn 0; return 0; return 0;\nreturn 0;\nreturn 0;\nreturn 0; return 0;\nreturn 0; return 0; return 0; return 0;\nreturn 0; return 0;\nreturn 0; return 0; return 0; return 0; return 0; return 0; return 0; return 0;\nreturn 0; return 0; return 0; return 0;\nreturn 0; return 0; return 0; return 0;\nreturn 0; return 0; return 0;\nreturn 0;\nreturn 0; return 0;\nreturn 0; return 0; return 0;\nreturn 0; return 0; return 0; return 0; return 0;\nreturn 0;\nreturn 0; return 0;\nreturn 0;\nreturn 0;\nreturn 0; return 0;\nreturn 0; return 0; return 0;\nreturn 0; return 0; return 0;\nreturn 0; return 0;\nreturn 0;\nreturn 0;\nreturn 0; return 0;\nreturn 0;\nreturn 0; return 0;\nreturn 0; return 0;\nreturn 0; return 0;\nreturn 0;\nreturn 0; return 0;\nreturn 0;\nreturn 0; return 0; return 0; return 0;\nreturn 0; return 0; return 0; return 0; return 0;\nreturn 0; return 0; return 0;\nreturn 0; return 0;\nreturn 0;\nreturn 0;\nreturn 0; return 0; return 0;\nreturn 0;\nreturn 0;\nreturn 0;\nreturn 0; return 0; return 0; return 0;\nreturn 0; return 0;\nreturn 0;\nreturn 0;\nreturn 0;\nreturn 0;\nreturn 0;\nreturn 0; return 0;\nreturn 0;\nreturn 0; return 0; return 0;\nreturn 0; return 0; return 0; return 0;\nreturn 0;\nreturn 0; return 0; return 0;\n)\nreturn 0;\nreturn 0;\n)\nreturn 0; return 0;\n)\nreturn 0; return 0;\n\nreturn 0; return 0;\nreturn 0; return 0;\nreturn 0;\n\nif (0x)\nif (0x0000)\nif (0x)\nreturn 0;\nif 0x0000\nif 0x000)\nif 0x000)\nreturn 0;\n\nif 0x000)\nif 00)\nif 0x000)\nif 0x000\nif 0x000\n\nif 0x000\n\nreturn 0;\n\nif 0x000)\nif 0x000)\n\nreturn 0;\nif 0x000; if 0x000)\nif 000; if 000)\nif 000; return 0; return 0; return 0; return 0; return 0;\nreturn 0; return 0;\nif 0x555)\n\nif 0x000, if 0x000\nreturn 0;\nif 0x000\n\nif 0x0000)\nif 0000)\n\nreturn\n\n\nreturn\nif 000; return 0;\nif 000;\n\nreturn\nif 000; return\nif 000;\n\nreturn\n\n\nif 000; return 0x2\n\n"
        },
        "llm_ast": {
          "motivation": "Both candidates struggle to accurately represent the nesting and control flow of the Source. However, Candidate A is closer in terms of loop structure (using ForLoop when appropriate) and overall nesting depth.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_signextend-O0.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "source_ast": "{\n  if(){\n    switch(){\n      \n      case :\n        call(, , )\n        \n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if()call(, , )\n        return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  if(){\n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if(){\n          call(, , )\n        }\n        return\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  if(){\n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if(){\n          call(, , )\n        }\n        return\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.875,
          "base_ppl": 2.046875,
          "pr_ppl": 2.078125,
          "source_ast_ppl": 1.9609375,
          "base_ast_ppl": 1.921875,
          "pr_ast_ppl": 1.9140625,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B, while introducing new variable names and a slightly different function signature, presents a more idiomatic C structure with clear type handling and a readable switch statement.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates correctly reconstruct the nested structure and loop types. Candidate A has a slightly shallower nesting depth, more closely mirroring the source.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_signextend-O2.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,byte *param_2,long param_3)\n\n{\n  if ((*param_2 & 8) == 0) {\n    switch(param_2[6]) {\n    case 1:\n      return (long)(char)param_3;\n    case 2:\n    case 7:\n    case 10:\n      return (long)(short)param_3;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      return (long)(int)param_3;\n    default:\n      param_3 = -1;\n      if ((*(byte *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\");\n        return -1;\n      }\n    }\n  }\n  return param_3;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,byte *param_2,long param_3)\n\n{\n  if ((*param_2 & 8) == 0) {\n    switch(param_2[6]) {\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      return (long)(int)param_3;\n    case 2:\n    case 7:\n    case 10:\n      return (long)(short)param_3;\n    case 1:\n      return (long)(char)param_3;\n    default:\n      param_3 = -1;\n      if ((*(byte *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\");\n        return -1;\n      }\n    }\n  }\n  return param_3;\n}\n\n",
        "source_ast": "{\n  if(){\n    switch(){\n      \n      case :\n        call(, , )\n        \n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if()call(, , )\n        return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  if(){\n    switch(){\n      case :\n        return\n      case :\n      case :\n      case :\n        return\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        return\n      case :\n        \n        \n        if(){\n          call(, )\n          return\n        }\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  if(){\n    switch(){\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        return\n      case :\n      case :\n      case :\n        return\n      case :\n        return\n      case :\n        \n        \n        if(){\n          call(, )\n          return\n        }\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.875,
          "base_ppl": 1.734375,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 1.9609375,
          "base_ast_ppl": 1.765625,
          "pr_ast_ppl": 1.8359375,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B, while having some type inaccuracies, presents a more structured and readable approach with a clear `switch` statement for type handling.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates have the same loop type and complexity, but Candidate A matches the Source's nesting depth more accurately.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_signextend-O3.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,byte *param_2,long param_3)\n\n{\n  if ((*param_2 & 8) == 0) {\n    switch(param_2[6]) {\n    case 1:\n      return (long)(char)param_3;\n    case 2:\n    case 7:\n    case 10:\n      return (long)(short)param_3;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      return (long)(int)param_3;\n    default:\n      param_3 = -1;\n      if ((*(byte *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\");\n        return -1;\n      }\n    }\n  }\n  return param_3;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,byte *param_2,long param_3)\n\n{\n  if ((*param_2 & 8) == 0) {\n    switch(param_2[6]) {\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      return (long)(int)param_3;\n    case 2:\n    case 7:\n    case 10:\n      return (long)(short)param_3;\n    case 1:\n      return (long)(char)param_3;\n    default:\n      param_3 = -1;\n      if ((*(byte *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\");\n        return -1;\n      }\n    }\n  }\n  return param_3;\n}\n\n",
        "source_ast": "{\n  if(){\n    switch(){\n      \n      case :\n        call(, , )\n        \n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if()call(, , )\n        return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  if(){\n    switch(){\n      case :\n        return\n      case :\n      case :\n      case :\n        return\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        return\n      case :\n        \n        \n        if(){\n          call(, )\n          return\n        }\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  if(){\n    switch(){\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        return\n      case :\n      case :\n      case :\n        return\n      case :\n        return\n      case :\n        \n        \n        if(){\n          call(, )\n          return\n        }\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.875,
          "base_ppl": 1.734375,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 1.9609375,
          "base_ast_ppl": 1.765625,
          "pr_ast_ppl": 1.8359375,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B, while adding some type information, is significantly more readable with its use of a switch statement and clear logic flow.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates reconstruct the nested structure of the Source, but Candidate A preserves the nesting depth more accurately.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 1.9765625,
          "pr_ppl": 1.984375,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.140625,
          "pr_ast_ppl": 2.140625,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "winner": "Error",
          "motivation": "```\n\n**Analysis:**\n\nThe code has a 'once' variable, so it appears to handle a specific situation.\n\n **The candidate has some code for the BIFF8 and BIFF5. **\n\n**Note:** The code is a bit messy.\n\n**Error Handling:**\n\n*  `xls_debug` is used to print.\n\n**Error handling**\n\n\nThe code is missing a `return` statement.\n\n\nLet's look at the function's purpose.\n\n\n\n**Conclusion:**\n\nIt appears to be a function that parses a file, not a function.\n\n```\n\nThe code appears to be a file parser.\n\n**Candidate A**\n\n* The code is a bit messy.\n\n\n\n```\n\nThe code seems to be a parser that parses a file.\n\n\n\n**Candidate B**\n\n* The code has a lot of code.\n\n\n\nThe code seems to be a function that parses a file.\n\n\n\nThe code has a loop.\n\n\n\n**Candidate C**\n\n\n\n\n```\n\nLet me know if you need help with the code.\n\n\n\n\n**Candidate D\n\n\n\nThe code appears to be a structure that is used to parse a file.\n\n\n\n**Candidate E\n\n\n\n```\n\nThe code is a structure.\n\n\n\n\n"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n            break;\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              call(, , )\n              \n              \n            case :\n              call(, , )\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 1.75,
          "pr_ppl": 1.75,
          "source_ast_ppl": 2.046875,
          "base_ast_ppl": 2.0625,
          "pr_ast_ppl": 2.046875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "Error",
          "motivation": "    p = c_data + count;\n\n    return 0;\n\n\n  }\n\n\n\n   return 0;\n\n\n\n    `\n  if (p == pe) {\n    return READ_OK;\n}\n\n\n\n  return 0;\n\n    return READ_ERROR_FILE_END_OF_FILE;\n\n\n\n    return READ_ERROR_VAR_MISSING;\n\n\n\n    return READ_ERROR_VAR_NOT_found;\n\n\n\n  return READ_ERROR_PARSING_error;\n\n\n#line 123;\n  return READ_ERROR_error;\n\n  return READ_ERROR_error;\n\n  return READ_error;\n\n\n  return READ_error;\n\n\n  return READ_error;\n\n\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n\n  return READ_error;\n    return READ_error;\n\n  return READ_error;\n\n\nreturn READ_error;\n\n\n\n  return READ_error;\n\n  return READ_error;\n\n\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n\n\n  return READ_error;\n\n\n\n  return READ_error;\n\n  return READ_error;\n\n\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n  return READ_error;\n\n\n\n  return READ_error;\n\n  return READ_error;\n\n\n\n  return READ_error;\n\n\n\nreturn READ_error;\n\n\n\nreturn READ_error;\n\n\n\nreturn READ_error;\n\n\n\nreturn READ_error;\n\nreturn READ_error;\n\n\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\n\n\nreturn READ_error;\n\nreturn READ_error;\n\n\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\n\n\nreturn READ_error;\n\n\n\nreturn READ_error;\n\n\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\n\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\n\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\n\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\n\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\n\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\n\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error;\n\nreturn READ_error; return READ_error; return READ_error;\n\nreturn READ_error; return READ_error; return READ_error;\n\nreturn READ_error; return READ_error; return READ_error; return READ_error;\n\nreturn READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error;\nreturn READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error; return READ_error"
        },
        "llm_ast": {
          "motivation": "Both candidates introduce excessive `do`, `while`, and `goto` constructs, significantly deviating from the Source's structure. Candidate A preserves the nesting depth of the Source's main `if`-`else` block more accurately.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n            break;\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              call(, , )\n              \n              \n            case :\n              call(, , )\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 1.75,
          "pr_ppl": 1.75,
          "source_ast_ppl": 2.046875,
          "base_ast_ppl": 2.0625,
          "pr_ast_ppl": 2.046875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "Error",
          "motivation": "```\n\n**ANALYSIS**\nThe code is missing the following:\n\n- **Error handling**:\n  * **`local_local_local_local_local;\n  * **Local_local_local_local;\n  * **local_local_local_local;\n  * **local_local_local_local;\n\n\n\nThe code uses a variable named `local_local_local_local;\n  local_local_local_local_local_local_local_local_local_local;\n  \n\n```\n\n\n\nThe code is a.\n\n\n\n\n  *\n  local_local_local_local;\n  * _local_local_local_local_local_local_local_local_local;\n  * _local_local_local_local;\n\n\n\nThis code is a.\n\n\n\n* **local_local_local_local;\n\nThis code is.\n\n* **local_local_local_local_local;\n\n\n\n  * **_long_long_local_local_local_local;\n\n```\n\nThe code is a.\n\n`local_local_local_local_local_local_local_local_local_local;\n```\n\nThe code is a.\n\n**Note:**\nThe code is.\n\n*\n\n* **local_local_local_local;\n\n**Note:**\n* **local_local_local_local;\n\n**Note: **\n\n**local_local_local_local_local_local_local_local_local_local;\n\n\n\n* **local_local_local_local_local_local_local_local_local;\n\n\n\n* **local_local_local_local_local_local_local_local_local_local_local;\n\n\n* **local_local_local_local_local_local_local_local_local_local;\n\n\n\n* **local_local_local_local_local_local_local_local_local_local;\n * **local_local_local_local_local_local_local_local_local;\n\n\n\n * `return;`\n * **local_local_local_local_local_local_local_local_local_local_local_local_local;\n * * `return;`\n * *local_local_local_local_local_local_local_local_local_local_local;\n * *local_local_local_local_local_local_local_local_local;\n\n* *local_local_local_local_local_local_local_local_local_local_local_local_local;\n* *local_local_local_local_local_local_local_local_local_local_local;\n * *local_local_local_local_local_local_local_local_local_local_local;\n * *local_local_local_local_local_local_local_local_local_local_local_local_local;\n * *local_local_local_local_local_local_local_local_local_local_local;\n * *local_local_local_local_local_local_local_local_local_local_local_local;\n\n\n\n* *local_local_local_local_local_local_local_local_local_local_local;\n\n\n\n* *local_local_local_local_local_local_local_local_local_local_local_local;\n * *local_local_local_local_local_local_local_local_local_local_local_local;\n\n * *local_local_local_local_local_local_local_local_local_local;\n * *local_local_local_local_local_local_local_local_local_local_local_local_local;\n * local_local_local_local_local_local_local_local_local_local_local_local;\n\n\n\nreturn p;\n\nreturn p;\nreturn p;\n\nreturn p;\n\n\n**return p;\nreturn p;\n\n\nreturn p;\n\n\n\n*\nreturn p;\n* return p;\n* return p;\n\n\n\n* return p;\n\n\n\n * return p;\n * return p;\n * return p;\n\n\n\n * return p;\n* return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p;\n * return p;\n * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p;\n * return p; * return p; * return p; * return p; * return p; * return p; * return p;\n * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p;\n * return p; * return p; * return p; * return p;\n* return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p;\n * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p;\n * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p;\n * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p;\n * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p;\n * return p; * return p; * return p; * return p; * return p; * return p; * return p; * return p;\n * return p; * return p; * return p; * return p; * return p; * return p; * return p;\n * return p; return p;\n * return p;\n * return p;\n * return p; * return p;\n * return p; * return p; * return p; * return p;\n * return p;\n * return p;\n * return p;\n * return p;\n * return p;\n * return p;\n * return p; * return p; * return p; * return p; * return p;\n * return p; * return p; * return p; * return p;\n * return p;\n * return p; * return p; * return p; * return p; * return p;\n * return p;\n * return p; * return p; * return p;\n * return p;\n * return p; * return p; * return p; * return p; * return p; * return p;\n * return p; * return p; * return p; * return p;\n * return p;\n * return p;\n * return p; * return p; * return p; * return p; * return p;\n * return p; * return p; * return p; * return p;\n * return p; * return p; * return p;\n * return p;\n * return p; * return p; * return p; * return p;\n* return p; * return p; * return p; * return p; * return p;\n * return p; * return p; * return p; * return p; * return p; *\n * return p; * return p; * return p; * return p; *\n* return p; * return p; * return p;\n* return p; * return p; * return p; *\n * return p; * return p; * return p; *\n* return p; * return p; * return p; * return p;\nreturn p;\n * return p; * return p; * return p; return\n * return p;\n * return p;\n * return p;\n * return p;\n * return p; * return p;"
        },
        "llm_ast": {
          "motivation": "Both candidates introduce excessive nesting and goto statements, violating the criteria of structural similarity and simplicity. However, Candidate A more closely resembles the Source's nesting structure, especially in the main `if-else` block and the nested `if` statements within the `while` loops.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                \n                \n              case :\n                call(, , )\n                \n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                \n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8515625,
          "base_ppl": 1.875,
          "pr_ppl": 1.8671875,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.28125,
          "pr_ast_ppl": 2.265625,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B produces more readable code by avoiding goto statements and using clear variable names, making it more understandable.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "While both candidates struggle to accurately represent the nested structure and loop types, Candidate A has a more accurate representation of the nested `if` statements and `while` loops compared to Candidate B.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                \n                \n              case :\n                call(, , )\n                \n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                \n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8515625,
          "base_ppl": 1.8828125,
          "pr_ppl": 1.8828125,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.28125,
          "pr_ast_ppl": 2.265625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B produces more readable code by using meaningful variable names and avoiding unnecessary loops, making it easier to understand the parsing logic.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "While both candidates introduce significant restructuring with nested `do...while` loops, Candidate A maintains the overall nesting structure of the Source more closely, particularly around the `if` statements and `switch` statement.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-libxls_xls_isRecordTooSmall-O2.so",
        "function": "xls_isRecordTooSmall",
        "source_code": "int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1, const BYTE* buf) {\n    switch (bof1->id) {\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            return (bof1->size < 2 * sizeof(WORD));\n        case XLS_RECORD_CODEPAGE:\n            return (bof1->size < sizeof(WORD));\n\t\tcase XLS_RECORD_WINDOW1:\n            return (bof1->size < sizeof(WIND1));\n        case XLS_RECORD_SST:\n            return (bof1->size < offsetof(SST, strings));\n        case XLS_RECORD_BOUNDSHEET:\n            return (bof1->size < offsetof(BOUNDSHEET, name));\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n                return (bof1->size < sizeof(XF5));\n            }\n            return (bof1->size < sizeof(XF8));\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n            return (bof1->size < offsetof(FONT, name));\n        case XLS_RECORD_FORMAT:\n            return (bof1->size < offsetof(FORMAT, value));\n        case XLS_RECORD_STYLE:\n            {\n                struct {\n                    unsigned short idx;\n                    unsigned char ident;\n                    unsigned char lvl;\n                } *styl;\n                if(bof1->size < 2) {\n                    return 1;\n                }\n                styl = (void *)buf;\n                if(xlsShortVal(styl->idx) & 0x8000) {\n                    return bof1->size < 4;\n                } else {\n                    if(bof1->size < 3) return 1;\n                    return bof1->size < 3 + styl->ident;\n                }\n            }\n\t\tcase XLS_RECORD_1904:\n            return (bof1->size < sizeof(BYTE));\n        default:\n            break;\n    }\n    return 0;\n}\n",
        "function_base": "\nbool xls_isRecordTooSmall(long param_1,ushort *param_2,short *param_3)\n\n{\n  ushort uVar1;\n  short sVar2;\n  bool bVar3;\n  \n  uVar1 = *param_2;\n  if (uVar1 < 0xfc) {\n    bVar3 = false;\n    switch(uVar1) {\n    case 0x22:\n      bVar3 = param_2[1] == 0;\n      break;\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x41:\n      break;\n    case 0x31:\n      goto switchD_00101137_caseD_31;\n    case 0x3d:\n      bVar3 = param_2[1] < 0x12;\n      break;\n    case 0x42:\nswitchD_00101137_caseD_42:\n      bVar3 = param_2[1] < 2;\n      break;\n    default:\n      if (uVar1 == 0x85) {\n        bVar3 = param_2[1] < 6;\n      }\n      else {\n        bVar3 = false;\n        if (uVar1 == 0xe0) {\n          if (*(char *)(param_1 + 0xc) == '\\0') {\n            bVar3 = param_2[1] < 0x18;\n          }\n          else {\n            bVar3 = param_2[1] < 0x10;\n          }\n        }\n      }\n    }\n  }\n  else {\n    if (0x292 < uVar1) {\n      if (uVar1 == 0x293) {\n        if (param_2[1] < 2) {\n          return true;\n        }\n        sVar2 = xlsShortVal((int)*param_3);\n        uVar1 = param_2[1];\n        if (sVar2 < 0) {\n          return uVar1 < 4;\n        }\n        if (uVar1 < 3) {\n          return true;\n        }\n        return uVar1 < (ushort)(*(byte *)(param_3 + 1) + 3);\n      }\n      if (uVar1 != 0x41e) {\n        if (uVar1 != 0x809) {\n          return false;\n        }\n        return param_2[1] < 4;\n      }\n      goto switchD_00101137_caseD_42;\n    }\n    if (uVar1 == 0xfc) {\n      return param_2[1] < 8;\n    }\n    if (uVar1 != 0x231) {\n      return false;\n    }\nswitchD_00101137_caseD_31:\n    bVar3 = param_2[1] < 0xe;\n  }\n  return bVar3;\n}\n\n",
        "function_pr": "\nbool xls_isRecordTooSmall(long param_1,ushort *param_2,short *param_3)\n\n{\n  ushort uVar1;\n  short sVar2;\n  bool bVar3;\n  \n  uVar1 = *param_2;\n  if (uVar1 < 0xfc) {\n    bVar3 = false;\n    switch(uVar1) {\n    case 0x22:\n      bVar3 = param_2[1] == 0;\n      break;\n    default:\n      if (uVar1 == 0x85) {\n        bVar3 = param_2[1] < 6;\n      }\n      else {\n        bVar3 = false;\n        if (uVar1 == 0xe0) {\n          if (*(char *)(param_1 + 0xc) == '\\0') {\n            bVar3 = param_2[1] < 0x18;\n          }\n          else {\n            bVar3 = param_2[1] < 0x10;\n          }\n        }\n      }\n      break;\n    case 0x31:\n      goto switchD_00101137_caseD_31;\n    case 0x42:\nswitchD_00101137_caseD_42:\n      bVar3 = param_2[1] < 2;\n      break;\n    case 0x3d:\n      bVar3 = param_2[1] < 0x12;\n      break;\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x41:\n      break;\n    }\n  }\n  else {\n    if (0x292 < uVar1) {\n      if (uVar1 == 0x293) {\n        if (param_2[1] < 2) {\n          return true;\n        }\n        sVar2 = xlsShortVal((int)*param_3);\n        uVar1 = param_2[1];\n        if (sVar2 < 0) {\n          return uVar1 < 4;\n        }\n        if (uVar1 < 3) {\n          return true;\n        }\n        return uVar1 < (ushort)(*(byte *)(param_3 + 1) + 3);\n      }\n      if (uVar1 != 0x41e) {\n        if (uVar1 != 0x809) {\n          return false;\n        }\n        return param_2[1] < 4;\n      }\n      goto switchD_00101137_caseD_42;\n    }\n    if (uVar1 == 0xfc) {\n      return param_2[1] < 8;\n    }\n    if (uVar1 != 0x231) {\n      return false;\n    }\nswitchD_00101137_caseD_31:\n    bVar3 = param_2[1] < 0xe;\n  }\n  return bVar3;\n}\n\n",
        "source_ast": "{\n  switch(){\n    case :\n      \n      return\n    case :\n      return\n    case :\n      return\n    case :\n      return\n    case :\n      return\n    case :\n      if(){\n        return\n      }\n      return\n    case :\n    case :\n      return\n    case :\n      return\n    case :\n      {\n        \n        if(){\n          return\n        }\n        \n        if(call()){\n          return\n        }else{\n          if()return\n          return\n        }\n      }\n    case :\n      return\n    case :\n      \n      \n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  if(){\n    \n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        goto label\n      case :\n        \n        \n      case :\n        \n        \n      case :\n        \n        if(){\n          \n        }else{\n          \n          if(){\n            if(){\n              \n            }else{\n              \n            }\n          }\n        }\n    }\n  }else{\n    if(){\n      if(){\n        if(){\n          return\n        }\n        call()\n        \n        if(){\n          return\n        }\n        if(){\n          return\n        }\n        returncall()\n      }\n      if(){\n        if(){\n          return\n        }\n        return\n      }\n      goto label\n    }\n    if(){\n      return\n    }\n    if(){\n      return\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  if(){\n    \n    switch(){\n      case :\n        \n        \n      case :\n        \n        if(){\n          \n        }else{\n          \n          if(){\n            if(){\n              \n            }else{\n              \n            }\n          }\n        }\n        \n      case :\n        goto label\n      case :\n        \n        \n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n    }\n  }else{\n    if(){\n      if(){\n        if(){\n          return\n        }\n        call()\n        \n        if(){\n          return\n        }\n        if(){\n          return\n        }\n        returncall()\n      }\n      if(){\n        if(){\n          return\n        }\n        return\n      }\n      goto label\n    }\n    if(){\n      return\n    }\n    if(){\n      return\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.203125,
          "base_ppl": 1.8515625,
          "pr_ppl": 1.875,
          "source_ast_ppl": 3.515625,
          "base_ast_ppl": 2.28125,
          "pr_ast_ppl": 2.265625,
          "delta_ppl": 0.0234375
        },
        "llm_qualitative": {
          "motivation": "Candidate B, while containing some type inaccuracies, presents a more idiomatic C structure with clear `switch` statements and structured logic, making it more readable.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates introduce unnecessary `goto` and `Label` constructs, but Candidate A maintains a more structurally similar nesting depth to the Source.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-libxls_xls_isRecordTooSmall-O3.so",
        "function": "xls_isRecordTooSmall",
        "source_code": "int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1, const BYTE* buf) {\n    switch (bof1->id) {\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            return (bof1->size < 2 * sizeof(WORD));\n        case XLS_RECORD_CODEPAGE:\n            return (bof1->size < sizeof(WORD));\n\t\tcase XLS_RECORD_WINDOW1:\n            return (bof1->size < sizeof(WIND1));\n        case XLS_RECORD_SST:\n            return (bof1->size < offsetof(SST, strings));\n        case XLS_RECORD_BOUNDSHEET:\n            return (bof1->size < offsetof(BOUNDSHEET, name));\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n                return (bof1->size < sizeof(XF5));\n            }\n            return (bof1->size < sizeof(XF8));\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n            return (bof1->size < offsetof(FONT, name));\n        case XLS_RECORD_FORMAT:\n            return (bof1->size < offsetof(FORMAT, value));\n        case XLS_RECORD_STYLE:\n            {\n                struct {\n                    unsigned short idx;\n                    unsigned char ident;\n                    unsigned char lvl;\n                } *styl;\n                if(bof1->size < 2) {\n                    return 1;\n                }\n                styl = (void *)buf;\n                if(xlsShortVal(styl->idx) & 0x8000) {\n                    return bof1->size < 4;\n                } else {\n                    if(bof1->size < 3) return 1;\n                    return bof1->size < 3 + styl->ident;\n                }\n            }\n\t\tcase XLS_RECORD_1904:\n            return (bof1->size < sizeof(BYTE));\n        default:\n            break;\n    }\n    return 0;\n}\n",
        "function_base": "\nbool xls_isRecordTooSmall(long param_1,ushort *param_2,short *param_3)\n\n{\n  ushort uVar1;\n  short sVar2;\n  bool bVar3;\n  \n  uVar1 = *param_2;\n  if (uVar1 < 0xfc) {\n    bVar3 = false;\n    switch(uVar1) {\n    case 0x22:\n      bVar3 = param_2[1] == 0;\n      break;\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x41:\n      break;\n    case 0x31:\n      goto switchD_00101137_caseD_31;\n    case 0x3d:\n      bVar3 = param_2[1] < 0x12;\n      break;\n    case 0x42:\nswitchD_00101137_caseD_42:\n      bVar3 = param_2[1] < 2;\n      break;\n    default:\n      if (uVar1 == 0x85) {\n        bVar3 = param_2[1] < 6;\n      }\n      else {\n        bVar3 = false;\n        if (uVar1 == 0xe0) {\n          if (*(char *)(param_1 + 0xc) == '\\0') {\n            bVar3 = param_2[1] < 0x18;\n          }\n          else {\n            bVar3 = param_2[1] < 0x10;\n          }\n        }\n      }\n    }\n  }\n  else {\n    if (0x292 < uVar1) {\n      if (uVar1 == 0x293) {\n        if (param_2[1] < 2) {\n          return true;\n        }\n        sVar2 = xlsShortVal((int)*param_3);\n        uVar1 = param_2[1];\n        if (sVar2 < 0) {\n          return uVar1 < 4;\n        }\n        if (uVar1 < 3) {\n          return true;\n        }\n        return uVar1 < (ushort)(*(byte *)(param_3 + 1) + 3);\n      }\n      if (uVar1 != 0x41e) {\n        if (uVar1 != 0x809) {\n          return false;\n        }\n        return param_2[1] < 4;\n      }\n      goto switchD_00101137_caseD_42;\n    }\n    if (uVar1 == 0xfc) {\n      return param_2[1] < 8;\n    }\n    if (uVar1 != 0x231) {\n      return false;\n    }\nswitchD_00101137_caseD_31:\n    bVar3 = param_2[1] < 0xe;\n  }\n  return bVar3;\n}\n\n",
        "function_pr": "\nbool xls_isRecordTooSmall(long param_1,ushort *param_2,short *param_3)\n\n{\n  ushort uVar1;\n  short sVar2;\n  bool bVar3;\n  \n  uVar1 = *param_2;\n  if (uVar1 < 0xfc) {\n    bVar3 = false;\n    switch(uVar1) {\n    case 0x22:\n      bVar3 = param_2[1] == 0;\n      break;\n    default:\n      if (uVar1 == 0x85) {\n        bVar3 = param_2[1] < 6;\n      }\n      else {\n        bVar3 = false;\n        if (uVar1 == 0xe0) {\n          if (*(char *)(param_1 + 0xc) == '\\0') {\n            bVar3 = param_2[1] < 0x18;\n          }\n          else {\n            bVar3 = param_2[1] < 0x10;\n          }\n        }\n      }\n      break;\n    case 0x31:\n      goto switchD_00101137_caseD_31;\n    case 0x42:\nswitchD_00101137_caseD_42:\n      bVar3 = param_2[1] < 2;\n      break;\n    case 0x3d:\n      bVar3 = param_2[1] < 0x12;\n      break;\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x41:\n      break;\n    }\n  }\n  else {\n    if (0x292 < uVar1) {\n      if (uVar1 == 0x293) {\n        if (param_2[1] < 2) {\n          return true;\n        }\n        sVar2 = xlsShortVal((int)*param_3);\n        uVar1 = param_2[1];\n        if (sVar2 < 0) {\n          return uVar1 < 4;\n        }\n        if (uVar1 < 3) {\n          return true;\n        }\n        return uVar1 < (ushort)(*(byte *)(param_3 + 1) + 3);\n      }\n      if (uVar1 != 0x41e) {\n        if (uVar1 != 0x809) {\n          return false;\n        }\n        return param_2[1] < 4;\n      }\n      goto switchD_00101137_caseD_42;\n    }\n    if (uVar1 == 0xfc) {\n      return param_2[1] < 8;\n    }\n    if (uVar1 != 0x231) {\n      return false;\n    }\nswitchD_00101137_caseD_31:\n    bVar3 = param_2[1] < 0xe;\n  }\n  return bVar3;\n}\n\n",
        "source_ast": "{\n  switch(){\n    case :\n      \n      return\n    case :\n      return\n    case :\n      return\n    case :\n      return\n    case :\n      return\n    case :\n      if(){\n        return\n      }\n      return\n    case :\n    case :\n      return\n    case :\n      return\n    case :\n      {\n        \n        if(){\n          return\n        }\n        \n        if(call()){\n          return\n        }else{\n          if()return\n          return\n        }\n      }\n    case :\n      return\n    case :\n      \n      \n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  if(){\n    \n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        goto label\n      case :\n        \n        \n      case :\n        \n        \n      case :\n        \n        if(){\n          \n        }else{\n          \n          if(){\n            if(){\n              \n            }else{\n              \n            }\n          }\n        }\n    }\n  }else{\n    if(){\n      if(){\n        if(){\n          return\n        }\n        call()\n        \n        if(){\n          return\n        }\n        if(){\n          return\n        }\n        returncall()\n      }\n      if(){\n        if(){\n          return\n        }\n        return\n      }\n      goto label\n    }\n    if(){\n      return\n    }\n    if(){\n      return\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  if(){\n    \n    switch(){\n      case :\n        \n        \n      case :\n        \n        if(){\n          \n        }else{\n          \n          if(){\n            if(){\n              \n            }else{\n              \n            }\n          }\n        }\n        \n      case :\n        goto label\n      case :\n        \n        \n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n    }\n  }else{\n    if(){\n      if(){\n        if(){\n          return\n        }\n        call()\n        \n        if(){\n          return\n        }\n        if(){\n          return\n        }\n        returncall()\n      }\n      if(){\n        if(){\n          return\n        }\n        return\n      }\n      goto label\n    }\n    if(){\n      return\n    }\n    if(){\n      return\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.203125,
          "base_ppl": 1.8515625,
          "pr_ppl": 1.875,
          "source_ast_ppl": 3.515625,
          "base_ast_ppl": 2.28125,
          "pr_ast_ppl": 2.265625,
          "delta_ppl": 0.0234375
        },
        "llm_qualitative": {
          "motivation": "Candidate B is structured with a clear `switch` statement based on record types, making it more idiomatic and readable than Candidate A's rearranged and less logical structure.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates introduce unnecessary `goto` statements and extra nesting compared to the source. However, Candidate A maintains the correct nesting depth of the `if` statements within the `switch` block, while Candidate B incorrectly nests them outside.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 1.734375,
          "pr_ppl": 1.7265625,
          "source_ast_ppl": 2.046875,
          "base_ast_ppl": 1.953125,
          "pr_ast_ppl": 1.953125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B has a more human-readable format",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8515625,
          "base_ppl": 1.71875,
          "pr_ppl": 1.7109375,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more accurate as it doesn't have a goto statement and is a more traditional implementation, avoiding potential issues with the goto statement",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.4921875,
          "base_ppl": 2.25,
          "pr_ppl": 2.359375,
          "source_ast_ppl": 1.6484375,
          "base_ast_ppl": 2.25,
          "pr_ast_ppl": 2.25,
          "delta_ppl": 0.109375
        },
        "llm_qualitative": {
          "motivation": "Candidate B, while more complex, correctly implements the timestamp parsing logic and handles errors gracefully, making it more accurate and robust.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.4921875,
          "base_ppl": 2.25,
          "pr_ppl": 2.359375,
          "source_ast_ppl": 1.6484375,
          "base_ast_ppl": 2.25,
          "pr_ast_ppl": 2.25,
          "delta_ppl": 0.109375
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses clear control flow and structure, resembling common parsing patterns, making it more readable for a human.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            \n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.5703125,
          "base_ppl": 2.171875,
          "pr_ppl": 2.28125,
          "source_ast_ppl": 1.71875,
          "base_ast_ppl": 2.375,
          "pr_ast_ppl": 2.375,
          "delta_ppl": 0.109375
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses clear, readable control flow with loops and conditional statements, making it easier to understand the date parsing logic.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates introduce unnecessary nesting and `goto` statements, but Candidate A maintains the original nesting structure of the Source more closely.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            \n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.5703125,
          "base_ppl": 2.171875,
          "pr_ppl": 2.28125,
          "source_ast_ppl": 1.71875,
          "base_ast_ppl": 2.375,
          "pr_ast_ppl": 2.375,
          "delta_ppl": 0.109375
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a more structured, readable approach with clear variable names and logical flow, making it easier to understand the date parsing logic.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_zsav_read_compressed_data-O0.so",
        "function": "zsav_read_compressed_data",
        "source_code": "readstat_error_t zsav_read_compressed_data(sav_ctx_t *ctx,\n        readstat_error_t (*row_handler)(unsigned char *, size_t, sav_ctx_t *)) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = ctx->io;\n    readstat_off_t data_offset = 0;\n\n    size_t uncompressed_row_len = ctx->var_offset * 8;\n    readstat_off_t uncompressed_offset = 0;\n    unsigned char *uncompressed_row = NULL;\n\n    uLongf uncompressed_block_len = 0;\n    unsigned char *compressed_block = NULL, *uncompressed_block = NULL;\n\n    struct sav_row_stream_s state = { \n        .missing_value = ctx->missing_double,\n        .bias = ctx->bias,\n        .bswap = ctx->bswap };\n\n    struct zheader zheader;\n    struct ztrailer ztrailer;\n    struct ztrailer_entry *ztrailer_entries = NULL;\n\n    int n_blocks = 0;\n    int block_i = 0;\n    int i;\n\n    if (io->read(&zheader, sizeof(struct zheader), io->io_ctx) < sizeof(struct zheader)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    zheader.zheader_ofs = ctx->bswap ? byteswap8(zheader.zheader_ofs) : zheader.zheader_ofs;\n    zheader.ztrailer_ofs = ctx->bswap ? byteswap8(zheader.ztrailer_ofs) : zheader.ztrailer_ofs;\n    zheader.ztrailer_len = ctx->bswap ? byteswap8(zheader.ztrailer_len) : zheader.ztrailer_len;\n\n    if (zheader.zheader_ofs != io->seek(0, READSTAT_SEEK_CUR, io->io_ctx) - sizeof(struct zheader)) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    n_blocks = (zheader.ztrailer_len - 24) / 24;\n\n    if (io->seek(zheader.ztrailer_ofs, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->read(&ztrailer, sizeof(struct ztrailer), io->io_ctx) < sizeof(struct ztrailer)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ztrailer.bias = ctx->bswap ? byteswap8(ztrailer.bias) : ztrailer.bias;\n    ztrailer.zero = ctx->bswap ? byteswap8(ztrailer.zero) : ztrailer.zero;\n    ztrailer.block_size = ctx->bswap ? byteswap4(ztrailer.block_size) : ztrailer.block_size;\n    ztrailer.n_blocks = ctx->bswap ? byteswap4(ztrailer.n_blocks) : ztrailer.n_blocks;\n\n    if (n_blocks != ztrailer.n_blocks) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    if (n_blocks && (ztrailer_entries = readstat_malloc(n_blocks * sizeof(struct ztrailer_entry))) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (io->read(ztrailer_entries, n_blocks * sizeof(struct ztrailer_entry), io->io_ctx) < \n            n_blocks * sizeof(struct ztrailer_entry)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    for (i=0; i<n_blocks; i++) {\n        struct ztrailer_entry *entry = &ztrailer_entries[i];\n\n        entry->uncompressed_ofs = ctx->bswap ? byteswap8(entry->uncompressed_ofs) : entry->uncompressed_ofs;\n        entry->compressed_ofs = ctx->bswap ? byteswap8(entry->compressed_ofs) : entry->compressed_ofs;\n        entry->uncompressed_size = ctx->bswap ? byteswap4(entry->uncompressed_size) : entry->uncompressed_size;\n        entry->compressed_size = ctx->bswap ? byteswap4(entry->compressed_size) : entry->compressed_size;\n    }\n\n    if (uncompressed_row_len && (uncompressed_row = readstat_malloc(uncompressed_row_len)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    while (1) {\n        if (block_i == n_blocks)\n            goto cleanup;\n\n        struct ztrailer_entry *entry = &ztrailer_entries[block_i];\n        if (io->seek(entry->compressed_ofs, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n            retval = READSTAT_ERROR_SEEK;\n            goto cleanup;\n        }\n        if ((compressed_block = readstat_realloc(compressed_block, entry->compressed_size)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if (io->read(compressed_block, entry->compressed_size, io->io_ctx) != entry->compressed_size) {\n            retval = READSTAT_ERROR_READ;\n            goto cleanup;\n        }\n\n        uncompressed_block_len = entry->uncompressed_size;\n        if ((uncompressed_block = readstat_realloc(uncompressed_block, uncompressed_block_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        int status = uncompress(uncompressed_block, &uncompressed_block_len,\n                compressed_block, entry->compressed_size);\n        if (status != Z_OK || uncompressed_block_len != entry->uncompressed_size) {\n            retval = READSTAT_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        block_i++;\n        state.status = SAV_ROW_STREAM_HAVE_DATA;\n        data_offset = 0;\n\n        while (state.status != SAV_ROW_STREAM_NEED_DATA) {\n            state.next_in = &uncompressed_block[data_offset];\n            state.avail_in = uncompressed_block_len - data_offset;\n\n            state.next_out = &uncompressed_row[uncompressed_offset];\n            state.avail_out = uncompressed_row_len - uncompressed_offset;\n\n            sav_decompress_row(&state);\n\n            uncompressed_offset = uncompressed_row_len - state.avail_out;\n            data_offset = uncompressed_block_len - state.avail_in;\n\n            if (state.status == SAV_ROW_STREAM_FINISHED_ROW) {\n                retval = row_handler(uncompressed_row, uncompressed_row_len, ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                uncompressed_offset = 0;\n            }\n\n            if (state.status == SAV_ROW_STREAM_FINISHED_ALL)\n                goto cleanup;\n            if (ctx->row_limit > 0 && ctx->current_row == ctx->row_limit)\n                goto cleanup;\n        }\n    }\n\ncleanup:\n    if (uncompressed_row)\n        free(uncompressed_row);\n    if (ztrailer_entries)\n        free(ztrailer_entries);\n    if (compressed_block)\n        free(compressed_block);\n    if (uncompressed_block)\n        free(uncompressed_block);\n\n    return retval;\n}\n",
        "function_base": "\nint zsav_read_compressed_data(long param_1,code *param_2)\n\n{\n  undefined1 auVar1 [16];\n  int iVar2;\n  int iVar3;\n  ulong uVar4;\n  long lVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined4 local_158;\n  undefined4 local_154;\n  undefined8 local_150;\n  undefined8 local_148;\n  int local_140;\n  undefined4 local_13c;\n  undefined8 local_138;\n  undefined8 local_130;\n  long local_120;\n  undefined8 local_118;\n  long local_110;\n  int local_ec;\n  int local_e8;\n  void *local_e0;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined4 local_c8;\n  int local_c4;\n  long local_c0;\n  undefined8 local_b8;\n  long local_b0;\n  long local_a8;\n  long local_a0;\n  long local_98;\n  long local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined1 auStack_78 [8];\n  undefined4 local_70;\n  uint local_6c;\n  int local_68;\n  void *local_60;\n  void *local_58;\n  long local_50;\n  void *local_48;\n  long local_40;\n  long local_38;\n  long local_30;\n  long local_28;\n  int local_1c;\n  code *local_18;\n  long local_10;\n  \n  local_1c = 0;\n  local_28 = *(long *)(param_1 + 0x48);\n  local_30 = 0;\n  local_38 = (long)(*(int *)(param_1 + 0x1ac) << 3);\n  local_40 = 0;\n  local_48 = (void *)0x0;\n  local_50 = 0;\n  local_58 = (void *)0x0;\n  local_60 = (void *)0x0;\n  local_a8 = 0;\n  local_a0 = 0;\n  local_98 = 0;\n  local_90 = 0;\n  local_88 = *(undefined8 *)(param_1 + 0x1f0);\n  local_80 = *(undefined8 *)(param_1 + 0x218);\n  local_18 = param_2;\n  local_10 = param_1;\n  memset(auStack_78,0,8);\n  local_70 = 0;\n  local_6c = (uint)(*(byte *)(local_10 + 0x22c) & 1);\n  local_68 = 0;\n  local_e0 = (void *)0x0;\n  local_e8 = 0;\n  uVar4 = (**(code **)(local_28 + 0x18))(&local_c0,0x18,*(undefined8 *)(local_28 + 0x28));\n  if (uVar4 < 0x18) {\n    local_1c = 2;\n  }\n  else {\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_110 = local_c0;\n    }\n    else {\n      local_110 = byteswap8(local_c0);\n    }\n    local_c0 = local_110;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_118 = local_b8;\n    }\n    else {\n      local_118 = byteswap8(local_b8);\n    }\n    local_b8 = local_118;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_120 = local_b0;\n    }\n    else {\n      local_120 = byteswap8(local_b0);\n    }\n    lVar6 = local_c0;\n    local_b0 = local_120;\n    lVar5 = (**(code **)(local_28 + 0x10))(0,1,*(undefined8 *)(local_28 + 0x28));\n    if (lVar6 == lVar5 + -0x18) {\n      auVar1._8_8_ = 0;\n      auVar1._0_8_ = local_b0 - 0x18;\n      iVar2 = SUB164(auVar1 / ZEXT816(0x18),0);\n      lVar6 = (**(code **)(local_28 + 0x10))(local_b8,0,*(undefined8 *)(local_28 + 0x28));\n      if (lVar6 == -1) {\n        local_1c = 0xf;\n      }\n      else {\n        uVar4 = (**(code **)(local_28 + 0x18))(&local_d8,0x18,*(undefined8 *)(local_28 + 0x28));\n        if (uVar4 < 0x18) {\n          local_1c = 2;\n        }\n        else {\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_130 = local_d8;\n          }\n          else {\n            local_130 = byteswap8(local_d8);\n          }\n          local_d8 = local_130;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_138 = local_d0;\n          }\n          else {\n            local_138 = byteswap8(local_d0);\n          }\n          local_d0 = local_138;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_13c = local_c8;\n          }\n          else {\n            local_13c = byteswap4(local_c8);\n          }\n          local_c8 = local_13c;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_140 = local_c4;\n          }\n          else {\n            local_140 = byteswap4(local_c4);\n          }\n          local_c4 = local_140;\n          if (iVar2 == local_140) {\n            if ((iVar2 == 0) ||\n               (local_e0 = (void *)readstat_malloc((long)iVar2 * 0x18), local_e0 != (void *)0x0)) {\n              uVar4 = (**(code **)(local_28 + 0x18))\n                                (local_e0,(long)iVar2 * 0x18,*(undefined8 *)(local_28 + 0x28));\n              if (uVar4 < (ulong)((long)iVar2 * 0x18)) {\n                local_1c = 2;\n              }\n              else {\n                for (local_ec = 0; local_ec < iVar2; local_ec = local_ec + 1) {\n                  puVar7 = (undefined8 *)((long)local_e0 + (long)local_ec * 0x18);\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_148 = *puVar7;\n                  }\n                  else {\n                    local_148 = byteswap8(*puVar7);\n                  }\n                  *puVar7 = local_148;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_150 = puVar7[1];\n                  }\n                  else {\n                    local_150 = byteswap8(puVar7[1]);\n                  }\n                  puVar7[1] = local_150;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_154 = *(undefined4 *)(puVar7 + 2);\n                  }\n                  else {\n                    local_154 = byteswap4(*(undefined4 *)(puVar7 + 2));\n                  }\n                  *(undefined4 *)(puVar7 + 2) = local_154;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_158 = *(undefined4 *)((long)puVar7 + 0x14);\n                  }\n                  else {\n                    local_158 = byteswap4(*(undefined4 *)((long)puVar7 + 0x14));\n                  }\n                  *(undefined4 *)((long)puVar7 + 0x14) = local_158;\n                }\n                if ((local_38 == 0) ||\n                   (local_48 = (void *)readstat_malloc(local_38), local_48 != (void *)0x0)) {\n                  while (local_e8 != iVar2) {\n                    lVar6 = (**(code **)(local_28 + 0x10))\n                                      (*(undefined8 *)((long)local_e0 + (long)local_e8 * 0x18 + 8),0\n                                       ,*(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 == -1) {\n                      local_1c = 0xf;\n                      break;\n                    }\n                    local_58 = (void *)readstat_realloc(local_58,(long)*(int *)((long)local_e0 +\n                                                                               (long)local_e8 * 0x18\n                                                                               + 0x14));\n                    if (local_58 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    lVar6 = (**(code **)(local_28 + 0x18))\n                                      (local_58,(long)*(int *)((long)local_e0 +\n                                                              (long)local_e8 * 0x18 + 0x14),\n                                       *(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)) {\n                      local_1c = 2;\n                      break;\n                    }\n                    local_50 = (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10);\n                    local_60 = (void *)readstat_realloc(local_60,local_50);\n                    if (local_60 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    iVar3 = uncompress(local_60,&local_50,local_58,\n                                       (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)\n                                      );\n                    if ((iVar3 != 0) ||\n                       (local_50 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10))) {\n                      local_1c = 5;\n                      break;\n                    }\n                    local_e8 = local_e8 + 1;\n                    local_68 = 1;\n                    local_30 = 0;\n                    while (local_68 != 0) {\n                      local_a8 = (long)local_60 + local_30;\n                      local_a0 = local_50 - local_30;\n                      local_98 = (long)local_48 + local_40;\n                      local_90 = local_38 - local_40;\n                      sav_decompress_row(&local_a8);\n                      local_40 = local_38 - local_90;\n                      local_30 = local_50 - local_a0;\n                      if (local_68 == 2) {\n                        local_1c = (*local_18)(local_48,local_38,local_10);\n                        if (local_1c != 0) goto LAB_00101a68;\n                        local_40 = 0;\n                      }\n                      if ((local_68 == 3) ||\n                         ((0 < *(int *)(local_10 + 0x1b8) &&\n                          (*(int *)(local_10 + 0x1c0) == *(int *)(local_10 + 0x1b8)))))\n                      goto LAB_00101a68;\n                    }\n                  }\n                }\n                else {\n                  local_1c = 3;\n                }\n              }\n            }\n            else {\n              local_1c = 3;\n            }\n          }\n          else {\n            local_1c = 5;\n          }\n        }\n      }\n    }\n    else {\n      local_1c = 5;\n    }\n  }\nLAB_00101a68:\n  if (local_48 != (void *)0x0) {\n    free(local_48);\n  }\n  if (local_e0 != (void *)0x0) {\n    free(local_e0);\n  }\n  if (local_58 != (void *)0x0) {\n    free(local_58);\n  }\n  if (local_60 != (void *)0x0) {\n    free(local_60);\n  }\n  return local_1c;\n}\n\n",
        "function_pr": "\nint zsav_read_compressed_data(long param_1,code *param_2)\n\n{\n  undefined auVar1 [16];\n  int iVar2;\n  int iVar3;\n  ulong uVar4;\n  long lVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined4 local_158;\n  undefined4 local_154;\n  undefined8 local_150;\n  undefined8 local_148;\n  int local_140;\n  undefined4 local_13c;\n  undefined8 local_138;\n  undefined8 local_130;\n  long local_120;\n  undefined8 local_118;\n  long local_110;\n  int local_ec;\n  int local_e8;\n  void *local_e0;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined4 local_c8;\n  int local_c4;\n  long local_c0;\n  undefined8 local_b8;\n  long local_b0;\n  long local_a8;\n  long local_a0;\n  long local_98;\n  long local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined auStack_78 [8];\n  undefined4 local_70;\n  uint local_6c;\n  int local_68;\n  void *local_60;\n  void *local_58;\n  long local_50;\n  void *local_48;\n  long local_40;\n  long local_38;\n  long local_30;\n  long local_28;\n  int local_1c;\n  code *local_18;\n  long local_10;\n  \n  local_1c = 0;\n  local_28 = *(long *)(param_1 + 0x48);\n  local_30 = 0;\n  local_38 = (long)(*(int *)(param_1 + 0x1ac) << 3);\n  local_40 = 0;\n  local_48 = (void *)0x0;\n  local_50 = 0;\n  local_58 = (void *)0x0;\n  local_60 = (void *)0x0;\n  local_a8 = 0;\n  local_a0 = 0;\n  local_98 = 0;\n  local_90 = 0;\n  local_88 = *(undefined8 *)(param_1 + 0x1f0);\n  local_80 = *(undefined8 *)(param_1 + 0x218);\n  local_18 = param_2;\n  local_10 = param_1;\n  memset(auStack_78,0,8);\n  local_70 = 0;\n  local_6c = (uint)(*(byte *)(local_10 + 0x22c) & 1);\n  local_68 = 0;\n  local_e0 = (void *)0x0;\n  local_e8 = 0;\n  uVar4 = (**(code **)(local_28 + 0x18))(&local_c0,0x18,*(undefined8 *)(local_28 + 0x28));\n  if (uVar4 < 0x18) {\n    local_1c = 2;\n  }\n  else {\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_110 = local_c0;\n    }\n    else {\n      local_110 = byteswap8(local_c0);\n    }\n    local_c0 = local_110;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_118 = local_b8;\n    }\n    else {\n      local_118 = byteswap8(local_b8);\n    }\n    local_b8 = local_118;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_120 = local_b0;\n    }\n    else {\n      local_120 = byteswap8(local_b0);\n    }\n    lVar6 = local_c0;\n    local_b0 = local_120;\n    lVar5 = (**(code **)(local_28 + 0x10))(0,1,*(undefined8 *)(local_28 + 0x28));\n    if (lVar6 == lVar5 + -0x18) {\n      auVar1._8_8_ = 0;\n      auVar1._0_8_ = local_b0 - 0x18;\n      iVar2 = SUB164(auVar1 / ZEXT816(0x18),0);\n      lVar6 = (**(code **)(local_28 + 0x10))(local_b8,0,*(undefined8 *)(local_28 + 0x28));\n      if (lVar6 == -1) {\n        local_1c = 0xf;\n      }\n      else {\n        uVar4 = (**(code **)(local_28 + 0x18))(&local_d8,0x18,*(undefined8 *)(local_28 + 0x28));\n        if (uVar4 < 0x18) {\n          local_1c = 2;\n        }\n        else {\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_130 = local_d8;\n          }\n          else {\n            local_130 = byteswap8(local_d8);\n          }\n          local_d8 = local_130;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_138 = local_d0;\n          }\n          else {\n            local_138 = byteswap8(local_d0);\n          }\n          local_d0 = local_138;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_13c = local_c8;\n          }\n          else {\n            local_13c = byteswap4(local_c8);\n          }\n          local_c8 = local_13c;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_140 = local_c4;\n          }\n          else {\n            local_140 = byteswap4(local_c4);\n          }\n          local_c4 = local_140;\n          if (iVar2 == local_140) {\n            if ((iVar2 == 0) ||\n               (local_e0 = (void *)readstat_malloc((long)iVar2 * 0x18), local_e0 != (void *)0x0)) {\n              uVar4 = (**(code **)(local_28 + 0x18))\n                                (local_e0,(long)iVar2 * 0x18,*(undefined8 *)(local_28 + 0x28));\n              if (uVar4 < (ulong)((long)iVar2 * 0x18)) {\n                local_1c = 2;\n              }\n              else {\n                for (local_ec = 0; local_ec < iVar2; local_ec = local_ec + 1) {\n                  puVar7 = (undefined8 *)((long)local_e0 + (long)local_ec * 0x18);\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_148 = *puVar7;\n                  }\n                  else {\n                    local_148 = byteswap8(*puVar7);\n                  }\n                  *puVar7 = local_148;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_150 = puVar7[1];\n                  }\n                  else {\n                    local_150 = byteswap8(puVar7[1]);\n                  }\n                  puVar7[1] = local_150;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_154 = *(undefined4 *)(puVar7 + 2);\n                  }\n                  else {\n                    local_154 = byteswap4(*(undefined4 *)(puVar7 + 2));\n                  }\n                  *(undefined4 *)(puVar7 + 2) = local_154;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_158 = *(undefined4 *)((long)puVar7 + 0x14);\n                  }\n                  else {\n                    local_158 = byteswap4(*(undefined4 *)((long)puVar7 + 0x14));\n                  }\n                  *(undefined4 *)((long)puVar7 + 0x14) = local_158;\n                }\n                if ((local_38 == 0) ||\n                   (local_48 = (void *)readstat_malloc(local_38), local_48 != (void *)0x0)) {\n                  while (local_e8 != iVar2) {\n                    lVar6 = (**(code **)(local_28 + 0x10))\n                                      (*(undefined8 *)((long)local_e0 + (long)local_e8 * 0x18 + 8),0\n                                       ,*(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 == -1) {\n                      local_1c = 0xf;\n                      break;\n                    }\n                    local_58 = (void *)readstat_realloc(local_58,(long)*(int *)((long)local_e0 +\n                                                                               (long)local_e8 * 0x18\n                                                                               + 0x14));\n                    if (local_58 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    lVar6 = (**(code **)(local_28 + 0x18))\n                                      (local_58,(long)*(int *)((long)local_e0 +\n                                                              (long)local_e8 * 0x18 + 0x14),\n                                       *(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)) {\n                      local_1c = 2;\n                      break;\n                    }\n                    local_50 = (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10);\n                    local_60 = (void *)readstat_realloc(local_60,local_50);\n                    if (local_60 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    iVar3 = uncompress(local_60,&local_50,local_58,\n                                       (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)\n                                      );\n                    if ((iVar3 != 0) ||\n                       (local_50 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10))) {\n                      local_1c = 5;\n                      break;\n                    }\n                    local_e8 = local_e8 + 1;\n                    local_68 = 1;\n                    local_30 = 0;\n                    while (local_68 != 0) {\n                      local_a8 = (long)local_60 + local_30;\n                      local_a0 = local_50 - local_30;\n                      local_98 = (long)local_48 + local_40;\n                      local_90 = local_38 - local_40;\n                      sav_decompress_row(&local_a8);\n                      local_40 = local_38 - local_90;\n                      local_30 = local_50 - local_a0;\n                      if (local_68 == 2) {\n                        local_1c = (*local_18)(local_48,local_38,local_10);\n                        if (local_1c != 0) goto LAB_00101a68;\n                        local_40 = 0;\n                      }\n                      if ((local_68 == 3) ||\n                         ((0 < *(int *)(local_10 + 0x1b8) &&\n                          (*(int *)(local_10 + 0x1c0) == *(int *)(local_10 + 0x1b8)))))\n                      goto LAB_00101a68;\n                    }\n                  }\n                }\n                else {\n                  local_1c = 3;\n                }\n              }\n            }\n            else {\n              local_1c = 3;\n            }\n          }\n          else {\n            local_1c = 5;\n          }\n        }\n      }\n    }\n    else {\n      local_1c = 5;\n    }\n  }\nLAB_00101a68:\n  if (local_48 != (void *)0x0) {\n    free(local_48);\n  }\n  if (local_e0 != (void *)0x0) {\n    free(local_e0);\n  }\n  if (local_58 != (void *)0x0) {\n    free(local_58);\n  }\n  if (local_60 != (void *)0x0) {\n    free(local_60);\n  }\n  return local_1c;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  if(){\n    \n    goto label\n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  for(;;){\n    \n    (? call(): )\n    (? call(): )\n    (? call(): )\n    (? call(): )\n  }\n  if(call()){\n    \n    goto label\n  }\n  while(){\n    if()goto label\n    \n    if(call(, , )){\n      \n      goto label\n    }\n    if(call(, )){\n      \n      goto label\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    \n    if(call(, )){\n      \n      goto label\n    }\n    call(, , , )\n    if(){\n      \n      goto label\n    }\n    \n    \n    \n    while(){\n      \n      \n      \n      \n      call()\n      \n      \n      if(){\n        call(, , )\n        if()goto label\n        \n      }\n      if()goto label\n      if()goto label\n    }\n  }\n  if()call()\n  if()call()\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, , )\n  \n  call()\n  \n  \n  \n  call(, , )\n  if(){\n    \n  }else{\n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    \n    call(, , )\n    if(){\n      \n      \n      call(call(), )\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          \n        }else{\n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            if(call()){\n              call(, , )\n              if(call()){\n                \n              }else{\n                for(;;){\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                }\n                if(call()){\n                  while(){\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    \n                    \n                    while(){\n                      \n                      \n                      \n                      \n                      call()\n                      \n                      \n                      if(){\n                        call(, , )\n                        if()goto label\n                        \n                      }\n                      if()goto label\n                    }\n                  }\n                }else{\n                  \n                }\n              }\n            }else{\n              \n            }\n          }else{\n            \n          }\n        }\n      }\n    }else{\n      \n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, , )\n  \n  call()\n  \n  \n  \n  call(, , )\n  if(){\n    \n  }else{\n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    \n    call(, , )\n    if(){\n      \n      \n      call(call(), )\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          \n        }else{\n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            if(call()){\n              call(, , )\n              if(call()){\n                \n              }else{\n                for(;;){\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                }\n                if(call()){\n                  while(){\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    \n                    \n                    while(){\n                      \n                      \n                      \n                      \n                      call()\n                      \n                      \n                      if(){\n                        call(, , )\n                        if()goto label\n                        \n                      }\n                      if()goto label\n                    }\n                  }\n                }else{\n                  \n                }\n              }\n            }else{\n              \n            }\n          }else{\n            \n          }\n        }\n      }\n    }else{\n      \n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.7578125,
          "base_ppl": 1.5,
          "pr_ppl": 1.4921875,
          "source_ast_ppl": 2.28125,
          "base_ast_ppl": 1.75,
          "pr_ast_ppl": 1.75,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B has better control flow and readability, making the code easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      \n      do{\n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n        }\n        if()goto label\n        \n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.234375,
          "base_ppl": 1.890625,
          "pr_ppl": 1.8671875,
          "source_ast_ppl": 3.953125,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.46875,
          "delta_ppl": -0.0234375
        },
        "llm_qualitative": {
          "motivation": "Candidate B is semantically incorrect but its structure is much more readable and resembles standard C coding practices.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates incorrectly represent the loops, but Candidate A uses a switch statement to approximate the nested structure of the Source's do-while and if-return blocks.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      \n      do{\n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n        }\n        if()goto label\n        \n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.234375,
          "base_ppl": 1.890625,
          "pr_ppl": 1.8671875,
          "source_ast_ppl": 3.953125,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.46875,
          "delta_ppl": -0.0234375
        },
        "llm_qualitative": {
          "motivation": "Candidate B is semantically correct and uses standard control flow (loops) making it much more readable than Candidate A's nested structure and goto statements.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates incorrectly handle the nested loops. However, Candidate A preserves the nesting structure of the Source's `do-while` loop better than Candidate B.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            if(){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            if(){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.5703125,
          "base_ppl": 1.8671875,
          "pr_ppl": 1.8671875,
          "source_ast_ppl": 1.71875,
          "base_ast_ppl": 2.1875,
          "pr_ast_ppl": 2.1875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses more idiomatic C constructs, making it easier for a human to understand the date parsing logic, while Candidate A relies on more complex and less readable code.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.4921875,
          "base_ppl": 1.984375,
          "pr_ppl": 1.9765625,
          "source_ast_ppl": 1.6484375,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B, while more complex, follows a standard state machine pattern for parsing, making it more likely to be accurate and maintainable.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_por-O0.so",
        "function": "readstat_parse_por",
        "source_code": "readstat_error_t readstat_parse_por(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    unsigned char reverse_lookup[256];\n    char vanity[5][40];\n    char error_buf[1024];\n\n    por_ctx_t *ctx = por_ctx_init();\n    \n    ctx->handle = parser->handlers;\n    ctx->user_ctx = user_ctx;\n    ctx->io = io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (parser->output_encoding) {\n        if (strcmp(parser->output_encoding, \"UTF-8\") != 0)\n            ctx->converter = iconv_open(parser->output_encoding, \"UTF-8\");\n\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n    \n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n    \n    if (read_bytes(ctx, vanity, sizeof(vanity)) != sizeof(vanity)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    retval = readstat_convert(ctx->file_label, sizeof(ctx->file_label), vanity[1] + 20, 20, NULL);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if (read_bytes(ctx, reverse_lookup, sizeof(reverse_lookup)) != sizeof(reverse_lookup)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n    \n    ctx->space = reverse_lookup[126];\n\n    int i;\n\n    for (i=0; i<256; i++) {\n        if (por_ascii_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_ascii_lookup[i];\n        } else if (por_unicode_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_unicode_lookup[i];\n        }\n    }\n\n    ctx->byte2unicode[reverse_lookup[64]] = por_unicode_lookup[64];\n\n    unsigned char check[8];\n    char tr_check[8];\n    \n    if (read_bytes(ctx, check, sizeof(check)) != sizeof(check)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ssize_t encoded_len;\n\n    if ((encoded_len = por_utf8_encode(check, sizeof(check), tr_check, sizeof(tr_check), ctx->byte2unicode)) == -1) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error converting check string: %.*s\", (int)sizeof(check), check);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_CONVERT;\n        goto cleanup;\n    }\n\n    if (strncmp(\"SPSSPORT\", tr_check, encoded_len) != 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n    \n    ctx->var_offset = -1;\n    \n    char string[256];\n\n    retval = read_version_and_timestamp(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n\n    while (1) {\n        uint16_t tr_tag = read_tag(ctx);\n        switch (tr_tag) {\n            case '1': /* product ID */\n            case '2': /* author ID */\n            case '3': /* sub-product ID */\n                retval = read_string(ctx, string, sizeof(string));\n                break;\n            case '4': /* variable count */\n                retval = read_variable_count_record(ctx);\n                break;\n            case '5': /* precision */\n                retval = read_precision_record(ctx);\n                break;\n            case '6': /* case weight */\n                retval = read_case_weight_record(ctx);\n                break;\n            case '7': /* variable */\n                retval = read_variable_record(ctx);\n                break;\n            case '8': /* missing value */\n                retval = read_missing_value_record(ctx);\n                break;\n            case 'B': /* missing value range */\n                retval = read_missing_value_range_record(ctx);\n                break;\n            case '9': /* LO THRU x */\n                retval = read_missing_value_lo_range_record(ctx);\n                break;\n            case 'A': /* x THRU HI */\n                retval = read_missing_value_hi_range_record(ctx);\n                break;\n            case 'C': /* variable label */\n                retval = read_variable_label_record(ctx);\n                break;\n            case 'D': /* value label */\n                retval = read_value_label_record(ctx);\n                break;\n            case 'E': /* document record */\n                retval = read_document_record(ctx);\n                break;\n            case 'F': /* file data */\n                if (ctx->var_offset != ctx->var_count - 1) {\n                    retval = READSTAT_ERROR_COLUMN_COUNT_MISMATCH;\n                    goto cleanup;\n                }\n\n                retval = handle_variables(ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                if (ctx->handle.value) {\n                    retval = read_por_file_data(ctx);\n                }\n                goto cleanup;\n            default:\n                retval = READSTAT_ERROR_PARSE;\n                goto cleanup;\n        }\n        if (retval != READSTAT_OK)\n            break;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n    por_ctx_free(ctx);\n    \n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_por(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  iconv_t pvVar3;\n  long lVar4;\n  undefined1 local_738 [264];\n  size_t local_630;\n  char local_624 [8];\n  undefined1 local_61c [8];\n  int local_614;\n  void *local_610;\n  char local_608 [1024];\n  undefined1 local_208 [60];\n  undefined1 auStack_1cc [148];\n  byte local_138 [264];\n  undefined8 *local_30;\n  int local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_24 = 0;\n  local_30 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_610 = (void *)por_ctx_init();\n  memcpy(local_610,local_10,0x40);\n  *(undefined8 *)((long)local_610 + 0x48) = local_20;\n  *(undefined8 **)((long)local_610 + 0x58) = local_30;\n  *(int *)((long)local_610 + 0x2d0) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)local_610 + 0x2d4) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  if (*(long *)((long)local_10 + 0x50) != 0) {\n    iVar2 = strcmp(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n    if (iVar2 != 0) {\n      pvVar3 = iconv_open(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n      *(iconv_t *)((long)local_610 + 0x2a8) = pvVar3;\n    }\n    if (*(long *)((long)local_610 + 0x2a8) == -1) {\n      *(undefined8 *)((long)local_610 + 0x2a8) = 0;\n      local_24 = 7;\n      goto LAB_00101f5b;\n    }\n  }\n  iVar2 = (*(code *)*local_30)(local_18,local_30[5]);\n  if (iVar2 == -1) {\n    local_24 = 1;\n  }\n  else {\n    lVar4 = (*(code *)local_30[2])(0,2,local_30[5]);\n    *(long *)((long)local_610 + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_24 = 0xf;\n    }\n    else {\n      lVar4 = (*(code *)local_30[2])(0,0,local_30[5]);\n      if (lVar4 == -1) {\n        local_24 = 0xf;\n      }\n      else {\n        lVar4 = read_bytes(local_610,local_208,200);\n        if (lVar4 == 200) {\n          local_24 = readstat_convert((long)local_610 + 0x89,0x15,auStack_1cc,0x14,0);\n          if (local_24 == 0) {\n            lVar4 = read_bytes(local_610,local_138,0x100);\n            if (lVar4 == 0x100) {\n              *(byte *)((long)local_610 + 0x60) = local_138[0x7e];\n              for (local_614 = 0; local_614 < 0x100; local_614 = local_614 + 1) {\n                if (PTR_por_ascii_lookup_00105fe8[local_614] == '\\0') {\n                  if (*(short *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2) != 0) {\n                    *(undefined2 *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                         *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2);\n                  }\n                }\n                else {\n                  *(short *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                       (short)(char)PTR_por_ascii_lookup_00105fe8[local_614];\n                }\n              }\n              *(undefined2 *)((long)local_610 + (ulong)local_138[0x40] * 2 + 0x9e) =\n                   *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + 0x80);\n              lVar4 = read_bytes(local_610,local_61c,8);\n              if (lVar4 == 8) {\n                local_630 = por_utf8_encode(local_61c,8,local_624,8,(long)local_610 + 0x9e);\n                if (local_630 == 0xffffffffffffffff) {\n                  if (*(long *)((long)local_610 + 0x30) != 0) {\n                    snprintf(local_608,0x400,\"Error converting check string: %.*s\",8,local_61c);\n                    (**(code **)((long)local_610 + 0x30))\n                              (local_608,*(undefined8 *)((long)local_610 + 0x48));\n                  }\n                  local_24 = 0x10;\n                }\n                else {\n                  iVar2 = strncmp(\"SPSSPORT\",local_624,local_630);\n                  if (iVar2 == 0) {\n                    *(undefined4 *)((long)local_610 + 0x2cc) = 0xffffffff;\n                    local_24 = read_version_and_timestamp(local_610);\n                    if (local_24 == 0) {\n                      local_24 = 0;\n                      do {\n                        uVar1 = read_tag(local_610);\n                        switch(uVar1) {\n                        case 0x31:\n                        case 0x32:\n                        case 0x33:\n                          local_24 = read_string(local_610,local_738,0x100);\n                          break;\n                        case 0x34:\n                          local_24 = read_variable_count_record(local_610);\n                          break;\n                        case 0x35:\n                          local_24 = read_precision_record(local_610);\n                          break;\n                        case 0x36:\n                          local_24 = read_case_weight_record(local_610);\n                          break;\n                        case 0x37:\n                          local_24 = read_variable_record(local_610);\n                          break;\n                        case 0x38:\n                          local_24 = read_missing_value_record(local_610);\n                          break;\n                        case 0x39:\n                          local_24 = read_missing_value_lo_range_record(local_610);\n                          break;\n                        default:\n                          local_24 = 5;\n                          goto LAB_00101f5b;\n                        case 0x41:\n                          local_24 = read_missing_value_hi_range_record(local_610);\n                          break;\n                        case 0x42:\n                          local_24 = read_missing_value_range_record(local_610);\n                          break;\n                        case 0x43:\n                          local_24 = read_variable_label_record(local_610);\n                          break;\n                        case 0x44:\n                          local_24 = read_value_label_record(local_610);\n                          break;\n                        case 0x45:\n                          local_24 = read_document_record(local_610);\n                          break;\n                        case 0x46:\n                          if (*(int *)((long)local_610 + 0x2cc) ==\n                              *(int *)((long)local_610 + 0x2c8) + -1) {\n                            local_24 = handle_variables(local_610);\n                            if ((local_24 == 0) && (*(long *)((long)local_610 + 0x20) != 0)) {\n                              local_24 = read_por_file_data(local_610);\n                            }\n                          }\n                          else {\n                            local_24 = 8;\n                          }\n                          goto LAB_00101f5b;\n                        }\n                      } while (local_24 == 0);\n                    }\n                  }\n                  else {\n                    local_24 = 5;\n                  }\n                }\n              }\n              else {\n                local_24 = 2;\n              }\n            }\n            else {\n              local_24 = 2;\n            }\n          }\n        }\n        else {\n          local_24 = 2;\n        }\n      }\n    }\n  }\nLAB_00101f5b:\n  (*(code *)local_30[1])(local_30[5]);\n  por_ctx_free(local_610);\n  return local_24;\n}\n\n",
        "function_pr": "\nint readstat_parse_por(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  iconv_t pvVar3;\n  long lVar4;\n  undefined local_738 [264];\n  size_t local_630;\n  char local_624 [8];\n  undefined local_61c [8];\n  int local_614;\n  void *local_610;\n  char local_608 [1024];\n  undefined local_208 [60];\n  undefined auStack_1cc [148];\n  byte local_138 [264];\n  undefined8 *local_30;\n  int local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_24 = 0;\n  local_30 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_610 = (void *)por_ctx_init();\n  memcpy(local_610,local_10,0x40);\n  *(undefined8 *)((long)local_610 + 0x48) = local_20;\n  *(undefined8 **)((long)local_610 + 0x58) = local_30;\n  *(int *)((long)local_610 + 0x2d0) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)local_610 + 0x2d4) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  if (*(long *)((long)local_10 + 0x50) != 0) {\n    iVar2 = strcmp(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n    if (iVar2 != 0) {\n      pvVar3 = iconv_open(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n      *(iconv_t *)((long)local_610 + 0x2a8) = pvVar3;\n    }\n    if (*(long *)((long)local_610 + 0x2a8) == -1) {\n      *(undefined8 *)((long)local_610 + 0x2a8) = 0;\n      local_24 = 7;\n      goto LAB_00101f5b;\n    }\n  }\n  iVar2 = (*(code *)*local_30)(local_18,local_30[5]);\n  if (iVar2 == -1) {\n    local_24 = 1;\n  }\n  else {\n    lVar4 = (*(code *)local_30[2])(0,2,local_30[5]);\n    *(long *)((long)local_610 + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_24 = 0xf;\n    }\n    else {\n      lVar4 = (*(code *)local_30[2])(0,0,local_30[5]);\n      if (lVar4 == -1) {\n        local_24 = 0xf;\n      }\n      else {\n        lVar4 = read_bytes(local_610,local_208,200);\n        if (lVar4 == 200) {\n          local_24 = readstat_convert((long)local_610 + 0x89,0x15,auStack_1cc,0x14,0);\n          if (local_24 == 0) {\n            lVar4 = read_bytes(local_610,local_138,0x100);\n            if (lVar4 == 0x100) {\n              *(byte *)((long)local_610 + 0x60) = local_138[0x7e];\n              for (local_614 = 0; local_614 < 0x100; local_614 = local_614 + 1) {\n                if (PTR_por_ascii_lookup_00105fe8[local_614] == '\\0') {\n                  if (*(short *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2) != 0) {\n                    *(undefined2 *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                         *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2);\n                  }\n                }\n                else {\n                  *(short *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                       (short)(char)PTR_por_ascii_lookup_00105fe8[local_614];\n                }\n              }\n              *(undefined2 *)((long)local_610 + (ulong)local_138[0x40] * 2 + 0x9e) =\n                   *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + 0x80);\n              lVar4 = read_bytes(local_610,local_61c,8);\n              if (lVar4 == 8) {\n                local_630 = por_utf8_encode(local_61c,8,local_624,8,(long)local_610 + 0x9e);\n                if (local_630 == 0xffffffffffffffff) {\n                  if (*(long *)((long)local_610 + 0x30) != 0) {\n                    snprintf(local_608,0x400,\"Error converting check string: %.*s\",8,local_61c);\n                    (**(code **)((long)local_610 + 0x30))\n                              (local_608,*(undefined8 *)((long)local_610 + 0x48));\n                  }\n                  local_24 = 0x10;\n                }\n                else {\n                  iVar2 = strncmp(\"SPSSPORT\",local_624,local_630);\n                  if (iVar2 == 0) {\n                    *(undefined4 *)((long)local_610 + 0x2cc) = 0xffffffff;\n                    local_24 = read_version_and_timestamp(local_610);\n                    if (local_24 == 0) {\n                      local_24 = 0;\n                      do {\n                        uVar1 = read_tag(local_610);\n                        switch(uVar1) {\n                        case 0x31:\n                        case 0x32:\n                        case 0x33:\n                          local_24 = read_string(local_610,local_738,0x100);\n                          break;\n                        case 0x34:\n                          local_24 = read_variable_count_record(local_610);\n                          break;\n                        case 0x35:\n                          local_24 = read_precision_record(local_610);\n                          break;\n                        case 0x36:\n                          local_24 = read_case_weight_record(local_610);\n                          break;\n                        case 0x37:\n                          local_24 = read_variable_record(local_610);\n                          break;\n                        case 0x38:\n                          local_24 = read_missing_value_record(local_610);\n                          break;\n                        case 0x42:\n                          local_24 = read_missing_value_range_record(local_610);\n                          break;\n                        case 0x39:\n                          local_24 = read_missing_value_lo_range_record(local_610);\n                          break;\n                        case 0x41:\n                          local_24 = read_missing_value_hi_range_record(local_610);\n                          break;\n                        case 0x43:\n                          local_24 = read_variable_label_record(local_610);\n                          break;\n                        case 0x44:\n                          local_24 = read_value_label_record(local_610);\n                          break;\n                        case 0x45:\n                          local_24 = read_document_record(local_610);\n                          break;\n                        case 0x46:\n                          if (*(int *)((long)local_610 + 0x2cc) ==\n                              *(int *)((long)local_610 + 0x2c8) + -1) {\n                            local_24 = handle_variables(local_610);\n                            if ((local_24 == 0) && (*(long *)((long)local_610 + 0x20) != 0)) {\n                              local_24 = read_por_file_data(local_610);\n                            }\n                          }\n                          else {\n                            local_24 = 8;\n                          }\n                          goto LAB_00101f5b;\n                        default:\n                          local_24 = 5;\n                          goto LAB_00101f5b;\n                        }\n                      } while (local_24 == 0);\n                    }\n                  }\n                  else {\n                    local_24 = 5;\n                  }\n                }\n              }\n              else {\n                local_24 = 2;\n              }\n            }\n            else {\n              local_24 = 2;\n            }\n          }\n        }\n        else {\n          local_24 = 2;\n        }\n      }\n    }\n  }\nLAB_00101f5b:\n  (*(code *)local_30[1])(local_30[5]);\n  por_ctx_free(local_610);\n  return local_24;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  if()\n  if(){\n    if(call(, ))call(, )\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , , , )\n  if()goto label\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  for(;;){\n    if(){\n      \n    }elseif(){\n      \n    }\n  }\n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , , , )){\n    if(){\n      call(, , , , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  call()\n  if()goto label\n  while(){\n    call()\n    switch(){\n      case :\n      \n      case :\n      \n      case :\n        \n        call(, , )\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        if(){\n          \n          goto label\n        }\n        call()\n        if()goto label\n        if(){\n          call()\n        }\n        goto label\n      case :\n        \n        \n        goto label\n    }\n    if()\n  }\n  call()\n  call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, , )\n  \n  \n  \n  if(){\n    \n  }\n  if(){\n    call(, )\n    if(){\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n    }else{\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          call(, , , , )\n          if(){\n            call(, , )\n            if(){\n              \n              for(;;){\n                if(){\n                  if(){\n                    \n                  }\n                }else{\n                  \n                }\n              }\n              \n              call(, , )\n              if(){\n                call(, , , , )\n                if(){\n                  if(){\n                    call(, , , , )\n                    call(, )\n                  }\n                  \n                }else{\n                  call(, , )\n                  if(){\n                    \n                    call()\n                    if(){\n                      \n                      do{\n                        call()\n                        switch(){\n                          case :\n                          case :\n                          case :\n                            call(, , )\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            \n                            \n                            goto label\n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            if(){\n                              call()\n                              if(){\n                                call()\n                              }\n                            }else{\n                              \n                            }\n                            goto label\n                        }\n                      }while()\n                    }\n                  }else{\n                    \n                  }\n                }\n              }else{\n                \n              }\n            }else{\n              \n            }\n          }\n        }else{\n          \n        }\n      }\n    }\n  }\n  call()\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, , )\n  \n  \n  \n  if(){\n    \n  }\n  if(){\n    call(, )\n    if(){\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n    }else{\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          call(, , , , )\n          if(){\n            call(, , )\n            if(){\n              \n              for(;;){\n                if(){\n                  if(){\n                    \n                  }\n                }else{\n                  \n                }\n              }\n              \n              call(, , )\n              if(){\n                call(, , , , )\n                if(){\n                  if(){\n                    call(, , , , )\n                    call(, )\n                  }\n                  \n                }else{\n                  call(, , )\n                  if(){\n                    \n                    call()\n                    if(){\n                      \n                      do{\n                        call()\n                        switch(){\n                          case :\n                          case :\n                          case :\n                            call(, , )\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            if(){\n                              call()\n                              if(){\n                                call()\n                              }\n                            }else{\n                              \n                            }\n                            goto label\n                          case :\n                            \n                            \n                            goto label\n                        }\n                      }while()\n                    }\n                  }else{\n                    \n                  }\n                }\n              }else{\n                \n              }\n            }else{\n              \n            }\n          }\n        }else{\n          \n        }\n      }\n    }\n  }\n  call()\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 2.265625,
          "base_ppl": 1.828125,
          "pr_ppl": 1.8125,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.140625,
          "pr_ast_ppl": 2.109375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a more idiomatic approach with clear variable names and better structured loops, even though it has a minor bug, making it more readable and maintainable.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates introduce unnecessary `goto` statements and extra nesting, but Candidate A more closely preserves the Source's nesting structure, especially around the `for` loop.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_ctx_init-O0.so",
        "function": "dta_ctx_init",
        "source_code": "readstat_error_t dta_ctx_init(dta_ctx_t *ctx, uint32_t nvar, uint64_t nobs,\n        unsigned char byteorder, unsigned char ds_format,\n        const char *input_encoding, const char *output_encoding) {\n    readstat_error_t retval = READSTAT_OK;\n    int machine_byteorder = DTA_HILO;\n    if (ds_format < DTA_MIN_VERSION || ds_format > DTA_MAX_VERSION)\n        return READSTAT_ERROR_UNSUPPORTED_FILE_FORMAT_VERSION;\n\n    if (machine_is_little_endian()) {\n        machine_byteorder = DTA_LOHI;\n    }\n\n    ctx->bswap = (byteorder != machine_byteorder);\n    ctx->ds_format = ds_format;\n    ctx->endianness = byteorder == DTA_LOHI ? READSTAT_ENDIAN_LITTLE : READSTAT_ENDIAN_BIG;\n\n    ctx->nvar = nvar;\n    ctx->nobs = nobs;\n\n    if (ctx->nvar) {\n        if ((ctx->variables = readstat_calloc(ctx->nvar, sizeof(readstat_variable_t *))) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n    }\n\n    ctx->machine_is_twos_complement = READSTAT_MACHINE_IS_TWOS_COMPLEMENT;\n\n    if (ds_format < 105) {\n        ctx->fmtlist_entry_len = 7;\n    } else if (ds_format < 114) {\n        ctx->fmtlist_entry_len = 12;\n    } else if (ds_format < 118) {\n        ctx->fmtlist_entry_len = 49;\n    } else {\n        ctx->fmtlist_entry_len = 57;\n    }\n    \n    if (ds_format >= 117) {\n        ctx->typlist_version = 117;\n    } else if (ds_format >= 111) {\n        ctx->typlist_version = 111;\n    } else {\n        ctx->typlist_version = 0;\n    }\n\n    if (ds_format >= 118) {\n        ctx->data_label_len_len = 2;\n        ctx->strl_v_len = 2;\n        ctx->strl_o_len = 6;\n    } else if (ds_format >= 117) {\n        ctx->data_label_len_len = 1;\n        ctx->strl_v_len = 4;\n        ctx->strl_o_len = 4;\n    }\n\n    if (ds_format < 105) {\n        ctx->expansion_len_len = 0;\n    } else if (ds_format < 110) {\n        ctx->expansion_len_len = 2;\n    } else {\n        ctx->expansion_len_len = 4;\n    }\n    \n    if (ds_format < 110) {\n        ctx->lbllist_entry_len = 9;\n        ctx->variable_name_len = 9;\n        ctx->ch_metadata_len = 9;\n    } else if (ds_format < 118) {\n        ctx->lbllist_entry_len = 33;\n        ctx->variable_name_len = 33;\n        ctx->ch_metadata_len = 33;\n    } else {\n        ctx->lbllist_entry_len = 129;\n        ctx->variable_name_len = 129;\n        ctx->ch_metadata_len = 129;\n    }\n\n    if (ds_format < 108) {\n        ctx->variable_labels_entry_len = 32;\n        ctx->data_label_len = 32;\n    } else if (ds_format < 118) {\n        ctx->variable_labels_entry_len = 81;\n        ctx->data_label_len = 81;\n    } else {\n        ctx->variable_labels_entry_len = 321;\n        ctx->data_label_len = 321;\n    }\n\n    if (ds_format < 105) {\n        ctx->timestamp_len = 0;\n        ctx->value_label_table_len_len = 2;\n        ctx->value_label_table_labname_len = 12;\n        ctx->value_label_table_padding_len = 2;\n    } else {\n        ctx->timestamp_len = 18;\n        ctx->value_label_table_len_len = 4;\n        if (ds_format < 118) {\n            ctx->value_label_table_labname_len = 33;\n        } else {\n            ctx->value_label_table_labname_len = 129;\n        }\n        ctx->value_label_table_padding_len = 3;\n    }\n\n    if (ds_format < 117) {\n        ctx->typlist_entry_len = 1;\n        ctx->file_is_xmlish = 0;\n    } else {\n        ctx->typlist_entry_len = 2;\n        ctx->file_is_xmlish = 1;\n    }\n\n    if (ds_format < 113) {\n        ctx->max_int8 = DTA_OLD_MAX_INT8;\n        ctx->max_int16 = DTA_OLD_MAX_INT16;\n        ctx->max_int32 = DTA_OLD_MAX_INT32;\n        ctx->max_float = DTA_OLD_MAX_FLOAT;\n        ctx->max_double = DTA_OLD_MAX_DOUBLE;\n    } else {\n        ctx->max_int8 = DTA_113_MAX_INT8;\n        ctx->max_int16 = DTA_113_MAX_INT16;\n        ctx->max_int32 = DTA_113_MAX_INT32;\n        ctx->max_float = DTA_113_MAX_FLOAT;\n        ctx->max_double = DTA_113_MAX_DOUBLE;\n\n        ctx->supports_tagged_missing = 1;\n    }\n\n    if (output_encoding) {\n        if (input_encoding) {\n            ctx->converter = iconv_open(output_encoding, input_encoding);\n        } else if (ds_format < 118) {\n            ctx->converter = iconv_open(output_encoding, \"WINDOWS-1252\");\n        } else if (strcmp(output_encoding, \"UTF-8\") != 0) {\n            ctx->converter = iconv_open(output_encoding, \"UTF-8\");\n        }\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n\n    if (ds_format < 119) {\n        ctx->srtlist_len = (ctx->nvar + 1) * sizeof(int16_t);\n    } else {\n        ctx->srtlist_len = (ctx->nvar + 1) * sizeof(int32_t);\n    }\n\n    if ((ctx->srtlist = readstat_malloc(ctx->srtlist_len)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->nvar > 0) {\n        ctx->typlist_len = ctx->nvar * sizeof(uint16_t);\n        ctx->varlist_len = ctx->variable_name_len * ctx->nvar * sizeof(char);\n        ctx->fmtlist_len = ctx->fmtlist_entry_len * ctx->nvar * sizeof(char);\n        ctx->lbllist_len = ctx->lbllist_entry_len * ctx->nvar * sizeof(char);\n        ctx->variable_labels_len = ctx->variable_labels_entry_len * ctx->nvar * sizeof(char);\n\n        if ((ctx->typlist = readstat_malloc(ctx->typlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->varlist = readstat_malloc(ctx->varlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->fmtlist = readstat_malloc(ctx->fmtlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->lbllist = readstat_malloc(ctx->lbllist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->variable_labels = readstat_malloc(ctx->variable_labels_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n    }\n\n    ctx->initialized = 1;\n\ncleanup:\n    return retval;\n}\n",
        "function_base": "\nundefined4\ndta_ctx_init(long param_1,undefined4 param_2,undefined8 param_3,char param_4,byte param_5,\n            char *param_6,char *param_7)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  iconv_t pvVar4;\n  undefined4 uVar5;\n  \n  cVar1 = '\\x01';\n  if ((param_5 < 0x68) || (0x77 < param_5)) {\n    return 0x18;\n  }\n  iVar2 = machine_is_little_endian();\n  if (iVar2 != 0) {\n    cVar1 = '\\x02';\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfe | param_4 != cVar1;\n  *(uint *)(param_1 + 0x108) = (uint)param_5;\n  uVar5 = 2;\n  if (param_4 == '\\x02') {\n    uVar5 = 1;\n  }\n  *(undefined4 *)(param_1 + 0x170) = uVar5;\n  *(undefined4 *)(param_1 + 0x10c) = param_2;\n  *(undefined8 *)(param_1 + 0x110) = param_3;\n  if (*(int *)(param_1 + 0x10c) != 0) {\n    lVar3 = readstat_calloc((long)*(int *)(param_1 + 0x10c),8);\n    *(long *)(param_1 + 0x168) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfd;\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xa0) = 7;\n  }\n  else if (param_5 < 0x72) {\n    *(undefined8 *)(param_1 + 0xa0) = 0xc;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa0) = 0x31;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa0) = 0x39;\n  }\n  if (param_5 < 0x75) {\n    if (param_5 < 0x6f) {\n      *(undefined1 *)(param_1 + 0x28) = 0;\n    }\n    else {\n      *(undefined1 *)(param_1 + 0x28) = 0x6f;\n    }\n  }\n  else {\n    *(undefined1 *)(param_1 + 0x28) = 0x75;\n  }\n  if (param_5 < 0x76) {\n    if (0x74 < param_5) {\n      *(undefined8 *)(param_1 + 0x10) = 1;\n      *(undefined8 *)(param_1 + 0xe0) = 4;\n      *(undefined8 *)(param_1 + 0xe8) = 4;\n    }\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x10) = 2;\n    *(undefined8 *)(param_1 + 0xe0) = 2;\n    *(undefined8 *)(param_1 + 0xe8) = 6;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xb8) = 0;\n  }\n  else if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xb8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb8) = 4;\n  }\n  if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xa8) = 9;\n    *(undefined8 *)(param_1 + 0x98) = 9;\n    *(undefined8 *)(param_1 + 0xc0) = 9;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa8) = 0x21;\n    *(undefined8 *)(param_1 + 0x98) = 0x21;\n    *(undefined8 *)(param_1 + 0xc0) = 0x21;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa8) = 0x81;\n    *(undefined8 *)(param_1 + 0x98) = 0x81;\n    *(undefined8 *)(param_1 + 0xc0) = 0x81;\n  }\n  if (param_5 < 0x6c) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x20;\n    *(undefined8 *)(param_1 + 8) = 0x20;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x51;\n    *(undefined8 *)(param_1 + 8) = 0x51;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb0) = 0x141;\n    *(undefined8 *)(param_1 + 8) = 0x141;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n    *(undefined8 *)(param_1 + 200) = 2;\n    *(undefined8 *)(param_1 + 0xd0) = 0xc;\n    *(undefined8 *)(param_1 + 0xd8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x20) = 0x12;\n    *(undefined8 *)(param_1 + 200) = 4;\n    if (param_5 < 0x76) {\n      *(undefined8 *)(param_1 + 0xd0) = 0x21;\n    }\n    else {\n      *(undefined8 *)(param_1 + 0xd0) = 0x81;\n    }\n    *(undefined8 *)(param_1 + 0xd8) = 3;\n  }\n  if (param_5 < 0x75) {\n    *(undefined8 *)(param_1 + 0x30) = 1;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x30) = 2;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb | 4;\n  }\n  if (param_5 < 0x71) {\n    *(undefined1 *)(param_1 + 0x139) = 0x7e;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7ffe;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7ffffffe;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n  }\n  else {\n    *(undefined1 *)(param_1 + 0x139) = 100;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7fe4;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7fffffe4;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xf7 | 8;\n  }\n  if (param_7 != (char *)0x0) {\n    if (param_6 == (char *)0x0) {\n      if (param_5 < 0x76) {\n        pvVar4 = iconv_open(param_7,\"WINDOWS-1252\");\n        *(iconv_t *)(param_1 + 0x178) = pvVar4;\n      }\n      else {\n        iVar2 = strcmp(param_7,\"UTF-8\");\n        if (iVar2 != 0) {\n          pvVar4 = iconv_open(param_7,\"UTF-8\");\n          *(iconv_t *)(param_1 + 0x178) = pvVar4;\n        }\n      }\n    }\n    else {\n      pvVar4 = iconv_open(param_7,param_6);\n      *(iconv_t *)(param_1 + 0x178) = pvVar4;\n    }\n    if (*(long *)(param_1 + 0x178) == -1) {\n      *(undefined8 *)(param_1 + 0x178) = 0;\n      return 7;\n    }\n  }\n  if (param_5 < 0x77) {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 1;\n  }\n  else {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 2;\n  }\n  lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x60));\n  *(long *)(param_1 + 0x58) = lVar3;\n  if (lVar3 == 0) {\n    return 3;\n  }\n  if (0 < *(int *)(param_1 + 0x10c)) {\n    *(long *)(param_1 + 0x40) = (long)*(int *)(param_1 + 0x10c) << 1;\n    *(long *)(param_1 + 0x50) = *(long *)(param_1 + 0x98) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x70) = *(long *)(param_1 + 0xa0) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x80) = *(long *)(param_1 + 0xa8) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x90) = *(long *)(param_1 + 0xb0) * (long)*(int *)(param_1 + 0x10c);\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x40));\n    *(long *)(param_1 + 0x38) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x50));\n    *(long *)(param_1 + 0x48) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x70));\n    *(long *)(param_1 + 0x68) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x80));\n    *(long *)(param_1 + 0x78) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x90));\n    *(long *)(param_1 + 0x88) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(undefined4 *)(param_1 + 0x1d8) = 1;\n  return 0;\n}\n\n",
        "function_pr": "\nundefined4\ndta_ctx_init(long param_1,undefined4 param_2,undefined8 param_3,char param_4,byte param_5,\n            char *param_6,char *param_7)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  iconv_t pvVar4;\n  undefined4 uVar5;\n  \n  cVar1 = '\\x01';\n  if ((param_5 < 0x68) || (0x77 < param_5)) {\n    return 0x18;\n  }\n  iVar2 = machine_is_little_endian();\n  if (iVar2 != 0) {\n    cVar1 = '\\x02';\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfe | param_4 != cVar1;\n  *(uint *)(param_1 + 0x108) = (uint)param_5;\n  uVar5 = 2;\n  if (param_4 == '\\x02') {\n    uVar5 = 1;\n  }\n  *(undefined4 *)(param_1 + 0x170) = uVar5;\n  *(undefined4 *)(param_1 + 0x10c) = param_2;\n  *(undefined8 *)(param_1 + 0x110) = param_3;\n  if (*(int *)(param_1 + 0x10c) != 0) {\n    lVar3 = readstat_calloc((long)*(int *)(param_1 + 0x10c),8);\n    *(long *)(param_1 + 0x168) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfd;\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xa0) = 7;\n  }\n  else if (param_5 < 0x72) {\n    *(undefined8 *)(param_1 + 0xa0) = 0xc;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa0) = 0x31;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa0) = 0x39;\n  }\n  if (param_5 < 0x75) {\n    if (param_5 < 0x6f) {\n      *(undefined *)(param_1 + 0x28) = 0;\n    }\n    else {\n      *(undefined *)(param_1 + 0x28) = 0x6f;\n    }\n  }\n  else {\n    *(undefined *)(param_1 + 0x28) = 0x75;\n  }\n  if (param_5 < 0x76) {\n    if (0x74 < param_5) {\n      *(undefined8 *)(param_1 + 0x10) = 1;\n      *(undefined8 *)(param_1 + 0xe0) = 4;\n      *(undefined8 *)(param_1 + 0xe8) = 4;\n    }\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x10) = 2;\n    *(undefined8 *)(param_1 + 0xe0) = 2;\n    *(undefined8 *)(param_1 + 0xe8) = 6;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xb8) = 0;\n  }\n  else if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xb8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb8) = 4;\n  }\n  if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xa8) = 9;\n    *(undefined8 *)(param_1 + 0x98) = 9;\n    *(undefined8 *)(param_1 + 0xc0) = 9;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa8) = 0x21;\n    *(undefined8 *)(param_1 + 0x98) = 0x21;\n    *(undefined8 *)(param_1 + 0xc0) = 0x21;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa8) = 0x81;\n    *(undefined8 *)(param_1 + 0x98) = 0x81;\n    *(undefined8 *)(param_1 + 0xc0) = 0x81;\n  }\n  if (param_5 < 0x6c) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x20;\n    *(undefined8 *)(param_1 + 8) = 0x20;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x51;\n    *(undefined8 *)(param_1 + 8) = 0x51;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb0) = 0x141;\n    *(undefined8 *)(param_1 + 8) = 0x141;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n    *(undefined8 *)(param_1 + 200) = 2;\n    *(undefined8 *)(param_1 + 0xd0) = 0xc;\n    *(undefined8 *)(param_1 + 0xd8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x20) = 0x12;\n    *(undefined8 *)(param_1 + 200) = 4;\n    if (param_5 < 0x76) {\n      *(undefined8 *)(param_1 + 0xd0) = 0x21;\n    }\n    else {\n      *(undefined8 *)(param_1 + 0xd0) = 0x81;\n    }\n    *(undefined8 *)(param_1 + 0xd8) = 3;\n  }\n  if (param_5 < 0x75) {\n    *(undefined8 *)(param_1 + 0x30) = 1;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x30) = 2;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb | 4;\n  }\n  if (param_5 < 0x71) {\n    *(undefined *)(param_1 + 0x139) = 0x7e;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7ffe;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7ffffffe;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n  }\n  else {\n    *(undefined *)(param_1 + 0x139) = 100;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7fe4;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7fffffe4;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xf7 | 8;\n  }\n  if (param_7 != (char *)0x0) {\n    if (param_6 == (char *)0x0) {\n      if (param_5 < 0x76) {\n        pvVar4 = iconv_open(param_7,\"WINDOWS-1252\");\n        *(iconv_t *)(param_1 + 0x178) = pvVar4;\n      }\n      else {\n        iVar2 = strcmp(param_7,\"UTF-8\");\n        if (iVar2 != 0) {\n          pvVar4 = iconv_open(param_7,\"UTF-8\");\n          *(iconv_t *)(param_1 + 0x178) = pvVar4;\n        }\n      }\n    }\n    else {\n      pvVar4 = iconv_open(param_7,param_6);\n      *(iconv_t *)(param_1 + 0x178) = pvVar4;\n    }\n    if (*(long *)(param_1 + 0x178) == -1) {\n      *(undefined8 *)(param_1 + 0x178) = 0;\n      return 7;\n    }\n  }\n  if (param_5 < 0x77) {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 1;\n  }\n  else {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 2;\n  }\n  lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x60));\n  *(long *)(param_1 + 0x58) = lVar3;\n  if (lVar3 == 0) {\n    return 3;\n  }\n  if (0 < *(int *)(param_1 + 0x10c)) {\n    *(long *)(param_1 + 0x40) = (long)*(int *)(param_1 + 0x10c) << 1;\n    *(long *)(param_1 + 0x50) = *(long *)(param_1 + 0x98) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x70) = *(long *)(param_1 + 0xa0) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x80) = *(long *)(param_1 + 0xa8) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x90) = *(long *)(param_1 + 0xb0) * (long)*(int *)(param_1 + 0x10c);\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x40));\n    *(long *)(param_1 + 0x38) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x50));\n    *(long *)(param_1 + 0x48) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x70));\n    *(long *)(param_1 + 0x68) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x80));\n    *(long *)(param_1 + 0x78) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x90));\n    *(long *)(param_1 + 0x88) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(undefined4 *)(param_1 + 0x1d8) = 1;\n  return 0;\n}\n\n",
        "source_ast": "{\n  \n  \n  if()return\n  if(call()){\n    \n  }\n  \n  \n  (? : )\n  \n  \n  if(){\n    if(call(, )){\n      \n      goto label\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      call(, )\n    }elseif(){\n      call(, )\n    }elseif(call(, )){\n      call(, )\n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(){\n    \n    \n    \n    \n    \n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  call()\n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    call(, )\n    \n    if(){\n      return\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    if(){\n      \n    }else{\n      \n    }\n  }else{\n    \n  }\n  if(){\n    if(){\n      \n      \n      \n    }\n  }else{\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      if(){\n        call(, )\n        \n      }else{\n        call(, )\n        if(){\n          call(, )\n          \n        }\n      }\n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      return\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  call()\n  \n  if(){\n    return\n  }\n  if(){\n    \n    \n    \n    \n    \n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n  }\n  \n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  call()\n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    call(, )\n    \n    if(){\n      return\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    if(){\n      \n    }else{\n      \n    }\n  }else{\n    \n  }\n  if(){\n    if(){\n      \n      \n      \n    }\n  }else{\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      if(){\n        call(, )\n        \n      }else{\n        call(, )\n        if(){\n          call(, )\n          \n        }\n      }\n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      return\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  call()\n  \n  if(){\n    return\n  }\n  if(){\n    \n    \n    \n    \n    \n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n  }\n  \n  return\n}",
        "metrics": {
          "source_ppl": 1.7734375,
          "base_ppl": 1.4921875,
          "pr_ppl": 1.4921875,
          "source_ast_ppl": 2.03125,
          "base_ast_ppl": 1.8359375,
          "pr_ast_ppl": 1.8359375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more human-readable because it follows standard C practices and is easier to understand.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      }
    ]
  }
}