{
  "pr": "8161",
  "mean_delta_perplexity": -0.0146875,
  "mean_perplexity_base": 1.8590625,
  "mean_perplexity_pr": 1.844375,
  "mean_perplexity_source": 2.2234375,
  "mean_perplexity_base_ast": 2.5721875,
  "mean_perplexity_pr_ast": 2.5484375,
  "mean_perplexity_source_ast": 3.123125,
  "results": {
    "qwen-3": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type *id){\n  if(!id)return id;\n  type id = id0id0;\n  type id = id0id0;\n  type *id = null;\n  type id = 0;\n  type id = id;\n  call(str);\n  do{\n    if(id > 10){\n      call(str, (type)id->id);\n      call(str, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, 1, 4, id->id) != 4){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == null){\n        if(id)call(id, str, (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, 1, id.id, id->id) != id.id){\n        if(id)call(id, str);\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[0] + (id[1] << 8) != 0x600);\n        id->id = id[2] + (id[3] << 8);\n        if(id){\n          call(str, (id->id ? str : str));\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id->id = id[0] + (id[1] << 8);\n        if(id)call(str, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call(str);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }else{\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type *id;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            if(id)call(str, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type *id;\n          id = (type)id;\n          call(str, id->id & 0x07FF);\n          if(id->id & 0x8000){\n            call(str, id->id);\n            call(str, id->id);\n          }else{\n            type *id = call((type)&id[2], id.id - 2, 1, id);\n            call(str, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > 10){\n          type *id = id + 2;\n          type id, id;\n          id = id[0] + (id[1] << 8);\n          for(id = 0;  id < id; ++id){\n            call(str, id + 8, id[0], id[1], id[2]);\n            id = 4;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call(str);\n          for(id = 0;  id < id.id; ++id)call(str, id[id]);\n          call(str);\n        }\n        break;\n      case def:\n        if(id){\n          call(str, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = 1;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = call(id) * id;\n            *(type)((type)id + 0xd) = (id) * id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (type)(type)id[id * 2 + 1], (id) * (type)((type)id + id * 4 + 3), (type)(type)id[id * 2 + 2]);\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (type)(type)id[1]);\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = (type)call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = call(id) * id;\n            *(type)((type)id + 0xd) = (id) * id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (type)(type)id[id * 2 + 1], (id) * (type)((type)id + id * 4 + 3), (type)(type)id[id * 2 + 2]);\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (type)(type)id[1]);\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 2.078125,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.296875,
          "base_ast_ppl": 2.25,
          "pr_ast_ppl": 2.25,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate A avoids an explicit cast to 'ushort *' which may be unnecessary if '__ptr' is already declared as a 'ushort *' or 'void *'. This keeps the code concise and avoids introducing a potential type mismatch that could obscure the original intent. The logic flow remains unchanged, and the absence of an artificial cast aligns with minimalism in human-readable code.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A preserves the original variable names (buf, bof1.size) and memory allocation logic, aligning with the Source Code's structure. Candidate B introduces a variable name change (__ptr, uStack_38) and a bitwise shift operation (>> 0x30) that diverges from the source's explicit use of bof1.size, breaking structural isomorphism.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "The structural control flow remains unchanged between candidates. Candidate B introduces a type cast, which is a semantic clarification but does not alter the control flow hierarchy. Since both versions share identical conditional nesting and no new control structures (e.g., loops, switches) are introduced, Candidate A avoids unnecessary type annotations that could be considered artificial or machine-like in this context.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores the `(type)` cast present in the Source AST, which is absent in Candidate A. The Source contains numerous explicit type casts (e.g., `(type)id->id`), and Candidate B aligns with this topology by reintroducing the missing cast. Both versions share identical nesting complexity in this context.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type *id){\n  if(!id)return id;\n  type id = id0id0;\n  type id = id0id0;\n  type *id = null;\n  type id = 0;\n  type id = id;\n  call(str);\n  do{\n    if(id > 10){\n      call(str, (type)id->id);\n      call(str, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, 1, 4, id->id) != 4){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == null){\n        if(id)call(id, str, (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, 1, id.id, id->id) != id.id){\n        if(id)call(id, str);\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[0] + (id[1] << 8) != 0x600);\n        id->id = id[2] + (id[3] << 8);\n        if(id){\n          call(str, (id->id ? str : str));\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id->id = id[0] + (id[1] << 8);\n        if(id)call(str, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call(str);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }else{\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type *id;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            if(id)call(str, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type *id;\n          id = (type)id;\n          call(str, id->id & 0x07FF);\n          if(id->id & 0x8000){\n            call(str, id->id);\n            call(str, id->id);\n          }else{\n            type *id = call((type)&id[2], id.id - 2, 1, id);\n            call(str, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > 10){\n          type *id = id + 2;\n          type id, id;\n          id = id[0] + (id[1] << 8);\n          for(id = 0;  id < id; ++id){\n            call(str, id + 8, id[0], id[1], id[2]);\n            id = 4;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call(str);\n          for(id = 0;  id < id.id; ++id)call(str, id[id]);\n          call(str);\n        }\n        break;\n      case def:\n        if(id){\n          call(str, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = 1;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = call(id) * id;\n            *(type)((type)id + 0xd) = (id) * id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (type)(type)id[id * 2 + 1], (id) * (type)((type)id + id * 4 + 3), (type)(type)id[id * 2 + 2]);\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (type)(type)id[1]);\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = (type)call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = call(id) * id;\n            *(type)((type)id + 0xd) = (id) * id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (type)(type)id[id * 2 + 1], (id) * (type)((type)id + id * 4 + 3), (type)(type)id[id * 2 + 2]);\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (type)(type)id[1]);\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 2.078125,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.296875,
          "base_ast_ppl": 2.25,
          "pr_ast_ppl": 2.25,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "motivation": "Candidate A avoids an explicit type cast, maintaining a simpler expression structure. The control flow remains unchanged between candidates, so the tie-breaker applies: Candidate A has less artificial complexity in the assignment statement, aligning better with human-readable code conventions.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate B includes a `(type)` cast around the `call()` invocation, which aligns with the Ground Truth's frequent use of explicit type casts (e.g., `(type)id->id`, `(type)id`). This matches the Source AST's topology by restoring a type node missing in Candidate A. The nesting depth remains unchanged, so complexity is neutral.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "type id(type *id){\n  if(!id)return id;\n  type id = id0id0;\n  type id = id0id0;\n  type *id = null;\n  type id = 0;\n  type id = id;\n  call(str);\n  do{\n    if(id > 10){\n      call(str, (type)id->id);\n      call(str, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, 1, 4, id->id) != 4){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == null){\n        if(id)call(id, str, (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, 1, id.id, id->id) != id.id){\n        if(id)call(id, str);\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[0] + (id[1] << 8) != 0x600);\n        id->id = id[2] + (id[3] << 8);\n        if(id){\n          call(str, (id->id ? str : str));\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id->id = id[0] + (id[1] << 8);\n        if(id)call(str, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call(str);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }else{\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type *id;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            if(id)call(str, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type *id;\n          id = (type)id;\n          call(str, id->id & 0x07FF);\n          if(id->id & 0x8000){\n            call(str, id->id);\n            call(str, id->id);\n          }else{\n            type *id = call((type)&id[2], id.id - 2, 1, id);\n            call(str, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > 10){\n          type *id = id + 2;\n          type id, id;\n          id = id[0] + (id[1] << 8);\n          for(id = 0;  id < id; ++id){\n            call(str, id + 8, id[0], id[1], id[2]);\n            id = 4;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call(str);\n          for(id = 0;  id < id.id; ++id)call(str, id[id]);\n          call(str);\n        }\n        break;\n      case def:\n        if(id){\n          call(str, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = 1;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = id;\n    call(&id, 0, 4);\n    call(&id, 0, 4);\n    id = (type)0x0;\n    id = bool;\n    id = 0;\n    call(str);\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        call(str, (id) * (type)(*id + 8), *(type)(*id + 0x10) & 0xffffffff, *(type)(*id + 0x20) & 0xffffffff, *(type)(*id + 0x28) & 0xffffffff);\n      }\n      id = call(&id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(&id);\n      if(*(type)id != 0){\n        call(&id);\n      }\n      if(id.id != 0){\n        id = call(id, (type)id.id);\n        if(id == (type)0x0){\n          if(*(type)id != 0){\n            call(*(type)id, str, (type)id.id);\n          }\n          id = 5;\n          break;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != 0){\n            call(*(type)id, str);\n          }\n          id = 3;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      id = id & 0xffff;\n      if(id != 10){\n        if(id == 0x18){\n          if(*(type)id != 0){\n            call(str);\n            for(id = 0;  id < (type)(id >> 0x10); id = id + 1){\n              call(str, (id) * (type)((type)id + (type)id));\n            }\n            call(str);\n          }\n        }elseif(id == 0x22){\n          *(type)((type)id + 0xd) = (id) * id;\n          if(*(type)id != 0){\n            call(str, (id) * (type)((type)id + 0xd));\n          }\n        }else{\n          if(id == 0x2f){\n            id = 6;\n            break;\n          }\n          if(id == 0x31){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n          }elseif(id == 0x3c){\n            if(id){\n              if(((type)id == 0xfc) && (id = call(id, id, id.id)id != 0))break;\n              id = id;\n            }\n          }elseif(id == 0x3d){\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, (id) * id / 0x14, (id) * id % 0x14);\n              call(str, (type)id[1] / 0x14, (type)id[1] % 0x14);\n              call(str, (type)id[2] / 0x14, (type)id[2] % 0x14);\n              call(str, (type)id[3] / 0x14, (type)id[3] % 0x14);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              call(str, (type)id[8]);\n            }\n          }elseif(id == 0x42){\n            *(type)((type)id + 0x12) = call(id) * id + (id) * (type)((type)id + 1) * 0x100;\n            if(*(type)id != 0){\n              call(str, (id) * (type)((type)id + 0x12));\n            }\n          }elseif(id == 0x85){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != 0)break;\n          }elseif(id == 0x92){\n            if(10 < *(type)id){\n              id = id + 1;\n              id = *id;\n              id = *(type)((type)id + 1);\n              for(id = 0;  id < (type)((type)(type)id + (type)id * 0x100); id = id + 1){\n                call(str, call(id + 8), call(id) * id, (id) * (type)((type)id + 1), (type)(type)id[1]);\n                id = id + 2;\n              }\n            }\n          }elseif(id == 0xe0){\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(str, (id) * id);\n                call(str, (type)id[1]);\n                call(str, (type)id[2]);\n                call(str, (type)id[3]);\n                call(str, (type)id[4]);\n                call(str, (type)id[5]);\n                call(str, (type)id[6]);\n                call(str, (type)id[7]);\n              }\n            }\n          }else{\n            if(id == 0xfc){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != 0xff){\n              if(id == 0x231)goto lbl;\n              if(id == 0x293){\n                if(*(type)id != 0){\n                  call(str, call(*id & 0x7ff));\n                  if((*id & 0x8000) == 0){\n                    id = (type)call(id + 1, (type)(type)((id >> 0x10) - 2), 1, id);\n                    call(str, id);\n                    call(id);\n                  }else{\n                    call(str, (type)(type)id[1]);\n                    call(str, (id) * (type)((type)id + 3));\n                  }\n                }\n              }else{\n                if(id == 0x41e){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == 0x809){\n                  *(type)((type)id + 0xc) = call(id) * id + (id) * (type)((type)id + 1) * 0x100 != 0x600;\n                  *(type)((type)id + 0xe) = (type)(type)id[1] + (id) * (type)((type)id + 3) * 0x100;\n                  if(*(type)id != 0){\n                    id = str;\n                    if(*(type)((type)id + 0xc) != str){\n                      id = str;\n                    }\n                    call(str, id);\n                    call(str, (id) * (type)((type)id + 0xe));\n                  }\n                }elseif(*(type)id != 0){\n                  call(str, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id + 0x3c) == str){\n        id = (type)id != 10;\n      }\n    }while(id);\n    if(id != (type)0x0){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = id;\n    call(&id, 0, 4);\n    call(&id, 0, 4);\n    id = (type)0x0;\n    id = bool;\n    id = 0;\n    call(str);\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        call(str, (id) * (type)(*id + 8), *(type)(*id + 0x10) & 0xffffffff, *(type)(*id + 0x20) & 0xffffffff, *(type)(*id + 0x28) & 0xffffffff);\n      }\n      id = call(&id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(&id);\n      if(*(type)id != 0){\n        call(&id);\n      }\n      if(id.id != 0){\n        id = (type)call(id, (type)id.id);\n        if(id == (type)0x0){\n          if(*(type)id != 0){\n            call(*(type)id, str, (type)id.id);\n          }\n          id = 5;\n          break;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != 0){\n            call(*(type)id, str);\n          }\n          id = 3;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      id = id & 0xffff;\n      if(id != 10){\n        if(id == 0x18){\n          if(*(type)id != 0){\n            call(str);\n            for(id = 0;  id < (type)(id >> 0x10); id = id + 1){\n              call(str, (id) * (type)((type)id + (type)id));\n            }\n            call(str);\n          }\n        }elseif(id == 0x22){\n          *(type)((type)id + 0xd) = (id) * id;\n          if(*(type)id != 0){\n            call(str, (id) * (type)((type)id + 0xd));\n          }\n        }else{\n          if(id == 0x2f){\n            id = 6;\n            break;\n          }\n          if(id == 0x31){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n          }elseif(id == 0x3c){\n            if(id){\n              if(((type)id == 0xfc) && (id = call(id, id, id.id)id != 0))break;\n              id = id;\n            }\n          }elseif(id == 0x3d){\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, (id) * id / 0x14, (id) * id % 0x14);\n              call(str, (type)id[1] / 0x14, (type)id[1] % 0x14);\n              call(str, (type)id[2] / 0x14, (type)id[2] % 0x14);\n              call(str, (type)id[3] / 0x14, (type)id[3] % 0x14);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              call(str, (type)id[8]);\n            }\n          }elseif(id == 0x42){\n            *(type)((type)id + 0x12) = call(id) * id + (id) * (type)((type)id + 1) * 0x100;\n            if(*(type)id != 0){\n              call(str, (id) * (type)((type)id + 0x12));\n            }\n          }elseif(id == 0x85){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != 0)break;\n          }elseif(id == 0x92){\n            if(10 < *(type)id){\n              id = id + 1;\n              id = *id;\n              id = *(type)((type)id + 1);\n              for(id = 0;  id < (type)((type)(type)id + (type)id * 0x100); id = id + 1){\n                call(str, call(id + 8), call(id) * id, (id) * (type)((type)id + 1), (type)(type)id[1]);\n                id = id + 2;\n              }\n            }\n          }elseif(id == 0xe0){\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(str, (id) * id);\n                call(str, (type)id[1]);\n                call(str, (type)id[2]);\n                call(str, (type)id[3]);\n                call(str, (type)id[4]);\n                call(str, (type)id[5]);\n                call(str, (type)id[6]);\n                call(str, (type)id[7]);\n              }\n            }\n          }else{\n            if(id == 0xfc){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != 0xff){\n              if(id == 0x231)goto lbl;\n              if(id == 0x293){\n                if(*(type)id != 0){\n                  call(str, call(*id & 0x7ff));\n                  if((*id & 0x8000) == 0){\n                    id = (type)call(id + 1, (type)(type)((id >> 0x10) - 2), 1, id);\n                    call(str, id);\n                    call(id);\n                  }else{\n                    call(str, (type)(type)id[1]);\n                    call(str, (id) * (type)((type)id + 3));\n                  }\n                }\n              }else{\n                if(id == 0x41e){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == 0x809){\n                  *(type)((type)id + 0xc) = call(id) * id + (id) * (type)((type)id + 1) * 0x100 != 0x600;\n                  *(type)((type)id + 0xe) = (type)(type)id[1] + (id) * (type)((type)id + 3) * 0x100;\n                  if(*(type)id != 0){\n                    id = str;\n                    if(*(type)((type)id + 0xc) != str){\n                      id = str;\n                    }\n                    call(str, id);\n                    call(str, (id) * (type)((type)id + 0xe));\n                  }\n                }elseif(*(type)id != 0){\n                  call(str, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id + 0x3c) == str){\n        id = (type)id != 10;\n      }\n    }while(id);\n    if(id != (type)0x0){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 2.015625,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.296875,
          "base_ast_ppl": 2.375,
          "pr_ast_ppl": 2.375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A aligns with the Source Code structure by avoiding an unnecessary cast to 'ushort *' which is not present in the original code. The source uses 'BYTE* buf' without type-casting the realloc result, making Candidate B's addition of '(ushort *)' a regression.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate A matches the Source AST topology as it preserves the original structure without introducing new node types. Candidate B adds an extraneous cast around the call() function, which is not present in the Ground Truth, violating the Topology Match criterion.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 + 1];\n  type id[64 + 1];\n  type *id = null;\n  type id = 0;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id++;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 5:\n        {\n          id = id;\n        }\n        break;\n        case 6:\n        {\n          id = id - id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id++;\n              }\n            }\n          }\n          break;\n          case 4:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case 6:\n          {\n            id = id - id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id - id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = (type)call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = (type)call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.34375,
          "base_ppl": 1.859375,
          "pr_ppl": 1.859375,
          "source_ast_ppl": 2.234375,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "The logic flow and control structures are identical between Candidate A and B. The only difference is an explicit cast to (char *) in Candidate B. Since the logic is unchanged and the tie-breaker favors less artificial nesting, Candidate A is preferable as it avoids the redundant cast, maintaining simplicity and readability without altering control flow.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A aligns with the Source Code structure by omitting the unnecessary (char *) cast, which is not present in the original code. The Source Code uses bsearch without explicit casting to char*, instead relying on type-specific assignments (varlookup_t *). Candidate B introduces a cast to char*, which diverges from the original structure and adds noise.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "<think>\nOkay, let's tackle this problem step by step. The user wants to determine whether Candidate A or B in the AST diff matches the Source AST topology. The criteria given are Topology Match and Complexity. \n\nFirst, I need to understand what the Ground Truth (Source AST) looks like. From the provided code, it's a function with a lot of variable declarations, assignments, loops, conditionals, and switch statements. There are multiple labels (like lbl) and goto statements, which are common in C-style code. The structure is quite complex with nested blocks, especially in the switch cases where there are multiple code blocks with calls and assignments.\n\nNow, looking at the AST Diff between A and B. The changes are in two places. In the first diff block (around line 116), Candidate A has \"id = call(id, id, id, 0x28, id);\" while Candidate B adds a cast to (type) around the call. Similarly, in the second diff block (around line 178), the same change is present: adding a (type) cast to the call.\n\nThe criteria mention Topology Match: does the '+' code (Candidate B) restore a node type present in the Source but missing in Candidate A? The Source code has various type casts, like (type)id, (type)0x0, etc. In the Source, there's a line like \"type *id = (type)id;\" which shows explicit casting. Also, in the switch cases, there are assignments like \"id = (type)*id++;\" which involve casting. \n\nIn Candidate A, the call is not cast, but in Candidate B, it's cast to (type). The Source has these casts, so if Candidate B adds the cast, that would align with the Source's structure. However, I need to check if the Source's AST includes these casts. For example, in the original Source code, there's a line \"type *id = (type)id;\" which is a cast. Also, in the switch case 3, there's \"type *id = call(...)\" which is a declaration with type. \n\nBut looking at the specific lines in the diff: in the Source, the call is not cast. Wait, the original Source code's lines in the diff are part of the switch cases. For example, in the first diff, the original line in the Source (Candidate A) is \"id = call(id, id, id, 0x28, id);\" while Candidate B adds a (type) cast. But in the Source AST, are there casts here? Let me check the original Source code provided.\n\nLooking back at the Ground Truth, there's a line: \"type *id = (type)id;\" which is a cast. Also, in the switch case 3, there's \"type *id = call(id, id, id, (id), &id);\" which is a declaration with type. However, in the diff lines, the original code (Candidate A) doesn't have a cast on the call, but the Source might have it. Wait, the original Source code in the Ground Truth has lines like \"type *id = (type)id;\" which is a cast. However, in the diff lines, the code in the Source (the original) might not have that cast. Wait, the Ground Truth is the original code. Let me check the exact lines in the Ground Truth that correspond to the diff.\n\nIn the Ground Truth, the first diff is in the switch case 0: \"call(id, id, id); id[id] = str;\" but in the diff lines, the code is in a different part. Wait, the diff lines are in the code after the switch statements. For example, in the first diff block (line 116), the code is part of a case in a switch. Let me check the exact lines in the Ground Truth.\n\nLooking at the Ground Truth code, in the first switch case (case 0), there's a line: \"call(id, id, id); id[id] = str;\" but in the diff, the code is in a different part. Wait, the diff lines are in the code after the switch. For example, the first diff is in the code after the switch, in the lbl: block. Let me check the exact lines.\n\nIn the Ground Truth, there's a part where in the switch case 3, there's a line: \"type *id = call(id, id, id, (id), &id);\" which includes a cast in the declaration. However, in the diff lines, the code is \"id = call(...)\" without a cast. But the Source code (Ground Truth) might have that cast. Wait, the Ground Truth code in the diff lines (the parts being compared) might not have the cast. So, if Candidate B adds the (type) cast, does that match the Source's structure?\n\nAlternatively, perhaps the Source AST has a cast in those lines. For example, in the Ground Truth, there's a line: \"type *id = call(id, id, id, (id), &id);\" which is a declaration with type. However, the diff lines are about assignments, not declarations. For example, in the first diff, the code is \"id = call(...)\" which is an assignment. The Source code in that line might not have a cast. Therefore, adding the (type) cast in Candidate B might not be present in the Source, so it's not a topology match.\n\nWait, but the criteria for Topology Match is whether the '+' code (Candidate B) restores a node type present in the Source but missing in Candidate A. So, if the Source has a cast in that line, and Candidate A doesn't, but Candidate B does, then B would be the winner. However, if the Source doesn't have that cast, then it's not a match.\n\nLooking back at the Ground Truth code, the lines in the diff are:\n\nIn the first diff (around line 116), the code is part of a case in a switch. For example, in the Ground Truth, in the case 3 of the first switch, there's:\n\ntype *id = call(id, id, id, (id), &id);\nif(!id){\n  call(id, (id), str, id);\n  if(id->id.id)call(id, id->id);\n}else{\n  ...\n}\n\nBut in the diff lines, the code is:\n\nid = call(id, id, id, 0x28, id);\nid = id;\nif(id == (type)0x0){\n  call(id, 0x2000, str, id);\n\nWait, the original code (Candidate A) is \"id = call(...)\", but the Source code (Ground Truth) might have a cast here. However, in the Ground Truth code provided, the lines in the diff are part of the code. Let me check the exact lines in the Ground Truth.\n\nIn the Ground Truth code, the first diff is in the code after the switch. For example, in the first switch case (case 0), there's:\n\ncall(id, id, id);\nid[id] = str;\n\nBut the diff lines are in a different part. Wait, the diff lines are in the code after the switch. For example, in the Ground Truth, after the switch, there's a lbl: block with code. Let me check the exact lines.\n\nLooking at the Ground Truth code:\n\nIn the first switch (the one with case 0, 1, 2, etc.), after the switch, there's a lbl: and some code. Then, later, there's another switch in the lbl: block. The diff lines are in the code after the first switch. For example, the first diff is in the code after the first switch, where there's a case 3, and the code is:\n\ntype *id = call(id, id, id, (id), &id);\nif(!id){\n  call(id, (id), str, id);\n  if(id->id.id)call(id, id->id);\n}else{\n  ...\n}\n\nBut in the diff lines, the code is:\n\nid = call(id, id, id, 0x28, id);\nid = id;\nif(id == (type)0x0){\n  call(id, 0x2000, str, id);\n\nWait, this seems different. The original code (Ground Truth) might have a cast here. However, the Ground Truth code provided in the input doesn't have that exact line. The user provided the Ground Truth code, and the diff is between A and B. So, the Ground Truth is the original code, and the diff shows changes between A and B. \n\nWait, the user says that the Ground Truth is the Source AST. So, the diff is between Candidate A and B, and the Ground Truth is the original code. So, the question is: which of A or B matches the Ground Truth's structure.\n\nBut the problem is that the Ground Truth code is the original, and the diff is between A and B. So, the user is comparing the two candidates (A and B) against the Ground Truth. The user wants to know which candidate (A or B) is closer to the Ground Truth in terms of topology and complexity.\n\nBut the Ground Truth code is the original code. So, the diff is between A and B, and the user wants to know which of A or B is more aligned with the original code (Ground Truth).\n\nWait, the user says: \"Determine which version in the Diff (A or B) mirrors the Source AST topology.\"\n\nSo, the Ground Truth is the original code. The diff shows changes between A and B. The user wants to know which of A or B is closer to the original code (Ground Truth).\n\nBut the Ground Truth code is the original code, and the diff shows that A and B are two versions that differ in certain lines. So, the user is asking which of A or B is more like the original code.\n\nBut how can we determine that? The user provided the Ground Truth code, and the diff between A and B. The user wants to know which of A or B is more aligned with the Ground Truth.\n\nBut the Ground Truth code is the original code. So, the original code is the one that is correct, and the diff shows that A and B are two versions that differ from it. Wait, no. The diff is between A and B, and the Ground Truth is the original. So, the user is comparing A and B against the original to see which is closer.\n\nBut how can we know which is closer? The user provided the Ground Truth code, and the diff between A and B. So, the user is asking which of A or B is more like the original code (Ground Truth).\n\nBut the problem is that the Ground Truth code is the original, and the diff is between A and B. So, the user is asking which of A or B is closer to the original.\n\nBut how can we determine that? The user says that the Ground Truth is the Source AST. So, the original code is the Source AST. The diff between A and B is the changes between two versions. The user wants to know which of A or B is more like the original.\n\nBut without knowing which of A or B is the original, this is confusing. Wait, perhaps the Ground Truth is the original code, and the diff is between A and B, which are two versions that may have diverged from the original. The user wants to know which of A or B is closer to the original.\n\nBut how can we determine that? The user provides the Ground Truth code, and the diff between A and B. So, the user is asking which of A or B is more similar to the Ground Truth.\n\nBut the problem is that the Ground Truth code is the original code, and the diff shows that A and B differ in certain lines. So, the user is asking which of A or B is more like the original code.\n\nBut how can we compare A and B against the original code? The user has to look at the changes in the diff and see which of A or B has changes that are present in the original code.\n\nWait, the user says that the Ground Truth is the Source AST. So, the original code is the Source AST. The diff between A and B is the changes between two versions. The user wants to know which of A or B is closer to the original code.\n\nBut the user hasn't provided the original code's lines that are in the diff. Wait, the user provided the Ground Truth code, which is the original code. The diff shows that in certain lines, A and B differ. So, the user is asking which of A or B is more like the original code.\n\nBut how can we determine that? For example, if the original code has a cast in a line where A doesn't have it, but B does, then B would be closer to the original. Conversely, if the original code doesn't have the cast, then A would be closer.\n\nSo, the key is to check whether the original code (Ground Truth) has the cast that's present in B but not in A.\n\nLooking at the first diff in the Ground Truth code:\n\nIn the Ground Truth, the line is \"id = call(id, id, id, 0x28, id);\" (Candidate A) or \"id = (type)call(...)\" (Candidate B). But in the original code (Ground Truth), which one is present?\n\nWait, the user provided the Ground Truth code as the original. So, the original code's lines are the ones that are present in the Ground Truth. The diff is between A and B, which are two versions that may differ from the original.\n\nBut the user hasn't provided the original code's lines that are in the diff. Wait, the user provided the Ground Truth code, which is the original code. So, the lines in the diff (A and B) are parts of the original code. Wait, no. The diff is between A and B, and the Ground Truth is the original code. So, the user is comparing A and B against the original code.\n\nBut the user hasn't provided the original code's lines that are in the diff. Wait, the user provided the Ground Truth code, which is the original code. The diff is between A and B, which are two versions. So, the user wants to know which of A or B is more like the original code.\n\nBut how can we determine that? The user has to look at the lines in the diff and see which of A or B's lines match the original code's lines.\n\nFor example, in the first diff line:\n\nOriginal code (Ground Truth) has \"id = call(id, id, id, 0x28, id);\" (Candidate A) or \"id = (type)call(...)\" (Candidate B). But which one is present in the original code?\n\nWait, the user provided the Ground Truth code, which is the original code. So, the lines in the Ground Truth code are the original lines. The diff between A and B is the changes between two versions. So, the user is asking which of A or B is closer to the original code.\n\nBut the user hasn't provided the original code's lines that are in the diff. Wait, the user provided the Ground Truth code, which is the original code. The diff is between A and B, which are two versions. So, the user is asking which of A or B is more like the original code.\n\nBut the user hasn't provided the original code's lines that are in the diff. Wait, the user provided the Ground Truth code, which is the original code. The diff is between A and B, which are two versions. So, the user is asking which of A or B is closer to the original code.\n\nBut how can we determine that? The user has to look at the lines in the diff and compare them to the original code's lines.\n\nFor example, in the first diff line:\n\nIn the Ground Truth code (original), the line is \"id = call(id, id, id, 0x28, id);\" (Candidate A) or \"id = (type)call(...)\" (Candidate B). Which one is present in the original code?\n\nWait, the user provided the Ground Truth code as the original. So, the original code's lines are the ones that are present in the Ground Truth. The diff is between A and B, which are two versions that may differ from the original.\n\nBut the user hasn't provided the original code's lines that are in the diff. Wait, the user provided the Ground Truth code, which includes all the lines. So, the lines in the diff are part of the Ground Truth code. Therefore, the original code (Ground Truth) has the lines as they are in the Ground Truth code.\n\nWait, this is confusing. Let me re-express:\n\nThe user says that the Ground Truth is the Source AST. The diff is between Candidate A and Candidate B. The user wants to know which of A or B is more like the Source AST (Ground Truth).\n\nBut the Ground Truth code is the original code. So, the lines in the Ground Truth code are the original lines. The diff between A and B shows that in certain lines, A and B differ. The user wants to know which of A or B is closer to the original code.\n\nBut how can we determine that? The user must compare the lines in A and B against the original code's lines.\n\nFor example, in the first diff line:\n\nIn the Ground Truth code, the line is \"id = call(id, id, id, 0x28, id);\" (Candidate A) or \"id = (type)call(...)\" (Candidate B). But which one is present in the original code?\n\nWait, the user provided the Ground Truth code, which includes all the lines. So, the original code's lines are the ones that are present in the Ground Truth. Therefore, the lines in the diff (A and B) are parts of the Ground Truth code. Wait, no. The diff is between A and B, which are two versions that may differ from the original code.\n\nWait, perhaps the user is saying that the Ground Truth is the original code, and the diff shows the changes between A and B. So, the user is asking which of A or B is closer to the original code.\n\nBut without knowing which of A or B is the original, this is tricky. However, the user is asking which of A or B mirrors the Source AST (Ground Truth) topology.\n\nSo, the user is asking which of A or B is more like the original code (Ground Truth). To determine that, we need to see which of A or B's changes are present in the original code.\n\nFor example, if in the original code, the line is \"id = (type)call(...)\", then Candidate B would match, and Candidate A would not. Conversely, if the original code has \"id = call(...)\", then Candidate A would match.\n\nBut the user provided the Ground Truth code, which includes all the lines. So, the lines in the diff are part of the Ground Truth code. Therefore, the original code (Ground Truth) has the lines as they are in the Ground Truth code. Therefore, the diff between A and B is showing changes from the original code.\n\nWait, this is getting too tangled. Let's take a step back.\n\nThe user is comparing two versions (A and B) of the code against the original (Ground Truth) to see which is closer. The diff shows the changes"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 + 1];\n  type id[64 + 1];\n  type *id = null;\n  type id = 0;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id++;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 5:\n        {\n          id = id;\n        }\n        break;\n        case 6:\n        {\n          id = id - id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id++;\n              }\n            }\n          }\n          break;\n          case 4:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case 6:\n          {\n            id = id - id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id - id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = (type)call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = (type)call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.34375,
          "base_ppl": 1.859375,
          "pr_ppl": 1.859375,
          "source_ast_ppl": 2.234375,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "The logic flow and control structures are identical between Candidate A and B. The only difference is an explicit cast to (char *) in Candidate B, which does not alter the control flow or readability. Since the logic is identical, the Tie-Breaker rule applies, and Candidate A is chosen for having less artificial code (no redundant cast).",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A aligns with the Source Code structure by preserving the correct type handling of bsearch() results. The Source Code uses varlookup_t* without casting to char*, while Candidate B introduces a (char *) cast that diverges from the original type safety and structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores explicit type casting nodes ((type)call(...)) present in the Source AST, which are absent in Candidate A. The Source contains multiple cast operations (e.g., (type)id), and Candidate B aligns with this topology by reintroducing these casts. Both versions share identical nesting depth in the modified regions, so topology match is the decisive factor.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 * 4 + 1];\n  type id = 0;\n  type *id = null;\n  type id = 0;\n  type id = 1024 + id;\n  type *id = null;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id - 1;\n            while(id >= id && call(id->id, id) == 0){\n              id = id;\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              id = id;\n              id++;\n            }\n            for(id = id;  id <= id; id++){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          if((*id) != str){\n            type id = (*id) - str;\n            if(id <= (id - id) / 10){\n              id = 10 * id + id;\n            }else{\n              {\n                id++;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case 5:\n        {\n          id = 0;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id - 1;\n              while(id >= id && call(id->id, id) == 0){\n                id = id;\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                id = id;\n                id++;\n              }\n              for(id = id;  id <= id; id++){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id - id), (type)(id - id), (type)(id - id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = (type)call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = (type)call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.4375,
          "base_ppl": 2.0625,
          "pr_ppl": 2.046875,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.34375,
          "pr_ast_ppl": 2.34375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A preserves the original bsearch call without unnecessary casting, aligning closer with the source code's structure which directly assigns the bsearch result to a varlookup_t* pointer. Candidate B introduces a redundant (char *) cast that does not exist in the source, diverging from the original type handling.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate A avoids adding redundant type casts that do not align with high-level semantic structures. The changes in Candidate B introduce explicit casting around function calls, which may obscure the original intent or add unnecessary complexity. Since the diff does not introduce clearer control flow constructs (e.g., loops, switches) or reduce spaghetti-like logic, Candidate A maintains a cleaner, more idiomatic structure by preserving the original logic without artificial nesting.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores explicit type casts (e.g., `(type)call(...)`) present in the Source AST but missing in Candidate A. The Source contains multiple `(type)` casts (e.g., `type *id = (type)id;`), and Candidate B's changes explicitly add these casts, aligning with the Source's topology. Candidate A lacks these casts, which are critical structural elements in the original AST.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 * 4 + 1];\n  type id = 0;\n  type *id = null;\n  type id = 0;\n  type id = 1024 + id;\n  type *id = null;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id - 1;\n            while(id >= id && call(id->id, id) == 0){\n              id = id;\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              id = id;\n              id++;\n            }\n            for(id = id;  id <= id; id++){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          if((*id) != str){\n            type id = (*id) - str;\n            if(id <= (id - id) / 10){\n              id = 10 * id + id;\n            }else{\n              {\n                id++;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case 5:\n        {\n          id = 0;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id - 1;\n              while(id >= id && call(id->id, id) == 0){\n                id = id;\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                id = id;\n                id++;\n              }\n              for(id = id;  id <= id; id++){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id - id), (type)(id - id), (type)(id - id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = (type)call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = (type)call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.4375,
          "base_ppl": 2.0625,
          "pr_ppl": 2.046875,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.34375,
          "pr_ast_ppl": 2.34375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by explicitly casting the result of bsearch to (char *), making the code's intent clearer. While both versions use the comma operator in conditions (a potential graph artifact), Candidate B's explicit cast aligns with human engineering by reducing ambiguity in type handling, even if the control flow structure remains unchanged.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A preserves the original bsearch call without unnecessary casting, aligning with the source code's use of bsearch returning a void* that is implicitly cast to varlookup_t*. Candidate B's explicit (char *) cast introduces a type mismatch compared to the source structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Both candidates maintain identical control flow structures (e.g., `do-while`, `if` conditions). The changes in Candidate B involve redundant type casting, which does not improve semantic clarity or reduce artificial nesting. Since the logic and nesting depth are identical, Candidate A avoids unnecessary syntactic embellishment, aligning better with idiomatic design principles.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores explicit type casts (e.g., `(type)call(...)`) present in the Source AST, which are absent in Candidate A. These casts are critical structural elements in the Ground Truth, aligning B's topology with the original code's node types and nesting complexity.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 + 1];\n  type id[64 + 1];\n  type *id = null;\n  type id = 0;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id++;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 5:\n        {\n          id = id;\n        }\n        break;\n        case 6:\n        {\n          id = id - id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id++;\n              }\n            }\n          }\n          break;\n          case 4:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case 6:\n          {\n            id = id - id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id - id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[8192];\n  type id;\n  type *id;\n  type id[79];\n  type id[9];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + (type)id;\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)*(type)(id + (type)id * 2);\n    id = (id) * (type)(id + (type)id * 2);\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] + 0x2c];\n      id = &id + (type)(type)id[id];\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id == (type)0x0){\n              call(id, 0x2000, str, id);\n              if(*(type)(id + 0x30) != 0){\n                call(id, *(type)(id + 0x50));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id + -0x28;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id;\n              }\n            }\n            break;\n          case 4:\n            call(id, id, id);\n            id[id] = 0;\n            break;\n          case 5:\n            id = id;\n            break;\n          case 6:\n            id = (type)id - (type)id;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] + 0x2c];\n    id = &id + (type)(type)id[id];\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, 0x28, id);\n        id = id;\n        if(id == (type)0x0){\n          call(id, 0x2000, str, id);\n          if(*(type)(id + 0x30) != 0){\n            call(id, *(type)(id + 0x50));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id + -0x28;\n          }\n          while(bool){\n            id = id + 0x28;\n            id = bool;\n            if(((type)id - (type)id) / 0x28 < (type)id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = 0;\n      }elseif(id == str){\n        id = (type)id - (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, (type)id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[8192];\n  type id;\n  type *id;\n  type id[79];\n  type id[9];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + (type)id;\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)*(type)(id + (type)id * 2);\n    id = (id) * (type)(id + (type)id * 2);\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] + 0x2c];\n      id = &id + (type)(type)id[id];\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = (type)call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id == (type)0x0){\n              call(id, 0x2000, str, id);\n              if(*(type)(id + 0x30) != 0){\n                call(id, *(type)(id + 0x50));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id + -0x28;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id;\n              }\n            }\n            break;\n          case 4:\n            call(id, id, id);\n            id[id] = 0;\n            break;\n          case 5:\n            id = id;\n            break;\n          case 6:\n            id = (type)id - (type)id;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] + 0x2c];\n    id = &id + (type)(type)id[id];\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = (type)call(id, id, (type)id, 0x28, id);\n        id = id;\n        if(id == (type)0x0){\n          call(id, 0x2000, str, id);\n          if(*(type)(id + 0x30) != 0){\n            call(id, *(type)(id + 0x50));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id + -0x28;\n          }\n          while(bool){\n            id = id + 0x28;\n            id = bool;\n            if(((type)id - (type)id) / 0x28 < (type)id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = 0;\n      }elseif(id == str){\n        id = (type)id - (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, (type)id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.34375,
          "base_ppl": 1.8046875,
          "pr_ppl": 1.796875,
          "source_ast_ppl": 2.234375,
          "base_ast_ppl": 2.078125,
          "pr_ast_ppl": 2.0625,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Both versions have identical control flow and logic structure. The only difference is a type cast added in Candidate B. Since the logic is identical and the tie-breaker favors less artificial nesting (which is unchanged between versions), Candidate A is preferred for its brevity and lack of redundant type casting.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A aligns more closely with the Source Code structure as the cast to (char *) in Candidate B introduces a type transformation not present in the original code. The source code uses varlookup_t * for bsearch results, while both versions incorrectly treat the result as a char pointer. The change in Candidate B does not correct this discrepancy but adds unnecessary casting, moving away from the original structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 * 4 + 1];\n  type id = 0;\n  type *id = null;\n  type id = 0;\n  type id = 1024 + id;\n  type *id = null;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id - 1;\n            while(id >= id && call(id->id, id) == 0){\n              id = id;\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              id = id;\n              id++;\n            }\n            for(id = id;  id <= id; id++){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          if((*id) != str){\n            type id = (*id) - str;\n            if(id <= (id - id) / 10){\n              id = 10 * id + id;\n            }else{\n              {\n                id++;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case 5:\n        {\n          id = 0;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id - 1;\n              while(id >= id && call(id->id, id) == 0){\n                id = id;\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                id = id;\n                id++;\n              }\n              for(id = id;  id <= id; id++){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id - id), (type)(id - id), (type)(id - id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + 0x400;\n  id = id + id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id + (type)(type)(type)id[id] + 1;\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id != (type)0x0){\n              while(bool){\n                id = id + -0x28;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id + 0x28){\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n              }\n            }\n            break;\n          case 4:\n            if(*id != 0){\n              if((-call(*id - 0x30) - 1) / 10 < id){\n                id = id + 1;\n                goto lbl;\n              }\n              id = id * 10 + call(*id - 0x30);\n            }\n            break;\n          case 5:\n            id = 0;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id + (type)(type)(type)id[id] + 1;\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        while(bool){\n          id = id + -0x28;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id + 0x28;\n          id = bool;\n          if(((type)id - (type)id) / 0x28 < (type)id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id + 0x28){\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)id, str, (type)id - (type)id, (type)id - (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + 0x400;\n  id = id + id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id + (type)(type)(type)id[id] + 1;\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = (type)call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id != (type)0x0){\n              while(bool){\n                id = id + -0x28;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id + 0x28){\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n              }\n            }\n            break;\n          case 4:\n            if(*id != 0){\n              if((-call(*id - 0x30) - 1) / 10 < id){\n                id = id + 1;\n                goto lbl;\n              }\n              id = id * 10 + call(*id - 0x30);\n            }\n            break;\n          case 5:\n            id = 0;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id + (type)(type)(type)id[id] + 1;\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = (type)call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        while(bool){\n          id = id + -0x28;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id + 0x28;\n          id = bool;\n          if(((type)id - (type)id) / 0x28 < (type)id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id + 0x28){\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)id, str, (type)id - (type)id, (type)id - (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.4375,
          "base_ppl": 1.84375,
          "pr_ppl": 1.8359375,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.015625,
          "pr_ast_ppl": 2.015625,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate A avoids explicit type casting in the bsearch result, maintaining conciseness and reducing unnecessary syntactic noise. The control flow remains identical between versions, and Candidate A's lack of redundant casts aligns with the tie-breaker rule of preferring less artificial nesting/depth.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A preserves the original bsearch call without unnecessary casting, aligning with the source code's use of varlookup_t pointers. Candidate B introduces a (char *) cast that diverges from the source's type semantics.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[0].id == id)return id;\n  type id = 0;\n  type id = bool;\n  type id = bool;\n  type id = 0;\n  do{\n    type id;\n    for(id = 0;  id[id].id != id[id].id; ++id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[++id].id != id);\n  if(id > id || !id || id > 3)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if(id != (type)0x0){\n    id = *id;\n    if(id != -1){\n      id = 0;\n      id = 0;\n      id = 8;\n      id = bool;\n      do{\n        id = id + 2;\n        id = 1;\n        id = bool;\n        switch(id){\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 0xb:\n            id = bool;\n            id = 0;\n            break;\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x18:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n            goto lbl;\n          case 0x21:\n            break;\n          case def:\n            id = 1;\n            id = bool;\n            if(1 < id + 0xbfffffffffffffffU)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id + id;\n        id = id + 1;\n        id = *id;\n        id = id;\n      }while(id != -1);\n      if((id == 1 && id < 5) && (id < 4)){\n        *id = id;\n        id = 0;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if(id != (type)0x0){\n    id = *id;\n    if(id != -1){\n      id = id + 2;\n      id = 0;\n      id = 0;\n      id = 8;\n      id = bool;\n      do{\n        id = 1;\n        id = bool;\n        switch(id){\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 0xb:\n            id = bool;\n            id = 0;\n            break;\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x18:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n            goto lbl;\n          case 0x21:\n            break;\n          case def:\n            id = 1;\n            id = bool;\n            if(1 < id + 0xbfffffffffffffffU)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id + id;\n        id = id + 1;\n        id = *id;\n        id = id + 2;\n        id = id;\n      }while(id != -1);\n      if((id == 1 && id < 5) && (id < 4)){\n        *id = id;\n        id = 0;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.59375,
          "base_ppl": 1.953125,
          "pr_ppl": 1.90625,
          "source_ast_ppl": 5.1875,
          "base_ast_ppl": 2.4375,
          "pr_ast_ppl": 2.4375,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "motivation": "Candidate A maintains a clear do-while loop structure with the increment inside the loop body, which aligns with idiomatic C control flow patterns. Candidate B moves the increment outside the loop, disrupting the loop's natural progression and creating potential ambiguity in how param_1 is updated. The original structure preserves a logical, nested flow that reflects human reasoning about iterative processing.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A retains the original loop structure using an index variable (i) and avoids pointer arithmetic, aligning more closely with the source code's use of a do-while loop with index increment. Candidate B introduces pointer arithmetic (param_1 += 2), which diverges from the source's explicit index-based iteration.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[0].id == id)return id;\n  type id = 0;\n  type id = bool;\n  type id = bool;\n  type id = 0;\n  do{\n    type id;\n    for(id = 0;  id[id].id != id[id].id; ++id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[++id].id != id);\n  if(id > id || !id || id > 3)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if(id != (type)0x0){\n    id = *id;\n    if(id != -1){\n      id = 0;\n      id = 0;\n      id = 8;\n      id = bool;\n      do{\n        id = id + 2;\n        id = 1;\n        id = bool;\n        switch(id){\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 0xb:\n            id = bool;\n            id = 0;\n            break;\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x18:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n            goto lbl;\n          case 0x21:\n            break;\n          case def:\n            id = 1;\n            id = bool;\n            if(1 < id + 0xbfffffffffffffffU)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id + id;\n        id = id + 1;\n        id = *id;\n        id = id;\n      }while(id != -1);\n      if((id == 1 && id < 5) && (id < 4)){\n        *id = id;\n        id = 0;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if(id != (type)0x0){\n    id = *id;\n    if(id != -1){\n      id = id + 2;\n      id = 0;\n      id = 0;\n      id = 8;\n      id = bool;\n      do{\n        id = 1;\n        id = bool;\n        switch(id){\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 0xb:\n            id = bool;\n            id = 0;\n            break;\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x18:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n            goto lbl;\n          case 0x21:\n            break;\n          case def:\n            id = 1;\n            id = bool;\n            if(1 < id + 0xbfffffffffffffffU)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id + id;\n        id = id + 1;\n        id = *id;\n        id = id + 2;\n        id = id;\n      }while(id != -1);\n      if((id == 1 && id < 5) && (id < 4)){\n        *id = id;\n        id = 0;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.59375,
          "base_ppl": 1.953125,
          "pr_ppl": 1.90625,
          "source_ast_ppl": 5.1875,
          "base_ast_ppl": 2.4375,
          "pr_ast_ppl": 2.4375,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A preserves the loop increment inside the do-while structure, aligning with the original source's iteration pattern. Candidate B moves the increment outside the loop, disrupting the structural isomorphism with the source code's loop logic.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate A retains the original structure without introducing new node types like 'switch' present in B. The Source AST does not contain a 'switch' statement, so B's addition of it diverges from the original topology. A maintains the original nesting and node types, aligning more closely with the Ground Truth.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_zmagic-O2.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type *id = null;\n  type id, id;\n  type *id;\n  type *id;\n  type id, id, id = 0;\n  type id = id->id & id;\n  type id = id->id;\n  type *id = call(id unsigned char id->id);\n  type id = id->id;\n  type id = 0;\n  type id;\n  if((id->id & id) == 0)return 0;\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, -1, null, id, id, id);\n        if(id == -1)goto lbl;\n        id = 1;\n        if((id->id & id) != 0)goto lbl;\n        if(id != id && id != 0)goto lbl;\n        if((call(id, (id ? str : str))) == -1)goto lbl;\n        if((id = call(id)) == null)goto lbl;\n        if(call(id, -1, null, null, id, id) == -1){\n          if(call(id, id) != null)call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != null){\n          if(call(id, str, id) == -1){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, str) == -1)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = -1;\n        break;\n    }\n  }\n  lbl:\n  call(str, id);\n  if(id && id.id != id)(type)call(id, &id, null);\n  call(id);\n  id->id = id;\n  call(str, id);\n  return id;\n}",
        "base_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < 0){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "pr_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(0 < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.5625,
          "base_ppl": 2.640625,
          "pr_ppl": 2.625,
          "source_ast_ppl": 4.28125,
          "base_ast_ppl": 3.109375,
          "pr_ast_ppl": 3.109375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B's condition '0 < (int)uVar1' is more intuitive and directly expresses the intent of checking if uVar1 is non-zero. The original condition in A relies on negation and signed/unsigned conversion, which is less straightforward. B avoids the cognitive overhead of interpreting a negated value and directly compares to zero, aligning with human-like logical clarity.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B's condition `if (0 < (int)uVar1)` is logically equivalent to Candidate A's `if ((int)-uVar1 < 0)`, as both check whether `uVar1` is positive. Since the logic is preserved and no structural elements (e.g., `switch`, `for`) are involved, the change does not regress the code but aligns with equivalent control flow.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate B simplifies the condition to a direct comparison (0 < (type)id), which is more intuitive and aligns with idiomatic human-readable checks. The original condition ((type)-id < 0) requires mental inversion of the negation, making it less straightforward. Since both versions are logically equivalent, B's direct comparison is preferred as it reduces cognitive overhead.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_zmagic-O3.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type *id = null;\n  type id, id;\n  type *id;\n  type *id;\n  type id, id, id = 0;\n  type id = id->id & id;\n  type id = id->id;\n  type *id = call(id unsigned char id->id);\n  type id = id->id;\n  type id = 0;\n  type id;\n  if((id->id & id) == 0)return 0;\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, -1, null, id, id, id);\n        if(id == -1)goto lbl;\n        id = 1;\n        if((id->id & id) != 0)goto lbl;\n        if(id != id && id != 0)goto lbl;\n        if((call(id, (id ? str : str))) == -1)goto lbl;\n        if((id = call(id)) == null)goto lbl;\n        if(call(id, -1, null, null, id, id) == -1){\n          if(call(id, id) != null)call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != null){\n          if(call(id, str, id) == -1){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, str) == -1)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = -1;\n        break;\n    }\n  }\n  lbl:\n  call(str, id);\n  if(id && id.id != id)(type)call(id, &id, null);\n  call(id);\n  id->id = id;\n  call(str, id);\n  return id;\n}",
        "base_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < 0){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "pr_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(0 < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.5625,
          "base_ppl": 2.640625,
          "pr_ppl": 2.625,
          "source_ast_ppl": 4.28125,
          "base_ast_ppl": 3.109375,
          "pr_ast_ppl": 3.109375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B's condition (0 < (int)uVar1) directly expresses the intent of checking if uVar1 is positive, which is more intuitive and readable. Candidate A's condition ((int)-uVar1 < 0) relies on a mathematical equivalence that requires deeper analysis to understand, making it less aligned with human-like abstraction.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "motivation": "Candidate B simplifies the condition to directly check if 'id' is positive, which is more intuitive and aligns with natural human logic. The original condition in A uses a negated comparison ((type)-id < 0) that requires extra cognitive effort to parse, while B's '0 < (type)id' directly expresses the intent without unnecessary negation.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "Candidate B's condition '0 < (type)id' aligns with the Source's use of type-cast comparisons (e.g., 'if((type)-id < 0)') and preserves the logical structure of checking signed/unsigned values, which is consistent with the Source's complex control flow. Candidate A's negated comparison introduces a structural deviation.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O0.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "function_pr": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id = 0;\n  type id = id;\n  type *id = id->id;\n  type *id = call(1, (id));\n  type *id = call(1, (id));\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id > 0)id->id = id->id;\n  if(call(id, id->id) == -1){\n    id = id;\n    goto lbl;\n  }\n  if((id->id = call(0, id, id->id)) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if(call(0, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id, id, id->id.id, id)) != id){\n    goto lbl;\n  }\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = call() ^ id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = (id->id ? 8 : 4);\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id == null){\n    id->id = id->id;\n  }\n  if((id->id = call(id->id)) == null){\n    id = id;\n    goto lbl;\n  }\n  if(id->id && id->id && call(id->id, id->id) != 0){\n    type id = call(id->id, id->id);\n    if(id == (id) - 1){\n      id = id;\n      goto lbl;\n    }\n    id->id = id;\n  }\n  if((id = call(id->id, (id->id), id->id, (id->id), id->id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, &id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, id)) != id){\n    goto lbl;\n  }\n  if(call(id->id, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, 0)) != id){\n    goto lbl;\n  }\n  if(id->id.id && id->id != id->id){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  lbl:\n  call(id->id);\n  if(id == id || id == id || id == id){\n    if(id->id.id){\n      call(id->id, (id->id), str, call(id), id, call(id), id);\n      call(id->id, id);\n    }\n  }\n  if(id)call(id);\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = *(type)((type)id + 0x40);\n  id = id;\n  id = id;\n  id = id;\n  id = call(1, 0xdd0);\n  id = call(1, 0x180);\n  call(id, id, 0x40);\n  *(type)((type)id + 0x120) = *(type)((type)id + 0x48);\n  *(type)((type)id + 0x128) = *(type)((type)id + 0x50);\n  *(type)((type)id + 0x58) = id;\n  *(type)((type)id + 0x60) = *(type)((type)id + 0x40);\n  *(type)((type)id + 0x80) = (type)*(type)((type)id + 0x58);\n  if(0 < *(type)((type)id + 0x60)){\n    *(type)((type)id + 0x84) = (type)*(type)((type)id + 0x60);\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n  }else{\n    id = call(0, 2, id[5]);\n    *(type)((type)id + 0x40) = id;\n    if(id == -1){\n      id = 0xf;\n      if(*(type)((type)id + 0x30) != 0){\n        call((type)((type)id + 0x5ce), 0x800, str);\n        call((type)id + 0x5ce, *(type)((type)id + 0x58));\n      }\n    }else{\n      id = call(0, 0, id[5]);\n      if(id == -1){\n        id = 0xf;\n        if(*(type)((type)id + 0x30) != 0){\n          call((type)((type)id + 0x5ce), 0x800, str);\n          call((type)id + 0x5ce, *(type)((type)id + 0x58));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id + 0x30), id);\n        if(id == 0){\n          *(type)((type)id + 0x4c) = id[1];\n          *(type)((type)id + 0x48) = *id;\n          *(type)((type)id + 0x50) = id[2];\n          id = call();\n          *(type)((type)id + 0x68) = id ^ *id;\n          *(type)((type)id + 0x88) = *(type)(id + 0x10);\n          *(type)((type)id + 0x90) = *(type)(id + 0xe);\n          *(type)((type)id + 0x98) = *(type)(id + 8);\n          *(type)((type)id + 0xb0) = *(type)(id + 10);\n          *(type)((type)id + 0xc0) = *(type)(id + 0xc);\n          id = 4;\n          if(*(type)((type)id + 0x4c) != 0){\n            id = 8;\n          }\n          *(type)((type)id + 0xb8) = (type)id;\n          *(type)((type)id + 0x138) = *(type)(id + 0x12);\n          *(type)((type)id + 0x140) = *(type)(id + 0x14);\n          *(type)((type)id + 0x148) = id[3];\n          if(*(type)((type)id + 0x120) == 0){\n            *(type)((type)id + 0x120) = *(type)(id + 0x5e);\n          }\n          id = call(*(type)((type)id + 0x98));\n          *(type)((type)id + 0xa0) = id;\n          if(id == 0){\n            id = 3;\n          }else{\n            if(((*(type)((type)id + 0x120) != 0) && (*(type)((type)id + 0x128) != 0)) && (id = call(*(type)((type)id + 0x120), *(type)((type)id + 0x128))id != 0)){\n              id = call(*(type)((type)id + 0x128), *(type)((type)id + 0x120));\n              if(id == (type)0xffffffffffffffff){\n                id = 7;\n                goto lbl;\n              }\n              *(type)((type)id + 0x130) = id;\n            }\n            id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, *(type)((type)id + 0x130));\n            if(((id == 0) && (id = call(id, &id)id == 0)) && (id = call(id, id)id == 0)){\n              id = call(*(type)((type)id + 0x88), 0, id[5]);\n              if(id == -1){\n                id = 0xf;\n                if(*(type)((type)id + 0x30) != 0){\n                  call((type)((type)id + 0x5ce), 0x800, str, *(type)((type)id + 0x88));\n                  call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                }\n              }else{\n                id = call(id);\n                if((id == 0) && (id = call(id, 0)id == 0)){\n                  if((*(type)((type)id + 0x20) == 0) || (*(type)((type)id + 0x78) == *(type)((type)id + 0x80))){\n                    id = call(id);\n                  }else{\n                    id = 9;\n                    if(*(type)((type)id + 0x30) != 0){\n                      call((type)((type)id + 0x5ce), 0x800, str, (id) * (type)((type)id + 0x80), (id) * (type)((type)id + 0x78));\n                      call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[5]);\n  if((((id == 1) || (id == 2)) || (id == 0xf)) && (*(type)((type)id + 0x30) != 0)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id + 0x5ce), 0x800, str, id, (type)id, id, *id);\n    call((type)id + 0x5ce, id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = *(type)((type)id + 0x40);\n  id = id;\n  id = id;\n  id = id;\n  id = call(1, 0xdd0);\n  id = (type)call(1, 0x180);\n  call(id, id, 0x40);\n  *(type)((type)id + 0x120) = *(type)((type)id + 0x48);\n  *(type)((type)id + 0x128) = *(type)((type)id + 0x50);\n  *(type)((type)id + 0x58) = id;\n  *(type)((type)id + 0x60) = *(type)((type)id + 0x40);\n  *(type)((type)id + 0x80) = (type)*(type)((type)id + 0x58);\n  if(0 < *(type)((type)id + 0x60)){\n    *(type)((type)id + 0x84) = (type)*(type)((type)id + 0x60);\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n  }else{\n    id = call(0, 2, id[5]);\n    *(type)((type)id + 0x40) = id;\n    if(id == -1){\n      id = 0xf;\n      if(*(type)((type)id + 0x30) != 0){\n        call((type)((type)id + 0x5ce), 0x800, str);\n        call((type)id + 0x5ce, *(type)((type)id + 0x58));\n      }\n    }else{\n      id = call(0, 0, id[5]);\n      if(id == -1){\n        id = 0xf;\n        if(*(type)((type)id + 0x30) != 0){\n          call((type)((type)id + 0x5ce), 0x800, str);\n          call((type)id + 0x5ce, *(type)((type)id + 0x58));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id + 0x30), id);\n        if(id == 0){\n          *(type)((type)id + 0x4c) = id[1];\n          *(type)((type)id + 0x48) = *id;\n          *(type)((type)id + 0x50) = id[2];\n          id = call();\n          *(type)((type)id + 0x68) = id ^ *id;\n          *(type)((type)id + 0x88) = *(type)(id + 0x10);\n          *(type)((type)id + 0x90) = *(type)(id + 0xe);\n          *(type)((type)id + 0x98) = *(type)(id + 8);\n          *(type)((type)id + 0xb0) = *(type)(id + 10);\n          *(type)((type)id + 0xc0) = *(type)(id + 0xc);\n          id = 4;\n          if(*(type)((type)id + 0x4c) != 0){\n            id = 8;\n          }\n          *(type)((type)id + 0xb8) = (type)id;\n          *(type)((type)id + 0x138) = *(type)(id + 0x12);\n          *(type)((type)id + 0x140) = *(type)(id + 0x14);\n          *(type)((type)id + 0x148) = id[3];\n          if(*(type)((type)id + 0x120) == 0){\n            *(type)((type)id + 0x120) = *(type)(id + 0x5e);\n          }\n          id = call(*(type)((type)id + 0x98));\n          *(type)((type)id + 0xa0) = id;\n          if(id == 0){\n            id = 3;\n          }else{\n            if(((*(type)((type)id + 0x120) != 0) && (*(type)((type)id + 0x128) != 0)) && (id = call(*(type)((type)id + 0x120), *(type)((type)id + 0x128))id != 0)){\n              id = call(*(type)((type)id + 0x128), *(type)((type)id + 0x120));\n              if(id == (type)0xffffffffffffffff){\n                id = 7;\n                goto lbl;\n              }\n              *(type)((type)id + 0x130) = id;\n            }\n            id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, *(type)((type)id + 0x130));\n            if(((id == 0) && (id = call(id, &id)id == 0)) && (id = call(id, id)id == 0)){\n              id = call(*(type)((type)id + 0x88), 0, id[5]);\n              if(id == -1){\n                id = 0xf;\n                if(*(type)((type)id + 0x30) != 0){\n                  call((type)((type)id + 0x5ce), 0x800, str, *(type)((type)id + 0x88));\n                  call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                }\n              }else{\n                id = call(id);\n                if((id == 0) && (id = call(id, 0)id == 0)){\n                  if((*(type)((type)id + 0x20) == 0) || (*(type)((type)id + 0x78) == *(type)((type)id + 0x80))){\n                    id = call(id);\n                  }else{\n                    id = 9;\n                    if(*(type)((type)id + 0x30) != 0){\n                      call((type)((type)id + 0x5ce), 0x800, str, (id) * (type)((type)id + 0x80), (id) * (type)((type)id + 0x78));\n                      call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[5]);\n  if((((id == 1) || (id == 2)) || (id == 0xf)) && (*(type)((type)id + 0x30) != 0)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id + 0x5ce), 0x800, str, id, (type)id, id, *id);\n    call((type)id + 0x5ce, id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.25,
          "base_ppl": 1.875,
          "pr_ppl": 1.890625,
          "source_ast_ppl": 2.046875,
          "base_ast_ppl": 1.9921875,
          "pr_ast_ppl": 1.9921875,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate A avoids an unnecessary explicit cast from void* to uint*, which is redundant in C since void* can be implicitly assigned to any pointer type. This keeps the code simpler and more idiomatic, aligning with the principle of minimizing artificial complexity. The logic flow remains identical, and Candidate A has less syntactic overhead.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A aligns better with the source structure by avoiding an unnecessary cast to 'uint *' which is not present in the original code. The source uses 'calloc' without explicit type casting, and Candidate B introduces a type conversion that diverges from the original code's structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "The structural change in Candidate B introduces an explicit type cast, which does not alter the control flow skeleton but adds a layer of type-specific logic. Since the control flow remains identical between both candidates (a simple assignment), the tie-breaker rule applies. Candidate A avoids artificial type casting, maintaining a more concise and less verbose structure, which aligns better with idiomatic design principles by minimizing unnecessary explicitness.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O2.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "function_pr": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = (undefined8 *)calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id = 0;\n  type id = id;\n  type *id = id->id;\n  type *id = call(1, (id));\n  type *id = call(1, (id));\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id > 0)id->id = id->id;\n  if(call(id, id->id) == -1){\n    id = id;\n    goto lbl;\n  }\n  if((id->id = call(0, id, id->id)) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if(call(0, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id, id, id->id.id, id)) != id){\n    goto lbl;\n  }\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = call() ^ id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = (id->id ? 8 : 4);\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id == null){\n    id->id = id->id;\n  }\n  if((id->id = call(id->id)) == null){\n    id = id;\n    goto lbl;\n  }\n  if(id->id && id->id && call(id->id, id->id) != 0){\n    type id = call(id->id, id->id);\n    if(id == (id) - 1){\n      id = id;\n      goto lbl;\n    }\n    id->id = id;\n  }\n  if((id = call(id->id, (id->id), id->id, (id->id), id->id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, &id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, id)) != id){\n    goto lbl;\n  }\n  if(call(id->id, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, 0)) != id){\n    goto lbl;\n  }\n  if(id->id.id && id->id != id->id){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  lbl:\n  call(id->id);\n  if(id == id || id == id || id == id){\n    if(id->id.id){\n      call(id->id, (id->id), str, call(id), id, call(id), id);\n      call(id->id, id);\n    }\n  }\n  if(id)call(id);\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type id){\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = (type)id[8];\n  id = call(1, 0xdd0);\n  id = call(1, 0x180);\n  id = id[1];\n  *id = *id;\n  id[1] = id;\n  id[2] = id[2];\n  id[3] = id[3];\n  id[4] = id[4];\n  id[5] = id[5];\n  id[6] = id[6];\n  id[7] = id[7];\n  id[0x24] = id[9];\n  id[0x25] = id[10];\n  id[0xb] = id;\n  id[0xc] = id;\n  *(type)(id + 0x10) = *(type)(id + 0xb);\n  if(0 < (type)id[0xc]){\n    *(type)((type)id + 0x84) = (type)id[0xc];\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n    lbl:\n    call(id[5]);\n    id = id[6];\n    lbl:\n    if(id != 0){\n      id = call(id);\n      id = call();\n      id = id;\n      id = call(*id);\n      call((type)((type)id + 0x5ce), 0x800, str, id, id, id, *id);\n      id = id;\n      call((type)((type)id + 0x5ce), id);\n    }\n  }else{\n    id = call(0, 2, id[5]);\n    id[8] = id;\n    if(id == -1){\n      id = 0xf;\n      if((type)id[6] != (type)0x0){\n        *(type)((type)id + 0x5ee) = 0x656c696620666f;\n        *(type)((type)id + 0x5e6) = 0x20646e65206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(0, 0, id[5]);\n    id = (type)id[6];\n    if(id == -1){\n      id = 0xf;\n      if(id != (type)0x0){\n        *(type)((type)id + 0x5f4) = 0x656c696620666f;\n        *(type)((type)id + 0x5ee) = 0x666f20676e696e6e;\n        *(type)((type)id + 0x5e6) = 0x69676562206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(id, id, id, id);\n    id = (type)id;\n    if(id == 0){\n      *(type)((type)id + 0x4c) = id[1];\n      *(type)(id + 9) = *id;\n      *(type)(id + 10) = id[2];\n      id = call();\n      *(type)(id + 0xd) = id ^ *id;\n      id[0x11] = *(type)(id + 0x10);\n      id[0x12] = *(type)(id + 0xe);\n      id[0x13] = *(type)(id + 8);\n      id[0x16] = *(type)(id + 10);\n      id[0x18] = *(type)(id + 0xc);\n      id[0x17] = call(*(type)((type)id + 0x4c) != 0) * 4 + 4;\n      id[0x27] = *(type)(id + 0x12);\n      id[0x28] = *(type)(id + 0x14);\n      *(type)(id + 0x29) = id[3];\n      if(id[0x24] == 0){\n        id[0x24] = *(type)(id + 0x5e);\n      }\n      id = call();\n      id[0x14] = id;\n      if(id == 0){\n        id = 3;\n        lbl:\n        call(id[5]);\n        call(id);\n        goto lbl;\n      }\n      id = (type)id[0x24];\n      if(((id != (type)0x0) && (id = (type)id[0x25]id != (type)0x0)) && (id = call(id, id)id != 0)){\n        id = call(id, id);\n        if(id == (type)0xffffffffffffffff){\n          id = 7;\n          goto lbl;\n        }\n        id[0x26] = id;\n      }\n      id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, id[0x26]);\n      id = (type)id;\n      if(id == 0){\n        id = call(id, &id);\n        id = (type)id;\n        if(id == 0){\n          id = call(id, id);\n          id = (type)id;\n          if(id == 0){\n            id = call(id[0x11], 0, id[5]);\n            if(id == -1){\n              id = 0xf;\n              if(id[6] != 0){\n                call((type)((type)id + 0x5ce), 0x800, str, id[0x11]);\n                id = 0xf;\n                call((type)((type)id + 0x5ce), id[0xb]);\n              }\n              goto lbl;\n            }\n            id = call(id);\n            id = (type)id;\n            if(id == 0){\n              id = call(id, 0);\n              id = (type)id;\n              if(id == 0){\n                if((id[4] != 0) && (*(type)(id + 0xf) != *(type)(id + 0x10))){\n                  id = 9;\n                  if(id[6] != 0){\n                    call((type)((type)id + 0x5ce), 0x800, str);\n                    call((type)((type)id + 0x5ce), id[0xb]);\n                  }\n                  goto lbl;\n                }\n                id = call(id);\n                id = (type)id;\n              }\n            }\n          }\n        }\n      }\n    }\n    call(id[5]);\n    if(((type)id < 0x10) && ((0x8006U >> ((type)id & 0x1f) & 1) != 0)){\n      id = id[6];\n      goto lbl;\n    }\n  }\n  call(id);\n  if(id == (type)0x0){\n    return id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type id){\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = (type)id[8];\n  id = (type)call(1, 0xdd0);\n  id = (type)call(1, 0x180);\n  id = id[1];\n  *id = *id;\n  id[1] = id;\n  id[2] = id[2];\n  id[3] = id[3];\n  id[4] = id[4];\n  id[5] = id[5];\n  id[6] = id[6];\n  id[7] = id[7];\n  id[0x24] = id[9];\n  id[0x25] = id[10];\n  id[0xb] = id;\n  id[0xc] = id;\n  *(type)(id + 0x10) = *(type)(id + 0xb);\n  if(0 < (type)id[0xc]){\n    *(type)((type)id + 0x84) = (type)id[0xc];\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n    lbl:\n    call(id[5]);\n    id = id[6];\n    lbl:\n    if(id != 0){\n      id = call(id);\n      id = call();\n      id = id;\n      id = call(*id);\n      call((type)((type)id + 0x5ce), 0x800, str, id, id, id, *id);\n      id = id;\n      call((type)((type)id + 0x5ce), id);\n    }\n  }else{\n    id = call(0, 2, id[5]);\n    id[8] = id;\n    if(id == -1){\n      id = 0xf;\n      if((type)id[6] != (type)0x0){\n        *(type)((type)id + 0x5ee) = 0x656c696620666f;\n        *(type)((type)id + 0x5e6) = 0x20646e65206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(0, 0, id[5]);\n    id = (type)id[6];\n    if(id == -1){\n      id = 0xf;\n      if(id != (type)0x0){\n        *(type)((type)id + 0x5f4) = 0x656c696620666f;\n        *(type)((type)id + 0x5ee) = 0x666f20676e696e6e;\n        *(type)((type)id + 0x5e6) = 0x69676562206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(id, id, id, id);\n    id = (type)id;\n    if(id == 0){\n      *(type)((type)id + 0x4c) = id[1];\n      *(type)(id + 9) = *id;\n      *(type)(id + 10) = id[2];\n      id = call();\n      *(type)(id + 0xd) = id ^ *id;\n      id[0x11] = *(type)(id + 0x10);\n      id[0x12] = *(type)(id + 0xe);\n      id[0x13] = *(type)(id + 8);\n      id[0x16] = *(type)(id + 10);\n      id[0x18] = *(type)(id + 0xc);\n      id[0x17] = call(*(type)((type)id + 0x4c) != 0) * 4 + 4;\n      id[0x27] = *(type)(id + 0x12);\n      id[0x28] = *(type)(id + 0x14);\n      *(type)(id + 0x29) = id[3];\n      if(id[0x24] == 0){\n        id[0x24] = *(type)(id + 0x5e);\n      }\n      id = call();\n      id[0x14] = id;\n      if(id == 0){\n        id = 3;\n        lbl:\n        call(id[5]);\n        call(id);\n        goto lbl;\n      }\n      id = (type)id[0x24];\n      if(((id != (type)0x0) && (id = (type)id[0x25]id != (type)0x0)) && (id = call(id, id)id != 0)){\n        id = call(id, id);\n        if(id == (type)0xffffffffffffffff){\n          id = 7;\n          goto lbl;\n        }\n        id[0x26] = id;\n      }\n      id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, id[0x26]);\n      id = (type)id;\n      if(id == 0){\n        id = call(id, &id);\n        id = (type)id;\n        if(id == 0){\n          id = call(id, id);\n          id = (type)id;\n          if(id == 0){\n            id = call(id[0x11], 0, id[5]);\n            if(id == -1){\n              id = 0xf;\n              if(id[6] != 0){\n                call((type)((type)id + 0x5ce), 0x800, str, id[0x11]);\n                id = 0xf;\n                call((type)((type)id + 0x5ce), id[0xb]);\n              }\n              goto lbl;\n            }\n            id = call(id);\n            id = (type)id;\n            if(id == 0){\n              id = call(id, 0);\n              id = (type)id;\n              if(id == 0){\n                if((id[4] != 0) && (*(type)(id + 0xf) != *(type)(id + 0x10))){\n                  id = 9;\n                  if(id[6] != 0){\n                    call((type)((type)id + 0x5ce), 0x800, str);\n                    call((type)((type)id + 0x5ce), id[0xb]);\n                  }\n                  goto lbl;\n                }\n                id = call(id);\n                id = (type)id;\n              }\n            }\n          }\n        }\n      }\n    }\n    call(id[5]);\n    if(((type)id < 0x10) && ((0x8006U >> ((type)id & 0x1f) & 1) != 0)){\n      id = id[6];\n      goto lbl;\n    }\n  }\n  call(id);\n  if(id == (type)0x0){\n    return id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.25,
          "base_ppl": 2.046875,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 2.046875,
          "base_ast_ppl": 2.328125,
          "pr_ast_ppl": 2.3125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A aligns with the Source Code structure by avoiding unnecessary type casts. The original code uses calloc without explicit pointer casting, which matches the source's allocation pattern. Candidate B introduces casts (undefined8 * and uint *) that are not present in the source code, diverging from the original structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores type casting nodes present in the Source AST (e.g., `(type)call(...)`), which are absent in Candidate A. This matches the Source's topology and preserves the nesting depth of type-cast expressions seen in the original code.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O3.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "function_pr": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = (undefined8 *)calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id = 0;\n  type id = id;\n  type *id = id->id;\n  type *id = call(1, (id));\n  type *id = call(1, (id));\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id > 0)id->id = id->id;\n  if(call(id, id->id) == -1){\n    id = id;\n    goto lbl;\n  }\n  if((id->id = call(0, id, id->id)) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if(call(0, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id, id, id->id.id, id)) != id){\n    goto lbl;\n  }\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = call() ^ id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = (id->id ? 8 : 4);\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id == null){\n    id->id = id->id;\n  }\n  if((id->id = call(id->id)) == null){\n    id = id;\n    goto lbl;\n  }\n  if(id->id && id->id && call(id->id, id->id) != 0){\n    type id = call(id->id, id->id);\n    if(id == (id) - 1){\n      id = id;\n      goto lbl;\n    }\n    id->id = id;\n  }\n  if((id = call(id->id, (id->id), id->id, (id->id), id->id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, &id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, id)) != id){\n    goto lbl;\n  }\n  if(call(id->id, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, 0)) != id){\n    goto lbl;\n  }\n  if(id->id.id && id->id != id->id){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  lbl:\n  call(id->id);\n  if(id == id || id == id || id == id){\n    if(id->id.id){\n      call(id->id, (id->id), str, call(id), id, call(id), id);\n      call(id->id, id);\n    }\n  }\n  if(id)call(id);\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type id){\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = (type)id[8];\n  id = call(1, 0xdd0);\n  id = call(1, 0x180);\n  id = id[1];\n  *id = *id;\n  id[1] = id;\n  id[2] = id[2];\n  id[3] = id[3];\n  id[4] = id[4];\n  id[5] = id[5];\n  id[6] = id[6];\n  id[7] = id[7];\n  id[0x24] = id[9];\n  id[0x25] = id[10];\n  id[0xb] = id;\n  id[0xc] = id;\n  *(type)(id + 0x10) = *(type)(id + 0xb);\n  if(0 < (type)id[0xc]){\n    *(type)((type)id + 0x84) = (type)id[0xc];\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n    lbl:\n    call(id[5]);\n    id = id[6];\n    lbl:\n    if(id != 0){\n      id = call(id);\n      id = call();\n      id = id;\n      id = call(*id);\n      call((type)((type)id + 0x5ce), 0x800, str, id, id, id, *id);\n      id = id;\n      call((type)((type)id + 0x5ce), id);\n    }\n  }else{\n    id = call(0, 2, id[5]);\n    id[8] = id;\n    if(id == -1){\n      id = 0xf;\n      if((type)id[6] != (type)0x0){\n        *(type)((type)id + 0x5ee) = 0x656c696620666f;\n        *(type)((type)id + 0x5e6) = 0x20646e65206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(0, 0, id[5]);\n    id = (type)id[6];\n    if(id == -1){\n      id = 0xf;\n      if(id != (type)0x0){\n        *(type)((type)id + 0x5f4) = 0x656c696620666f;\n        *(type)((type)id + 0x5ee) = 0x666f20676e696e6e;\n        *(type)((type)id + 0x5e6) = 0x69676562206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(id, id, id, id);\n    id = (type)id;\n    if(id == 0){\n      *(type)((type)id + 0x4c) = id[1];\n      *(type)(id + 9) = *id;\n      *(type)(id + 10) = id[2];\n      id = call();\n      *(type)(id + 0xd) = id ^ *id;\n      id[0x11] = *(type)(id + 0x10);\n      id[0x12] = *(type)(id + 0xe);\n      id[0x13] = *(type)(id + 8);\n      id[0x16] = *(type)(id + 10);\n      id[0x18] = *(type)(id + 0xc);\n      id[0x17] = call(*(type)((type)id + 0x4c) != 0) * 4 + 4;\n      id[0x27] = *(type)(id + 0x12);\n      id[0x28] = *(type)(id + 0x14);\n      *(type)(id + 0x29) = id[3];\n      if(id[0x24] == 0){\n        id[0x24] = *(type)(id + 0x5e);\n      }\n      id = call();\n      id[0x14] = id;\n      if(id == 0){\n        id = 3;\n        lbl:\n        call(id[5]);\n        call(id);\n        goto lbl;\n      }\n      id = (type)id[0x24];\n      if(((id != (type)0x0) && (id = (type)id[0x25]id != (type)0x0)) && (id = call(id, id)id != 0)){\n        id = call(id, id);\n        if(id == (type)0xffffffffffffffff){\n          id = 7;\n          goto lbl;\n        }\n        id[0x26] = id;\n      }\n      id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, id[0x26]);\n      id = (type)id;\n      if(id == 0){\n        id = call(id, &id);\n        id = (type)id;\n        if(id == 0){\n          id = call(id, id);\n          id = (type)id;\n          if(id == 0){\n            id = call(id[0x11], 0, id[5]);\n            if(id == -1){\n              id = 0xf;\n              if(id[6] != 0){\n                call((type)((type)id + 0x5ce), 0x800, str, id[0x11]);\n                id = 0xf;\n                call((type)((type)id + 0x5ce), id[0xb]);\n              }\n              goto lbl;\n            }\n            id = call(id);\n            id = (type)id;\n            if(id == 0){\n              id = call(id, 0);\n              id = (type)id;\n              if(id == 0){\n                if((id[4] != 0) && (*(type)(id + 0xf) != *(type)(id + 0x10))){\n                  id = 9;\n                  if(id[6] != 0){\n                    call((type)((type)id + 0x5ce), 0x800, str);\n                    call((type)((type)id + 0x5ce), id[0xb]);\n                  }\n                  goto lbl;\n                }\n                id = call(id);\n                id = (type)id;\n              }\n            }\n          }\n        }\n      }\n    }\n    call(id[5]);\n    if(((type)id < 0x10) && ((0x8006U >> ((type)id & 0x1f) & 1) != 0)){\n      id = id[6];\n      goto lbl;\n    }\n  }\n  call(id);\n  if(id == (type)0x0){\n    return id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type id){\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = (type)id[8];\n  id = (type)call(1, 0xdd0);\n  id = (type)call(1, 0x180);\n  id = id[1];\n  *id = *id;\n  id[1] = id;\n  id[2] = id[2];\n  id[3] = id[3];\n  id[4] = id[4];\n  id[5] = id[5];\n  id[6] = id[6];\n  id[7] = id[7];\n  id[0x24] = id[9];\n  id[0x25] = id[10];\n  id[0xb] = id;\n  id[0xc] = id;\n  *(type)(id + 0x10) = *(type)(id + 0xb);\n  if(0 < (type)id[0xc]){\n    *(type)((type)id + 0x84) = (type)id[0xc];\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n    lbl:\n    call(id[5]);\n    id = id[6];\n    lbl:\n    if(id != 0){\n      id = call(id);\n      id = call();\n      id = id;\n      id = call(*id);\n      call((type)((type)id + 0x5ce), 0x800, str, id, id, id, *id);\n      id = id;\n      call((type)((type)id + 0x5ce), id);\n    }\n  }else{\n    id = call(0, 2, id[5]);\n    id[8] = id;\n    if(id == -1){\n      id = 0xf;\n      if((type)id[6] != (type)0x0){\n        *(type)((type)id + 0x5ee) = 0x656c696620666f;\n        *(type)((type)id + 0x5e6) = 0x20646e65206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(0, 0, id[5]);\n    id = (type)id[6];\n    if(id == -1){\n      id = 0xf;\n      if(id != (type)0x0){\n        *(type)((type)id + 0x5f4) = 0x656c696620666f;\n        *(type)((type)id + 0x5ee) = 0x666f20676e696e6e;\n        *(type)((type)id + 0x5e6) = 0x69676562206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(id, id, id, id);\n    id = (type)id;\n    if(id == 0){\n      *(type)((type)id + 0x4c) = id[1];\n      *(type)(id + 9) = *id;\n      *(type)(id + 10) = id[2];\n      id = call();\n      *(type)(id + 0xd) = id ^ *id;\n      id[0x11] = *(type)(id + 0x10);\n      id[0x12] = *(type)(id + 0xe);\n      id[0x13] = *(type)(id + 8);\n      id[0x16] = *(type)(id + 10);\n      id[0x18] = *(type)(id + 0xc);\n      id[0x17] = call(*(type)((type)id + 0x4c) != 0) * 4 + 4;\n      id[0x27] = *(type)(id + 0x12);\n      id[0x28] = *(type)(id + 0x14);\n      *(type)(id + 0x29) = id[3];\n      if(id[0x24] == 0){\n        id[0x24] = *(type)(id + 0x5e);\n      }\n      id = call();\n      id[0x14] = id;\n      if(id == 0){\n        id = 3;\n        lbl:\n        call(id[5]);\n        call(id);\n        goto lbl;\n      }\n      id = (type)id[0x24];\n      if(((id != (type)0x0) && (id = (type)id[0x25]id != (type)0x0)) && (id = call(id, id)id != 0)){\n        id = call(id, id);\n        if(id == (type)0xffffffffffffffff){\n          id = 7;\n          goto lbl;\n        }\n        id[0x26] = id;\n      }\n      id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, id[0x26]);\n      id = (type)id;\n      if(id == 0){\n        id = call(id, &id);\n        id = (type)id;\n        if(id == 0){\n          id = call(id, id);\n          id = (type)id;\n          if(id == 0){\n            id = call(id[0x11], 0, id[5]);\n            if(id == -1){\n              id = 0xf;\n              if(id[6] != 0){\n                call((type)((type)id + 0x5ce), 0x800, str, id[0x11]);\n                id = 0xf;\n                call((type)((type)id + 0x5ce), id[0xb]);\n              }\n              goto lbl;\n            }\n            id = call(id);\n            id = (type)id;\n            if(id == 0){\n              id = call(id, 0);\n              id = (type)id;\n              if(id == 0){\n                if((id[4] != 0) && (*(type)(id + 0xf) != *(type)(id + 0x10))){\n                  id = 9;\n                  if(id[6] != 0){\n                    call((type)((type)id + 0x5ce), 0x800, str);\n                    call((type)((type)id + 0x5ce), id[0xb]);\n                  }\n                  goto lbl;\n                }\n                id = call(id);\n                id = (type)id;\n              }\n            }\n          }\n        }\n      }\n    }\n    call(id[5]);\n    if(((type)id < 0x10) && ((0x8006U >> ((type)id & 0x1f) & 1) != 0)){\n      id = id[6];\n      goto lbl;\n    }\n  }\n  call(id);\n  if(id == (type)0x0){\n    return id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.25,
          "base_ppl": 2.046875,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 2.046875,
          "base_ast_ppl": 2.328125,
          "pr_ast_ppl": 2.3125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A aligns with the Source Code structure by omitting unnecessary type casts that are not present in the original C code. The source uses calloc without explicit pointer type casting, while Candidate B introduces casts (undefined8*, uint*) which are not reflected in the original code, introducing noise.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_zmagic-O0.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined4 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  int iVar3;\n  _union_1457 local_1b8 [19];\n  uint local_11c;\n  _union_1457 local_118 [19];\n  uint local_7c;\n  ulong local_78;\n  void *local_70;\n  undefined4 local_64;\n  uint local_60;\n  undefined4 local_5c;\n  int local_58;\n  int local_54;\n  long local_50;\n  void *local_48;\n  ulong local_40;\n  ulong local_38;\n  void *local_30;\n  undefined8 local_28;\n  undefined4 *local_20;\n  long local_18;\n  undefined4 local_c;\n  \n  local_30 = (void *)0x0;\n  local_5c = 0;\n  local_60 = *(uint *)(param_1 + 0x44) & 0x410;\n  local_64 = *param_2;\n  local_70 = *(void **)(param_2 + 0x26);\n  local_78 = *(ulong *)(param_2 + 0x28);\n  local_7c = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) == 0) {\n    local_c = 0;\n  }\n  else {\n    local_28 = param_3;\n    local_20 = param_2;\n    local_18 = param_1;\n    for (local_38 = 0; local_38 < ncompr; local_38 = local_38 + 1) {\n      iVar3 = -*(int *)(compr + local_38 * 0x20 + 8);\n      iVar1 = *(int *)(compr + local_38 * 0x20 + 8);\n      if (-1 < iVar3) {\n        iVar1 = iVar3;\n      }\n      if ((ulong)(long)iVar1 <= local_78) {\n        if (*(int *)(compr + local_38 * 0x20 + 8) < 0) {\n          local_11c = (**(code **)(compr + local_38 * 0x20))(local_70);\n        }\n        else {\n          iVar1 = memcmp(local_70,*(void **)(compr + local_38 * 0x20),\n                         (long)*(int *)(compr + local_38 * 0x20 + 8));\n          local_11c = (uint)(iVar1 == 0);\n        }\n        if (local_11c != 0) {\n          if (local_7c == 0) {\n            memset(local_1b8,0,0x98);\n            local_1b8[0] = (_union_1457)0x1;\n            iVar1 = sigaction(0xd,(sigaction *)local_1b8,(sigaction *)local_118);\n            local_7c = (uint)(iVar1 != -1);\n          }\n          local_40 = local_78;\n          free(local_30);\n          local_54 = uncompressbuf(local_64,*(undefined8 *)(local_18 + 0x120),local_38,\n                                   *(uint *)(local_18 + 0x44) & 0x4000000,local_70,&local_30,\n                                   &local_40);\n          if (local_54 != 0) {\n            if (local_54 == 1) goto LAB_00102adf;\n            if (local_54 != 2) {\n                    /* WARNING: Subroutine does not return */\n              abort();\n            }\n          }\n          *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) & 0xfffffffb;\n          if (local_54 == 2) {\n            local_58 = format_decompression_error(local_18,local_38,local_30);\n          }\n          else {\n            local_58 = file_buffer(local_18,0xffffffff,0,local_28,local_30,local_40);\n          }\n          if (local_58 != -1) {\n            local_5c = 1;\n            if (((*(uint *)(local_18 + 0x44) & 0x2000000) != 0) ||\n               ((local_60 != 0x410 && (local_60 != 0)))) break;\n            iVar1 = file_printf(local_18);\n            if ((iVar1 != -1) && (local_50 = file_push_buffer(local_18), local_50 != 0)) {\n              iVar1 = file_buffer(local_18,0xffffffff,0,0,local_70,local_78);\n              if (iVar1 == -1) {\n                lVar2 = file_pop_buffer(local_18);\n                if (lVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n                  abort();\n                }\n              }\n              else {\n                local_48 = (void *)file_pop_buffer(local_18);\n                if (local_48 != (void *)0x0) {\n                  iVar1 = file_printf(local_18,\"%s\",local_48);\n                  if (iVar1 == -1) {\n                    free(local_48);\n                    goto LAB_00102ad3;\n                  }\n                  free(local_48);\n                }\n                if ((local_60 != 0) || (iVar1 = file_printf(local_18), iVar1 != -1))\n                goto LAB_00102adf;\n              }\n            }\n          }\nLAB_00102ad3:\n          local_5c = 0xffffffff;\n        }\n      }\nLAB_00102adf:\n    }\n    if ((local_7c != 0) && (local_118[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_118,(sigaction *)0x0);\n    }\n    free(local_30);\n    *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) | 4;\n    local_c = local_5c;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nundefined4 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  _union_1457 local_1b8 [19];\n  uint local_11c;\n  _union_1457 local_118 [19];\n  uint local_7c;\n  ulong local_78;\n  void *local_70;\n  undefined4 local_64;\n  uint local_60;\n  undefined4 local_5c;\n  int local_58;\n  int local_54;\n  long local_50;\n  void *local_48;\n  ulong local_40;\n  ulong local_38;\n  void *local_30;\n  undefined8 local_28;\n  undefined4 *local_20;\n  long local_18;\n  undefined4 local_c;\n  \n  local_30 = (void *)0x0;\n  local_5c = 0;\n  local_60 = *(uint *)(param_1 + 0x44) & 0x410;\n  local_64 = *param_2;\n  local_70 = *(void **)(param_2 + 0x26);\n  local_78 = *(ulong *)(param_2 + 0x28);\n  local_7c = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) == 0) {\n    local_c = 0;\n  }\n  else {\n    local_28 = param_3;\n    local_20 = param_2;\n    local_18 = param_1;\n    for (local_38 = 0; local_38 < ncompr; local_38 = local_38 + 1) {\n      iVar1 = *(int *)(compr + local_38 * 0x20 + 8);\n      if (iVar1 < 1) {\n        iVar1 = -iVar1;\n      }\n      if ((ulong)(long)iVar1 <= local_78) {\n        if (*(int *)(compr + local_38 * 0x20 + 8) < 0) {\n          local_11c = (**(code **)(compr + local_38 * 0x20))(local_70);\n        }\n        else {\n          iVar1 = memcmp(local_70,*(void **)(compr + local_38 * 0x20),\n                         (long)*(int *)(compr + local_38 * 0x20 + 8));\n          local_11c = (uint)(iVar1 == 0);\n        }\n        if (local_11c != 0) {\n          if (local_7c == 0) {\n            memset(local_1b8,0,0x98);\n            local_1b8[0] = (_union_1457)0x1;\n            iVar1 = sigaction(0xd,(sigaction *)local_1b8,(sigaction *)local_118);\n            local_7c = (uint)(iVar1 != -1);\n          }\n          local_40 = local_78;\n          free(local_30);\n          local_54 = uncompressbuf(local_64,*(undefined8 *)(local_18 + 0x120),local_38,\n                                   *(uint *)(local_18 + 0x44) & 0x4000000,local_70,&local_30,\n                                   &local_40);\n          if (local_54 != 0) {\n            if (local_54 == 1) goto LAB_00102adf;\n            if (local_54 != 2) {\n                    /* WARNING: Subroutine does not return */\n              abort();\n            }\n          }\n          *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) & 0xfffffffb;\n          if (local_54 == 2) {\n            local_58 = format_decompression_error(local_18,local_38,local_30);\n          }\n          else {\n            local_58 = file_buffer(local_18,0xffffffff,0,local_28,local_30,local_40);\n          }\n          if (local_58 != -1) {\n            local_5c = 1;\n            if (((*(uint *)(local_18 + 0x44) & 0x2000000) != 0) ||\n               ((local_60 != 0x410 && (local_60 != 0)))) break;\n            iVar1 = file_printf(local_18);\n            if ((iVar1 != -1) && (local_50 = file_push_buffer(local_18), local_50 != 0)) {\n              iVar1 = file_buffer(local_18,0xffffffff,0,0,local_70,local_78);\n              if (iVar1 == -1) {\n                lVar2 = file_pop_buffer(local_18);\n                if (lVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n                  abort();\n                }\n              }\n              else {\n                local_48 = (void *)file_pop_buffer(local_18);\n                if (local_48 != (void *)0x0) {\n                  iVar1 = file_printf(local_18,\"%s\",local_48);\n                  if (iVar1 == -1) {\n                    free(local_48);\n                    goto LAB_00102ad3;\n                  }\n                  free(local_48);\n                }\n                if ((local_60 != 0) || (iVar1 = file_printf(local_18), iVar1 != -1))\n                goto LAB_00102adf;\n              }\n            }\n          }\nLAB_00102ad3:\n          local_5c = 0xffffffff;\n        }\n      }\nLAB_00102adf:\n    }\n    if ((local_7c != 0) && (local_118[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_118,(sigaction *)0x0);\n    }\n    free(local_30);\n    *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) | 4;\n    local_c = local_5c;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type *id = null;\n  type id, id;\n  type *id;\n  type *id;\n  type id, id, id = 0;\n  type id = id->id & id;\n  type id = id->id;\n  type *id = call(id unsigned char id->id);\n  type id = id->id;\n  type id = 0;\n  type id;\n  if((id->id & id) == 0)return 0;\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, -1, null, id, id, id);\n        if(id == -1)goto lbl;\n        id = 1;\n        if((id->id & id) != 0)goto lbl;\n        if(id != id && id != 0)goto lbl;\n        if((call(id, (id ? str : str))) == -1)goto lbl;\n        if((id = call(id)) == null)goto lbl;\n        if(call(id, -1, null, null, id, id) == -1){\n          if(call(id, id) != null)call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != null){\n          if(call(id, str, id) == -1){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, str) == -1)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = -1;\n        break;\n    }\n  }\n  lbl:\n  call(str, id);\n  if(id && id.id != id)(type)call(id, &id, null);\n  call(id);\n  id->id = id;\n  call(str, id);\n  return id;\n}",
        "base_ast": "type id( id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type id[19];\n  type id;\n  type id[19];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  id = (type)0x0;\n  id = 0;\n  id = *(type)(id + 0x44) & 0x410;\n  id = *id;\n  id = *(type)(id + 0x26);\n  id = *(type)(id + 0x28);\n  id = 0;\n  if((*(type)(id + 0x44) & 4) == 0){\n    id = 0;\n  }else{\n    id = id;\n    id = id;\n    id = id;\n    for(id = 0;  id < id; id = id + 1){\n      id = -*(type)(id + id * 0x20 + 8);\n      id = *(type)(id + id * 0x20 + 8);\n      if(-1 < id){\n        id = id;\n      }\n      if((type)(type)id <= id){\n        if(*(type)(id + id * 0x20 + 8) < 0){\n          id = call(id);\n        }else{\n          id = call(id, *(type)(id + id * 0x20), (type)*(type)(id + id * 0x20 + 8));\n          id = call(id == 0);\n        }\n        if(id != 0){\n          if(id == 0){\n            call(id, 0, 0x98);\n            id[0] = (type)0x1;\n            id = call(0xd, (type)id, (type)id);\n            id = call(id != -1);\n          }\n          id = id;\n          call(id);\n          id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n          if(id != 0){\n            if(id == 1)goto lbl;\n            if(id != 2){\n              call();\n            }\n          }\n          *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfffffffb;\n          if(id == 2){\n            id = call(id, id, id);\n          }else{\n            id = call(id, 0xffffffff, 0, id, id, id);\n          }\n          if(id != -1){\n            id = 1;\n            if(((*(type)(id + 0x44) & 0x2000000) != 0) || ((id != 0x410 && (id != 0))))break;\n            id = call(id);\n            if((id != -1) && (id = call(id)id != 0)){\n              id = call(id, 0xffffffff, 0, 0, id, id);\n              if(id == -1){\n                id = call(id);\n                if(id != 0){\n                  call();\n                }\n              }else{\n                id = (type)call(id);\n                if(id != (type)0x0){\n                  id = call(id, str, id);\n                  if(id == -1){\n                    call(id);\n                    goto lbl;\n                  }\n                  call(id);\n                }\n                if((id != 0) || (id = call(id)id != -1))goto lbl;\n              }\n            }\n          }\n          lbl:\n          id = 0xffffffff;\n        }\n      }\n      lbl:\n      ;\n    }\n    if((id != 0) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n    id = id;\n  }\n  return id;\n}",
        "pr_ast": "type id( id, type *id, type id){\n  type id;\n  type id;\n  type id[19];\n  type id;\n  type id[19];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  id = (type)0x0;\n  id = 0;\n  id = *(type)(id + 0x44) & 0x410;\n  id = *id;\n  id = *(type)(id + 0x26);\n  id = *(type)(id + 0x28);\n  id = 0;\n  if((*(type)(id + 0x44) & 4) == 0){\n    id = 0;\n  }else{\n    id = id;\n    id = id;\n    id = id;\n    for(id = 0;  id < id; id = id + 1){\n      id = *(type)(id + id * 0x20 + 8);\n      if(id < 1){\n        id = -id;\n      }\n      if((type)(type)id <= id){\n        if(*(type)(id + id * 0x20 + 8) < 0){\n          id = call(id);\n        }else{\n          id = call(id, *(type)(id + id * 0x20), (type)*(type)(id + id * 0x20 + 8));\n          id = call(id == 0);\n        }\n        if(id != 0){\n          if(id == 0){\n            call(id, 0, 0x98);\n            id[0] = (type)0x1;\n            id = call(0xd, (type)id, (type)id);\n            id = call(id != -1);\n          }\n          id = id;\n          call(id);\n          id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n          if(id != 0){\n            if(id == 1)goto lbl;\n            if(id != 2){\n              call();\n            }\n          }\n          *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfffffffb;\n          if(id == 2){\n            id = call(id, id, id);\n          }else{\n            id = call(id, 0xffffffff, 0, id, id, id);\n          }\n          if(id != -1){\n            id = 1;\n            if(((*(type)(id + 0x44) & 0x2000000) != 0) || ((id != 0x410 && (id != 0))))break;\n            id = call(id);\n            if((id != -1) && (id = call(id)id != 0)){\n              id = call(id, 0xffffffff, 0, 0, id, id);\n              if(id == -1){\n                id = call(id);\n                if(id != 0){\n                  call();\n                }\n              }else{\n                id = (type)call(id);\n                if(id != (type)0x0){\n                  id = call(id, str, id);\n                  if(id == -1){\n                    call(id);\n                    goto lbl;\n                  }\n                  call(id);\n                }\n                if((id != 0) || (id = call(id)id != -1))goto lbl;\n              }\n            }\n          }\n          lbl:\n          id = 0xffffffff;\n        }\n      }\n      lbl:\n      ;\n    }\n    if((id != 0) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n    id = id;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.5625,
          "base_ppl": 2.25,
          "pr_ppl": 2.234375,
          "source_ast_ppl": 4.28125,
          "base_ast_ppl": 2.796875,
          "pr_ast_ppl": 2.828125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B removes an unused variable (iVar3) and simplifies the logic by directly checking and modifying iVar1, reducing cognitive overhead. The original code in A introduced an artificial variable that complicated the flow without purpose. B's approach aligns with human-like abstraction by eliminating redundant steps and maintaining a direct mapping to the intended logic.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns with the Source Code's logic for handling absolute maglen values. The original code uses `abs(compr[i].maglen)` to determine buffer comparison, which Candidate B reflects by checking if `iVar1 < 1` and negating it (equivalent to absolute value). Candidate A's logic (`-*(int *)...` and `-1 < iVar3`) does not correctly model the absolute value check, introducing structural divergence.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate B improves idiomatic design by removing redundant assignments (e.g., `id = id;`), simplifying conditions (changing `-1 < id` to `id < 1`), and replacing no-op logic with meaningful negation (`id = -id`). This reduces artificial nesting and aligns with human-readable logic patterns, avoiding unnecessary complexity while preserving functional intent.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_checkfmt-O2.so",
        "function": "file_checkfmt",
        "source_code": "file_protected int\nfile_checkfmt(char *msg, size_t mlen, const char *fmt)\n{\n\tconst char *p;\n\tfor (p = fmt; *p; p++) {\n\t\tif (*p != '%')\n\t\t\tcontinue;\n\t\tif (*++p == '%')\n\t\t\tcontinue;\n\t\tif (*p == '\\0') {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"incomplete %% format\");\n\t\t\treturn -1;\n\t\t}\n\t\t// Skip uninteresting.\n\t\twhile (*p != '\\0' && strchr(\"#0.'+- \", *p) != NULL)\n\t\t\tp++;\n\t\tif (*p == '*') {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"* not allowed in format\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!file_checkfield(msg, mlen, \"width\", &p))\n\t\t\treturn -1;\n\n\t\tif (*p == '.') {\n\t\t\tp++;\n\t\t\tif (!file_checkfield(msg, mlen, \"precision\", &p))\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (!isalpha((unsigned char)*p)) {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"bad format char: %c\", *p);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "function_base": "\nundefined8 file_checkfmt(char *param_1,size_t param_2,byte *param_3)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  char *__format;\n  byte bVar3;\n  byte *local_38;\n  \n  do {\n    for (; *param_3 != 0x25; param_3 = param_3 + 1) {\n      if (*param_3 == 0) {\n        return 0;\n      }\nLAB_0010122d:\n    }\n    local_38 = param_3 + 1;\n    bVar3 = param_3[1];\n    if (bVar3 != 0x25) {\n      if (bVar3 == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        __format = \"incomplete %% format\";\nLAB_00101278:\n        snprintf(param_1,param_2,__format);\n        return 0xffffffff;\n      }\n      do {\n        if ((0x3f < bVar3) || ((1L << (bVar3 & 0x3f) & 0x1688900000001U) == 0)) {\n          if (bVar3 == 0x2a) {\n            if (param_1 == (char *)0x0) {\n              return 0xffffffff;\n            }\n            __format = \"* not allowed in format\";\n            goto LAB_00101278;\n          }\n          break;\n        }\n        bVar3 = local_38[1];\n        local_38 = local_38 + 1;\n      } while (bVar3 != 0);\n      iVar1 = file_checkfield(param_1,param_2,\"width\",&local_38);\n      if (iVar1 == 0) {\n        return 0xffffffff;\n      }\n      bVar3 = *local_38;\n      if (bVar3 == 0x2e) {\n        local_38 = local_38 + 1;\n        iVar1 = file_checkfield(param_1,param_2,\"precision\",&local_38);\n        if (iVar1 == 0) {\n          return 0xffffffff;\n        }\n        bVar3 = *local_38;\n      }\n      param_3 = local_38;\n      ppuVar2 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar2 + (ulong)bVar3 * 2 + 1) & 4) == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        snprintf(param_1,param_2,\"bad format char: %c\",(ulong)(uint)(int)(char)bVar3);\n        return 0xffffffff;\n      }\n      goto LAB_0010122d;\n    }\n    param_3 = param_3 + 2;\n  } while( true );\n}\n\n",
        "function_pr": "\nulong file_checkfmt(char *param_1,size_t param_2,byte *param_3)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  char *__format;\n  byte bVar3;\n  byte *local_38;\n  \n  do {\n    while( true ) {\n      bVar3 = *param_3;\n      if (bVar3 == 0x25) break;\n      if (bVar3 == 0) {\n        return (ulong)bVar3;\n      }\nLAB_0010122d:\n      param_3 = param_3 + 1;\n    }\n    local_38 = param_3 + 1;\n    bVar3 = param_3[1];\n    if (bVar3 != 0x25) {\n      if (bVar3 == 0) {\n        if (param_1 != (char *)0x0) {\n          __format = \"incomplete %% format\";\nLAB_00101278:\n          snprintf(param_1,param_2,__format);\n        }\n        return 0xffffffff;\n      }\n      do {\n        if ((0x3f < bVar3) || ((1L << (bVar3 & 0x3f) & 0x1688900000001U) == 0)) {\n          if (bVar3 == 0x2a) {\n            if (param_1 == (char *)0x0) {\n              return 0xffffffff;\n            }\n            __format = \"* not allowed in format\";\n            goto LAB_00101278;\n          }\n          break;\n        }\n        bVar3 = local_38[1];\n        local_38 = local_38 + 1;\n      } while (bVar3 != 0);\n      iVar1 = file_checkfield(param_1,param_2,\"width\",&local_38);\n      if (iVar1 == 0) {\n        return 0xffffffff;\n      }\n      bVar3 = *local_38;\n      if (bVar3 == 0x2e) {\n        local_38 = local_38 + 1;\n        iVar1 = file_checkfield(param_1,param_2,\"precision\",&local_38);\n        if (iVar1 == 0) {\n          return 0xffffffff;\n        }\n        bVar3 = *local_38;\n      }\n      param_3 = local_38;\n      ppuVar2 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar2 + (ulong)bVar3 * 2 + 1) & 4) == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        snprintf(param_1,param_2,\"bad format char: %c\",(ulong)(uint)(int)(char)bVar3);\n        return 0xffffffff;\n      }\n      goto LAB_0010122d;\n    }\n    param_3 = param_3 + 2;\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id;\n  for(id = id;  *id; id++){\n    if(*id != str)continue;\n    if(*++id == str)continue;\n    if(*id == str){\n      if(id)call(id, id, str);\n      return -1;\n    }\n    while(*id != str && call(str, *id) != null)id++;\n    if(*id == str){\n      if(id)call(id, id, str);\n      return -1;\n    }\n    if(!call(id, id, str, &id))return -1;\n    if(*id == str){\n      id++;\n      if(!call(id, id, str, &id))return -1;\n    }\n    if(!call((type)*id)){\n      if(id)call(id, id, str, *id);\n      return -1;\n    }\n  }\n  return 0;\n}",
        "base_ast": "typeid(type *id, type id, type *id)type id;type **id;type *id;type id;type *id;{\n  for(; *id != 0x25; id = id + 1){\n    if(*id == 0){\n      return 0;\n    }\n    lbl:\n    id = id + 1;\n    id = id[1];\n    if(id != 0x25){\n      if(id == 0){\n        if(id == (type)0x0){\n          return 0xffffffff;\n        }\n        id = str;\n        lbl:\n        call(id, id, id);\n        return 0xffffffff;\n      }\n      do{\n        if((0x3f < id) || ((1L << (id & 0x3f) & 0x1688900000001U) == 0)){\n          if(id == 0x2a){\n            if(id == (type)0x0){\n              return 0xffffffff;\n            }\n            id = str;\n            goto lbl;\n          }\n          break;\n        }\n        id = id[1];\n        id = id + 1;\n      }while(id != 0);\n      id = call(id, id, str, &id);\n      if(id == 0){\n        return 0xffffffff;\n      }\n      id = *id;\n      if(id == 0x2e){\n        id = id + 1;\n        id = call(id, id, str, &id);\n        if(id == 0){\n          return 0xffffffff;\n        }\n        id = *id;\n      }\n      id = id;\n      id = call();\n      if((*(type)((type)*id + (type)id * 2 + 1) & 4) == 0){\n        if(id == (type)0x0){\n          return 0xffffffff;\n        }\n        call(id, id, str, (type)(type)(type)(type)id);\n        return 0xffffffff;\n      }\n      goto lbl;\n    }\n    id = id + 2;\n  }\n  while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id){\n  type id;\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  do{\n    while(bool){\n      id = *id;\n      if(id == 0x25)break;\n      if(id == 0){\n        return (type)id;\n      }\n      lbl:\n      id = id + 1;\n    }\n    id = id + 1;\n    id = id[1];\n    if(id != 0x25){\n      if(id == 0){\n        if(id != (type)0x0){\n          id = str;\n          lbl:\n          call(id, id, id);\n        }\n        return 0xffffffff;\n      }\n      do{\n        if((0x3f < id) || ((1L << (id & 0x3f) & 0x1688900000001U) == 0)){\n          if(id == 0x2a){\n            if(id == (type)0x0){\n              return 0xffffffff;\n            }\n            id = str;\n            goto lbl;\n          }\n          break;\n        }\n        id = id[1];\n        id = id + 1;\n      }while(id != 0);\n      id = call(id, id, str, &id);\n      if(id == 0){\n        return 0xffffffff;\n      }\n      id = *id;\n      if(id == 0x2e){\n        id = id + 1;\n        id = call(id, id, str, &id);\n        if(id == 0){\n          return 0xffffffff;\n        }\n        id = *id;\n      }\n      id = id;\n      id = call();\n      if((*(type)((type)*id + (type)id * 2 + 1) & 4) == 0){\n        if(id == (type)0x0){\n          return 0xffffffff;\n        }\n        call(id, id, str, (type)(type)(type)(type)id);\n        return 0xffffffff;\n      }\n      goto lbl;\n    }\n    id = id + 2;\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 3.125,
          "base_ppl": 2.40625,
          "pr_ppl": 2.421875,
          "source_ast_ppl": 4.3125,
          "base_ast_ppl": 3.6875,
          "pr_ast_ppl": 3.59375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate A uses a `for` loop with a clear termination condition (`*param_3 != 0x25`), which directly expresses the loop's purpose in a semantic structure. Candidate B replaces this with a `while(true)` loop and manual `break`, which introduces artificial control flow and obscures the loop's intent. The original `for` loop aligns better with idiomatic control flow and human-readable logic.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A retains the original 'for' loop structure, which matches the Source Code's control flow. Candidate B replaces this with a 'do-while' loop, diverging from the original structure. The 'for' loop in Candidate A aligns with the Source Code's use of a 'for' loop to iterate through the format string.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate A retains the original 'for' loop structure present in the Source AST, which is critical for topology alignment. Candidate B replaces this with a 'do-while' loop, diverging from the Source's loop node type. While Candidate B introduces deeper nesting, the Source's explicit 'for' loop topology is preserved in Candidate A.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_getbuffer-O2.so",
        "function": "file_getbuffer",
        "source_code": "file_protected const char *\nfile_getbuffer(struct magic_set *ms)\n{\n\tchar *pbuf, *op, *np;\n\tsize_t psize, len;\n\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn NULL;\n\n\tif (ms->flags & MAGIC_RAW)\n\t\treturn ms->o.buf;\n\n\tif (ms->o.buf == NULL)\n\t\treturn NULL;\n\n\t/* * 4 is for octal representation, + 1 is for NUL */\n\tlen = strlen(ms->o.buf);\n\tif (len > (SIZE_MAX - 1) / 4) {\n\t\tfile_oomem(ms, len);\n\t\treturn NULL;\n\t}\n\tpsize = len * 4 + 1;\n\tif ((pbuf = CAST(char *, realloc(ms->o.pbuf, psize))) == NULL) {\n\t\tfile_oomem(ms, psize);\n\t\treturn NULL;\n\t}\n\tms->o.pbuf = pbuf;\n\n#if defined(HAVE_WCHAR_H) && defined(HAVE_MBRTOWC) && defined(HAVE_WCWIDTH)\n\t{\n\t\tmbstate_t state;\n\t\twchar_t nextchar;\n\t\tint mb_conv = 1;\n\t\tsize_t bytesconsumed;\n\t\tchar *eop;\n\t\t(void)memset(&state, 0, sizeof(mbstate_t));\n\n\t\tnp = ms->o.pbuf;\n\t\top = ms->o.buf;\n\t\teop = op + len;\n\n\t\twhile (op < eop) {\n\t\t\tbytesconsumed = mbrtowc(&nextchar, op,\n\t\t\t    CAST(size_t, eop - op), &state);\n\t\t\tif (bytesconsumed == CAST(size_t, -1) ||\n\t\t\t    bytesconsumed == CAST(size_t, -2)) {\n\t\t\t\tmb_conv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iswprint(nextchar)) {\n\t\t\t\t(void)memcpy(np, op, bytesconsumed);\n\t\t\t\top += bytesconsumed;\n\t\t\t\tnp += bytesconsumed;\n\t\t\t} else {\n\t\t\t\twhile (bytesconsumed-- > 0)\n\t\t\t\t\tOCTALIFY(np, op);\n\t\t\t}\n\t\t}\n\t\t*np = '\\0';\n\n\t\t/* Parsing succeeded as a multi-byte sequence */\n\t\tif (mb_conv != 0)\n\t\t\treturn ms->o.pbuf;\n\t}\n#endif\n\n\tfor (np = ms->o.pbuf, op = ms->o.buf; *op;) {\n\t\tif (isprint(CAST(unsigned char, *op))) {\n\t\t\t*np++ = *op++;\n\t\t} else {\n\t\t\tOCTALIFY(np, op);\n\t\t}\n\t}\n\t*np = '\\0';\n\treturn ms->o.pbuf;\n}\n",
        "function_base": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                    }\n                    bVar5 = pbVar6[1];\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "function_pr": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = (undefined1 *)realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                    }\n                    bVar5 = pbVar6[1];\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "source_ast": "type *id(type *id){\n  type *id, *id, *id;\n  type id, id;\n  if(id->id & id)return null;\n  if(id->id & id)return id->id.id;\n  if(id->id.id == null)return null;\n  id = call(id->id.id);\n  if(id > (id - 1) / 4){\n    call(id, id);\n    return null;\n  }\n  id = id * 4 + 1;\n  if((id = call(id * call(id->id.id, id))) == null){\n    call(id, id);\n    return null;\n  }\n  id->id.id = id;\n  id && id && id{\n    type id;\n    type id;\n    type id = 1;\n    type id;\n    type *id;\n    (type)call(&id, 0, (id));\n    id = id->id.id;\n    id = id->id.id;\n    id = id + id;\n    while(id < id){\n      id = call(&id, id, call(id, id - id), &id);\n      if(id == call(id, -1) || id == call(id, -2)){\n        id = 0;\n        break;\n      }\n      if(call(id)){\n        (type)call(id, id, id);\n        id = id;\n        id = id;\n      }else{\n        while(id-- > 0)call(id, id);\n      }\n    }\n    *id = str;\n    if(id != 0)return id->id.id;\n  }\n  for(id = id->id.idid = id->id.id;  *id; ){\n    if(call(call(id, id, *id))){\n      *id++ = *id++;\n    }else{\n      call(id, id);\n    }\n  }\n  *id = str;\n  return id->id.id;\n}",
        "base_ast": "type *id( id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type **id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  if((*(type)(id + 0x48) & 1) == 0){\n    id = *(type)(id + 0x20);\n    if((*(type)(id + 0x45) & 1) != 0){\n      return id;\n    }\n    if(id != (type)0x0){\n      id = call(id);\n      id = id;\n      if(id >> 0x3e == 0){\n        id = id * 4 + 1;\n        id = call(*(type)(id + 0x30), id);\n        if(id != (type)0x0){\n          *(type)(id + 0x30) = id;\n          id.id = 0;\n          id.id = (type)0x0;\n          if(id != 0){\n            id = *(type)(id + 0x20);\n            id = id + id;\n            do{\n              id = call(&id, (type)id, (type)id - (type)id, &id);\n              if(0xfffffffffffffffd < id){\n                *id = 0;\n                id = *(type)(id + 0x20);\n                id = *(type)(id + 0x30);\n                id = *id;\n                if(id != 0){\n                  id = call();\n                  do{\n                    if((*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0){\n                      *id = 0x5c;\n                      id[1] = *id >> 6 | 0x30;\n                      id[2] = *id >> 3 & 7 | 0x30;\n                      id[3] = *id & 7 | 0x30;\n                      id = id + 4;\n                    }else{\n                      *id = id;\n                      id = id + 1;\n                    }\n                    id = id[1];\n                    id = id + 1;\n                  }while(id != 0);\n                }\n                *id = 0;\n                return *(type)(id + 0x30);\n              }\n              id = call(id);\n              if(id == 0){\n                for(; id != 0; id = id - 1){\n                  *id = 0x5c;\n                  id[1] = *id >> 6 | 0x30;\n                  id[2] = *id >> 3 & 7 | 0x30;\n                  id = *id;\n                  id = id + 1;\n                  id[3] = id & 7 | 0x30;\n                  id = id + 4;\n                }\n              }else{\n                call(id, id, id);\n                id = id + id;\n                id = id + id;\n              }\n            }while(id < id);\n          }\n          *id = 0;\n          return *(type)(id + 0x30);\n        }\n      }\n      call(id, id);\n      return (type)0x0;\n    }\n  }\n  return (type)0x0;\n}",
        "pr_ast": "type *id( id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type **id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  if((*(type)(id + 0x48) & 1) == 0){\n    id = *(type)(id + 0x20);\n    if((*(type)(id + 0x45) & 1) != 0){\n      return id;\n    }\n    if(id != (type)0x0){\n      id = call(id);\n      id = id;\n      if(id >> 0x3e == 0){\n        id = id * 4 + 1;\n        id = (type)call(*(type)(id + 0x30), id);\n        if(id != (type)0x0){\n          *(type)(id + 0x30) = id;\n          id.id = 0;\n          id.id = (type)0x0;\n          if(id != 0){\n            id = *(type)(id + 0x20);\n            id = id + id;\n            do{\n              id = call(&id, (type)id, (type)id - (type)id, &id);\n              if(0xfffffffffffffffd < id){\n                *id = 0;\n                id = *(type)(id + 0x20);\n                id = *(type)(id + 0x30);\n                id = *id;\n                if(id != 0){\n                  id = call();\n                  do{\n                    if((*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0){\n                      *id = 0x5c;\n                      id[1] = *id >> 6 | 0x30;\n                      id[2] = *id >> 3 & 7 | 0x30;\n                      id[3] = *id & 7 | 0x30;\n                      id = id + 4;\n                    }else{\n                      *id = id;\n                      id = id + 1;\n                    }\n                    id = id[1];\n                    id = id + 1;\n                  }while(id != 0);\n                }\n                *id = 0;\n                return *(type)(id + 0x30);\n              }\n              id = call(id);\n              if(id == 0){\n                for(; id != 0; id = id - 1){\n                  *id = 0x5c;\n                  id[1] = *id >> 6 | 0x30;\n                  id[2] = *id >> 3 & 7 | 0x30;\n                  id = *id;\n                  id = id + 1;\n                  id[3] = id & 7 | 0x30;\n                  id = id + 4;\n                }\n              }else{\n                call(id, id, id);\n                id = id + id;\n                id = id + id;\n              }\n            }while(id < id);\n          }\n          *id = 0;\n          return *(type)(id + 0x30);\n        }\n      }\n      call(id, id);\n      return (type)0x0;\n    }\n  }\n  return (type)0x0;\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 2.0625,
          "pr_ppl": 2.046875,
          "source_ast_ppl": 4.78125,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.671875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores the explicit type cast `(type)` around the `call()` expression, which matches the Source AST's use of type casts (e.g., `(type)call(&id, 0, (id))`). Candidate A omits this cast, diverging from the Source's explicit type annotations. The nesting depth remains unchanged, but B aligns with the Source's topology through the preserved type node.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-file_file_getbuffer-O3.so",
        "function": "file_getbuffer",
        "source_code": "file_protected const char *\nfile_getbuffer(struct magic_set *ms)\n{\n\tchar *pbuf, *op, *np;\n\tsize_t psize, len;\n\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn NULL;\n\n\tif (ms->flags & MAGIC_RAW)\n\t\treturn ms->o.buf;\n\n\tif (ms->o.buf == NULL)\n\t\treturn NULL;\n\n\t/* * 4 is for octal representation, + 1 is for NUL */\n\tlen = strlen(ms->o.buf);\n\tif (len > (SIZE_MAX - 1) / 4) {\n\t\tfile_oomem(ms, len);\n\t\treturn NULL;\n\t}\n\tpsize = len * 4 + 1;\n\tif ((pbuf = CAST(char *, realloc(ms->o.pbuf, psize))) == NULL) {\n\t\tfile_oomem(ms, psize);\n\t\treturn NULL;\n\t}\n\tms->o.pbuf = pbuf;\n\n#if defined(HAVE_WCHAR_H) && defined(HAVE_MBRTOWC) && defined(HAVE_WCWIDTH)\n\t{\n\t\tmbstate_t state;\n\t\twchar_t nextchar;\n\t\tint mb_conv = 1;\n\t\tsize_t bytesconsumed;\n\t\tchar *eop;\n\t\t(void)memset(&state, 0, sizeof(mbstate_t));\n\n\t\tnp = ms->o.pbuf;\n\t\top = ms->o.buf;\n\t\teop = op + len;\n\n\t\twhile (op < eop) {\n\t\t\tbytesconsumed = mbrtowc(&nextchar, op,\n\t\t\t    CAST(size_t, eop - op), &state);\n\t\t\tif (bytesconsumed == CAST(size_t, -1) ||\n\t\t\t    bytesconsumed == CAST(size_t, -2)) {\n\t\t\t\tmb_conv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iswprint(nextchar)) {\n\t\t\t\t(void)memcpy(np, op, bytesconsumed);\n\t\t\t\top += bytesconsumed;\n\t\t\t\tnp += bytesconsumed;\n\t\t\t} else {\n\t\t\t\twhile (bytesconsumed-- > 0)\n\t\t\t\t\tOCTALIFY(np, op);\n\t\t\t}\n\t\t}\n\t\t*np = '\\0';\n\n\t\t/* Parsing succeeded as a multi-byte sequence */\n\t\tif (mb_conv != 0)\n\t\t\treturn ms->o.pbuf;\n\t}\n#endif\n\n\tfor (np = ms->o.pbuf, op = ms->o.buf; *op;) {\n\t\tif (isprint(CAST(unsigned char, *op))) {\n\t\t\t*np++ = *op++;\n\t\t} else {\n\t\t\tOCTALIFY(np, op);\n\t\t}\n\t}\n\t*np = '\\0';\n\treturn ms->o.pbuf;\n}\n",
        "function_base": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                      bVar5 = pbVar6[1];\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                      bVar5 = pbVar6[1];\n                    }\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "function_pr": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = (undefined1 *)realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                      bVar5 = pbVar6[1];\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                      bVar5 = pbVar6[1];\n                    }\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "source_ast": "type *id(type *id){\n  type *id, *id, *id;\n  type id, id;\n  if(id->id & id)return null;\n  if(id->id & id)return id->id.id;\n  if(id->id.id == null)return null;\n  id = call(id->id.id);\n  if(id > (id - 1) / 4){\n    call(id, id);\n    return null;\n  }\n  id = id * 4 + 1;\n  if((id = call(id * call(id->id.id, id))) == null){\n    call(id, id);\n    return null;\n  }\n  id->id.id = id;\n  id && id && id{\n    type id;\n    type id;\n    type id = 1;\n    type id;\n    type *id;\n    (type)call(&id, 0, (id));\n    id = id->id.id;\n    id = id->id.id;\n    id = id + id;\n    while(id < id){\n      id = call(&id, id, call(id, id - id), &id);\n      if(id == call(id, -1) || id == call(id, -2)){\n        id = 0;\n        break;\n      }\n      if(call(id)){\n        (type)call(id, id, id);\n        id = id;\n        id = id;\n      }else{\n        while(id-- > 0)call(id, id);\n      }\n    }\n    *id = str;\n    if(id != 0)return id->id.id;\n  }\n  for(id = id->id.idid = id->id.id;  *id; ){\n    if(call(call(id, id, *id))){\n      *id++ = *id++;\n    }else{\n      call(id, id);\n    }\n  }\n  *id = str;\n  return id->id.id;\n}",
        "base_ast": "type *id( id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type **id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  if((*(type)(id + 0x48) & 1) == 0){\n    id = *(type)(id + 0x20);\n    if((*(type)(id + 0x45) & 1) != 0){\n      return id;\n    }\n    if(id != (type)0x0){\n      id = call(id);\n      id = id;\n      if(id >> 0x3e == 0){\n        id = id * 4 + 1;\n        id = call(*(type)(id + 0x30), id);\n        if(id != (type)0x0){\n          *(type)(id + 0x30) = id;\n          id.id = 0;\n          id.id = (type)0x0;\n          if(id != 0){\n            id = *(type)(id + 0x20);\n            id = id + id;\n            do{\n              id = call(&id, (type)id, (type)id - (type)id, &id);\n              if(0xfffffffffffffffd < id){\n                *id = 0;\n                id = *(type)(id + 0x20);\n                id = *(type)(id + 0x30);\n                id = *id;\n                if(id != 0){\n                  id = call();\n                  do{\n                    if((*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0){\n                      *id = 0x5c;\n                      id[1] = *id >> 6 | 0x30;\n                      id[2] = *id >> 3 & 7 | 0x30;\n                      id[3] = *id & 7 | 0x30;\n                      id = id + 4;\n                      id = id[1];\n                    }else{\n                      *id = id;\n                      id = id + 1;\n                      id = id[1];\n                    }\n                    id = id + 1;\n                  }while(id != 0);\n                }\n                *id = 0;\n                return *(type)(id + 0x30);\n              }\n              id = call(id);\n              if(id == 0){\n                for(; id != 0; id = id - 1){\n                  *id = 0x5c;\n                  id[1] = *id >> 6 | 0x30;\n                  id[2] = *id >> 3 & 7 | 0x30;\n                  id = *id;\n                  id = id + 1;\n                  id[3] = id & 7 | 0x30;\n                  id = id + 4;\n                }\n              }else{\n                call(id, id, id);\n                id = id + id;\n                id = id + id;\n              }\n            }while(id < id);\n          }\n          *id = 0;\n          return *(type)(id + 0x30);\n        }\n      }\n      call(id, id);\n      return (type)0x0;\n    }\n  }\n  return (type)0x0;\n}",
        "pr_ast": "type *id( id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type **id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  if((*(type)(id + 0x48) & 1) == 0){\n    id = *(type)(id + 0x20);\n    if((*(type)(id + 0x45) & 1) != 0){\n      return id;\n    }\n    if(id != (type)0x0){\n      id = call(id);\n      id = id;\n      if(id >> 0x3e == 0){\n        id = id * 4 + 1;\n        id = (type)call(*(type)(id + 0x30), id);\n        if(id != (type)0x0){\n          *(type)(id + 0x30) = id;\n          id.id = 0;\n          id.id = (type)0x0;\n          if(id != 0){\n            id = *(type)(id + 0x20);\n            id = id + id;\n            do{\n              id = call(&id, (type)id, (type)id - (type)id, &id);\n              if(0xfffffffffffffffd < id){\n                *id = 0;\n                id = *(type)(id + 0x20);\n                id = *(type)(id + 0x30);\n                id = *id;\n                if(id != 0){\n                  id = call();\n                  do{\n                    if((*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0){\n                      *id = 0x5c;\n                      id[1] = *id >> 6 | 0x30;\n                      id[2] = *id >> 3 & 7 | 0x30;\n                      id[3] = *id & 7 | 0x30;\n                      id = id + 4;\n                      id = id[1];\n                    }else{\n                      *id = id;\n                      id = id + 1;\n                      id = id[1];\n                    }\n                    id = id + 1;\n                  }while(id != 0);\n                }\n                *id = 0;\n                return *(type)(id + 0x30);\n              }\n              id = call(id);\n              if(id == 0){\n                for(; id != 0; id = id - 1){\n                  *id = 0x5c;\n                  id[1] = *id >> 6 | 0x30;\n                  id[2] = *id >> 3 & 7 | 0x30;\n                  id = *id;\n                  id = id + 1;\n                  id[3] = id & 7 | 0x30;\n                  id = id + 4;\n                }\n              }else{\n                call(id, id, id);\n                id = id + id;\n                id = id + id;\n              }\n            }while(id < id);\n          }\n          *id = 0;\n          return *(type)(id + 0x30);\n        }\n      }\n      call(id, id);\n      return (type)0x0;\n    }\n  }\n  return (type)0x0;\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 2.03125,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 4.78125,
          "base_ast_ppl": 2.640625,
          "pr_ast_ppl": 2.640625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores the (type) cast present in the Ground Truth, aligning with the Source's use of explicit type casting in similar contexts (e.g., (type)call(...)). This matches the Source AST topology by preserving the node type structure, while Candidate A omits this cast.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_cnxptiee-O3.so",
        "function": "cnxptiee",
        "source_code": "int cnxptiee(const void *from_bytes, int fromtype, void *to_bytes, int totype)\n{\n    unsigned char *from = (unsigned char *)from_bytes;\n    unsigned char *to = (unsigned char *)to_bytes;\n    unsigned char temp[8];\n    int i;\n\n    if (fromtype == CN_TYPE_NATIVE) {\n        fromtype = FLOATREP;\n    }\n    switch(fromtype) {\n        case CN_TYPE_IEEEL :\n            if (totype == CN_TYPE_IEEEL)\n                break;\n            for (i=7;i>=0;i--) {\n                temp[7-i] = from[i];\n            }\n            from = temp;\n            fromtype = CN_TYPE_IEEEB;\n            /* Break intentionally omitted. */\n        case CN_TYPE_IEEEB :\n            /* Break intentionally omitted. */\n        case CN_TYPE_XPORT :\n            break;\n        default:\n            return(-1);\n    }\n    if (totype == CN_TYPE_NATIVE) {\n        totype = FLOATREP;\n    }\n    switch(totype) {\n        case CN_TYPE_XPORT :\n        case CN_TYPE_IEEEB :\n        case CN_TYPE_IEEEL :\n            break;\n        default:\n            return(-2);\n    }\n    if (fromtype == totype) {\n        memcpy(to,from,8);\n        return(0);\n    }\n    switch(fromtype) {\n        case CN_TYPE_IEEEB :\n            if (totype == CN_TYPE_XPORT)\n                ieee2xpt(from,to);\n            else memcpy(to,from,8);\n            break;\n        case CN_TYPE_XPORT :\n            xpt2ieee(from,to);\n            break;\n    }\n    if (totype == CN_TYPE_IEEEL) {\n        memcpy(temp,to,8);\n        for (i=7;i>=0;i--) {\n            to[7-i] = temp[i];\n        }\n    }\n    return(0);\n}\n",
        "function_base": "\nundefined8 cnxptiee(ulong *param_1,int param_2,ulong *param_3,int param_4)\n\n{\n  ulong uVar1;\n  ulong in_RAX;\n  undefined8 local_28;\n  \n  local_28 = in_RAX;\n  if (param_2 == 0) {\n    param_2 = get_native();\n  }\n  if (1 < param_2 - 1U) {\n    if (param_2 != 3) {\n      return 0xffffffff;\n    }\n    if (param_4 == 3) goto LAB_001012ac;\n    local_28 = CONCAT17((char)*param_1,\n                        CONCAT16(*(undefined1 *)((long)param_1 + 1),\n                                 CONCAT15(*(undefined1 *)((long)param_1 + 2),\n                                          CONCAT14(*(undefined1 *)((long)param_1 + 3),\n                                                   CONCAT13(*(undefined1 *)((long)param_1 + 4),\n                                                            CONCAT12(*(undefined1 *)\n                                                                      ((long)param_1 + 5),\n                                                                     CONCAT11(*(undefined1 *)\n                                                                               ((long)param_1 + 6),\n                                                                              *(undefined1 *)\n                                                                               ((long)param_1 + 7)))\n                                                           )))));\n    param_2 = 2;\n    param_1 = &local_28;\n  }\n  if (param_4 == 0) {\n    param_4 = get_native();\n  }\n  if (2 < param_4 - 1U) {\n    return 0xfffffffe;\n  }\n  if (param_2 != param_4) {\n    if (param_2 == 1) {\n      xpt2ieee(*param_1,param_3);\n    }\n    else if (param_2 == 2) {\n      if (param_4 == 1) {\n        ieee2xpt(param_1,param_3);\n        return 0;\n      }\n      *param_3 = *param_1;\n    }\n    if (param_4 != 3) {\n      return 0;\n    }\n    uVar1 = *param_3;\n    *param_3 = uVar1 >> 0x38 | (uVar1 & 0xff000000000000) >> 0x28 | (uVar1 & 0xff0000000000) >> 0x18\n               | (uVar1 & 0xff00000000) >> 8 | (uVar1 & 0xff000000) << 8 |\n               (uVar1 & 0xff0000) << 0x18 | (uVar1 & 0xff00) << 0x28 | uVar1 << 0x38;\n    return 0;\n  }\nLAB_001012ac:\n  *param_3 = *param_1;\n  return 0;\n}\n\n",
        "function_pr": "\nundefined8 cnxptiee(ulong *param_1,int param_2,ulong *param_3,int param_4)\n\n{\n  ulong uVar1;\n  uint uVar2;\n  ulong in_RAX;\n  undefined8 local_28;\n  \n  local_28 = in_RAX;\n  if (param_2 == 0) {\n    param_2 = get_native();\n    uVar2 = param_2 - 1;\n  }\n  else {\n    uVar2 = param_2 - 1;\n  }\n  if (1 < uVar2) {\n    if (param_2 != 3) {\n      return 0xffffffff;\n    }\n    if (param_4 == 3) goto LAB_001012ac;\n    local_28 = CONCAT17((char)*param_1,\n                        CONCAT16(*(undefined1 *)((long)param_1 + 1),\n                                 CONCAT15(*(undefined1 *)((long)param_1 + 2),\n                                          CONCAT14(*(undefined1 *)((long)param_1 + 3),\n                                                   CONCAT13(*(undefined1 *)((long)param_1 + 4),\n                                                            CONCAT12(*(undefined1 *)\n                                                                      ((long)param_1 + 5),\n                                                                     CONCAT11(*(undefined1 *)\n                                                                               ((long)param_1 + 6),\n                                                                              *(undefined1 *)\n                                                                               ((long)param_1 + 7)))\n                                                           )))));\n    param_2 = 2;\n    param_1 = &local_28;\n  }\n  if (param_4 == 0) {\n    param_4 = get_native();\n    uVar2 = param_4 - 1;\n  }\n  else {\n    uVar2 = param_4 - 1;\n  }\n  if (2 < uVar2) {\n    return 0xfffffffe;\n  }\n  if (param_2 != param_4) {\n    if (param_2 == 1) {\n      xpt2ieee(*param_1,param_3);\n    }\n    else if (param_2 == 2) {\n      if (param_4 == 1) {\n        ieee2xpt(param_1,param_3);\n        return 0;\n      }\n      *param_3 = *param_1;\n    }\n    if (param_4 == 3) {\n      uVar1 = *param_3;\n      *param_3 = uVar1 >> 0x38 | (uVar1 & 0xff000000000000) >> 0x28 |\n                 (uVar1 & 0xff0000000000) >> 0x18 | (uVar1 & 0xff00000000) >> 8 |\n                 (uVar1 & 0xff000000) << 8 | (uVar1 & 0xff0000) << 0x18 | (uVar1 & 0xff00) << 0x28 |\n                 uVar1 << 0x38;\n      return 0;\n    }\n    return 0;\n  }\nLAB_001012ac:\n  *param_3 = *param_1;\n  return 0;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id){\n  type *id = (type)id;\n  type *id = (type)id;\n  type id[8];\n  type id;\n  if(id == id){\n    id = id;\n  }\n  switch(id){\n    case id:\n      if(id == id)break;\n      for(id = 7;  id >= 0; id--){\n        id[7 - id] = id[id];\n      }\n      id = id;\n      id = id;\n    case id:\n    case id:\n      break;\n    case def:\n      return (-1);\n  }\n  if(id == id){\n    id = id;\n  }\n  switch(id){\n    case id:\n    case id:\n    case id:\n      break;\n    case def:\n      return (-2);\n  }\n  if(id == id){\n    call(id, id, 8);\n    return (0);\n  }\n  switch(id){\n    case id:\n      if(id == id)call(id, id);elsecall(id, id, 8);\n      break;\n    case id:\n      call(id, id);\n      break;\n  }\n  if(id == id){\n    call(id, id, 8);\n    for(id = 7;  id >= 0; id--){\n      id[7 - id] = id[id];\n    }\n  }\n  return (0);\n}",
        "base_ast": "type id(type *id, type id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  id = id;\n  if(id == 0){\n    id = call();\n  }\n  if(1 < id - 1U){\n    if(id != 3){\n      return 0xffffffff;\n    }\n    if(id == 3)goto lbl;\n    id = call((type)*id, call(*(type)((type)id + 1), call(*(type)((type)id + 2), call(*(type)((type)id + 3), call(*(type)((type)id + 4), call(*(type)((type)id + 5), call(*(type)((type)id + 6), *(type)((type)id + 7))))))));\n    id = 2;\n    id = &id;\n  }\n  if(id == 0){\n    id = call();\n  }\n  if(2 < id - 1U){\n    return 0xfffffffe;\n  }\n  if(id != id){\n    if(id == 1){\n      call(*id, id);\n    }elseif(id == 2){\n      if(id == 1){\n        call(id, id);\n        return 0;\n      }\n      *id = *id;\n    }\n    if(id != 3){\n      return 0;\n    }\n    id = *id;\n    *id = id >> 0x38 | (id & 0xff000000000000) >> 0x28 | (id & 0xff0000000000) >> 0x18 | (id & 0xff00000000) >> 8 | (id & 0xff000000) << 8 | (id & 0xff0000) << 0x18 | (id & 0xff00) << 0x28 | id << 0x38;\n    return 0;\n  }\n  lbl:\n  *id = *id;\n  return 0;\n}",
        "pr_ast": "type id(type *id, type id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type id;\n  id = id;\n  if(id == 0){\n    id = call();\n    id = id - 1;\n  }else{\n    id = id - 1;\n  }\n  if(1 < id){\n    if(id != 3){\n      return 0xffffffff;\n    }\n    if(id == 3)goto lbl;\n    id = call((type)*id, call(*(type)((type)id + 1), call(*(type)((type)id + 2), call(*(type)((type)id + 3), call(*(type)((type)id + 4), call(*(type)((type)id + 5), call(*(type)((type)id + 6), *(type)((type)id + 7))))))));\n    id = 2;\n    id = &id;\n  }\n  if(id == 0){\n    id = call();\n    id = id - 1;\n  }else{\n    id = id - 1;\n  }\n  if(2 < id){\n    return 0xfffffffe;\n  }\n  if(id != id){\n    if(id == 1){\n      call(*id, id);\n    }elseif(id == 2){\n      if(id == 1){\n        call(id, id);\n        return 0;\n      }\n      *id = *id;\n    }\n    if(id == 3){\n      id = *id;\n      *id = id >> 0x38 | (id & 0xff000000000000) >> 0x28 | (id & 0xff0000000000) >> 0x18 | (id & 0xff00000000) >> 8 | (id & 0xff000000) << 8 | (id & 0xff0000) << 0x18 | (id & 0xff00) << 0x28 | id << 0x38;\n      return 0;\n    }\n    return 0;\n  }\n  lbl:\n  *id = *id;\n  return 0;\n}",
        "metrics": {
          "source_ppl": 2.578125,
          "base_ppl": 2.1875,
          "pr_ppl": 2.109375,
          "source_ast_ppl": 2.9375,
          "base_ast_ppl": 2.734375,
          "pr_ast_ppl": 2.515625,
          "delta_ppl": -0.078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate A retains more of the original structure, including switch statements and similar condition checks present in the Source AST. Candidate B introduces modifications like added variables, altered condition expressions (e.g., `id - 1U` to `id`), and additional `else` blocks, which increase complexity and diverge from the Source's topology.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_readstat_convert-O2.so",
        "function": "readstat_convert",
        "source_code": "readstat_error_t readstat_convert(char *dst, size_t dst_len, const char *src, size_t src_len, iconv_t converter) {\n    /* strip off spaces from the input because the programs use ASCII space\n     * padding even with non-ASCII encoding. */\n    while (src_len && (src[src_len-1] == ' ' || src[src_len-1] == '\\0')) {\n        src_len--;\n    }\n    if (dst_len == 0) {\n        return READSTAT_ERROR_CONVERT_LONG_STRING;\n    } else if (converter) {\n        size_t dst_left = dst_len - 1;\n        char *dst_end = dst;\n        size_t status = iconv(converter, (readstat_iconv_inbuf_t)&src, &src_len, &dst_end, &dst_left);\n        if (status == (size_t)-1) {\n            if (errno == E2BIG) {\n                return READSTAT_ERROR_CONVERT_LONG_STRING;\n            } else if (errno == EILSEQ) {\n                return READSTAT_ERROR_CONVERT_BAD_STRING;\n            } else if (errno != EINVAL) { /* EINVAL indicates improper truncation; accept it */\n                return READSTAT_ERROR_CONVERT;\n            }\n        }\n        dst[dst_len - dst_left - 1] = '\\0';\n    } else if (src_len + 1 > dst_len) {\n        return READSTAT_ERROR_CONVERT_LONG_STRING;\n    } else {\n        memcpy(dst, src, src_len);\n        dst[src_len] = '\\0';\n    }\n    return READSTAT_OK;\n}\n",
        "function_base": "\nundefined8\nreadstat_convert(char *param_1,ulong param_2,char *param_3,size_t param_4,iconv_t param_5)\n\n{\n  int iVar1;\n  size_t sVar2;\n  int *piVar3;\n  ulong local_30;\n  char *local_28;\n  size_t local_20;\n  char *local_18;\n  \n  for (; param_4 != 0; param_4 = param_4 - 1) {\n    if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n  }\n  param_4 = 0;\nLAB_00101160:\n  if (param_2 == 0) {\n    return 0x13;\n  }\n  local_20 = param_4;\n  local_18 = param_3;\n  if (param_5 == (iconv_t)0x0) {\n    if (param_2 < param_4 + 1) {\n      return 0x13;\n    }\n    memcpy(param_1,param_3,param_4);\n    param_1[param_4] = '\\0';\n  }\n  else {\n    local_30 = param_2 - 1;\n    local_28 = param_1;\n    sVar2 = iconv(param_5,&local_18,&local_20,&local_28,&local_30);\n    if (sVar2 == 0xffffffffffffffff) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      if (iVar1 == 7) {\n        return 0x13;\n      }\n      if (iVar1 != 0x16) {\n        if (iVar1 == 0x54) {\n          return 0x11;\n        }\n        return 0x10;\n      }\n    }\n    param_1[param_2 + ~local_30] = '\\0';\n  }\n  return 0;\n}\n\n",
        "function_pr": "\nundefined8\nreadstat_convert(char *param_1,ulong param_2,char *param_3,size_t param_4,iconv_t param_5)\n\n{\n  int iVar1;\n  size_t sVar2;\n  int *piVar3;\n  ulong local_30;\n  char *local_28;\n  size_t local_20;\n  char *local_18;\n  \n  if (param_4 != 0) {\n    do {\n      if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n      param_4 = param_4 - 1;\n    } while (param_4 != 0);\n  }\n  param_4 = 0;\nLAB_00101160:\n  if (param_2 == 0) {\n    return 0x13;\n  }\n  local_20 = param_4;\n  local_18 = param_3;\n  if (param_5 == (iconv_t)0x0) {\n    if (param_2 < param_4 + 1) {\n      return 0x13;\n    }\n    memcpy(param_1,param_3,param_4);\n    param_1[param_4] = '\\0';\n  }\n  else {\n    local_30 = param_2 - 1;\n    local_28 = param_1;\n    sVar2 = iconv(param_5,&local_18,&local_20,&local_28,&local_30);\n    if (sVar2 == 0xffffffffffffffff) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      if (iVar1 == 7) {\n        return 0x13;\n      }\n      if (iVar1 != 0x16) {\n        if (iVar1 == 0x54) {\n          return 0x11;\n        }\n        return 0x10;\n      }\n    }\n    param_1[param_2 + ~local_30] = '\\0';\n  }\n  return 0;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type id){\n  while(id && (id[id - 1] == str || id[id - 1] == str)){\n    id--;\n  }\n  if(id == 0){\n    return id;\n  }elseif(id){\n    type id = id - 1;\n    type *id = id;\n    type id = call(id, (id) & id, &id, &id, &id);\n    if(id == (type)-1){\n      if(id == id){\n        return id;\n      }elseif(id == id){\n        return id;\n      }elseif(id != id){\n        return id;\n      }\n    }\n    id[id - id - 1] = str;\n  }elseif(id + 1 > id){\n    return id;\n  }else{\n    call(id, id, id);\n    id[id] = str;\n  }\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type id, type id){\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  for(; id != 0; id = id - 1){\n    if((id[id - 1] & 0xdfU) != 0)goto lbl;\n  }\n  id = 0;\n  lbl:\n  if(id == 0){\n    return 0x13;\n  }\n  id = id;\n  id = id;\n  if(id == (type)0x0){\n    if(id < id + 1){\n      return 0x13;\n    }\n    call(id, id, id);\n    id[id] = str;\n  }else{\n    id = id - 1;\n    id = id;\n    id = call(id, &id, &id, &id, &id);\n    if(id == 0xffffffffffffffff){\n      id = call();\n      id = *id;\n      if(id == 7){\n        return 0x13;\n      }\n      if(id != 0x16){\n        if(id == 0x54){\n          return 0x11;\n        }\n        return 0x10;\n      }\n    }\n    id[id + ~id] = str;\n  }\n  return 0;\n}",
        "pr_ast": "type id(type *id, type id, type *id, type id, type id){\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  if(id != 0){\n    do{\n      if((id[id - 1] & 0xdfU) != 0)goto lbl;\n      id = id - 1;\n    }while(id != 0);\n  }\n  id = 0;\n  lbl:\n  if(id == 0){\n    return 0x13;\n  }\n  id = id;\n  id = id;\n  if(id == (type)0x0){\n    if(id < id + 1){\n      return 0x13;\n    }\n    call(id, id, id);\n    id[id] = str;\n  }else{\n    id = id - 1;\n    id = id;\n    id = call(id, &id, &id, &id, &id);\n    if(id == 0xffffffffffffffff){\n      id = call();\n      id = *id;\n      if(id == 7){\n        return 0x13;\n      }\n      if(id != 0x16){\n        if(id == 0x54){\n          return 0x11;\n        }\n        return 0x10;\n      }\n    }\n    id[id + ~id] = str;\n  }\n  return 0;\n}",
        "metrics": {
          "source_ppl": 3.40625,
          "base_ppl": 2.125,
          "pr_ppl": 2.125,
          "source_ast_ppl": 4.4375,
          "base_ast_ppl": 3.984375,
          "pr_ast_ppl": 3.796875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A uses a `for` loop, which is a semantic structure well-suited for counting loops. Candidate B replaces it with a `do-while` wrapped in an `if` statement, adding artificial nesting. The `for` loop in A directly expresses the counting logic without redundant checks, aligning better with idiomatic control flow.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "winner": "Error",
          "motivation": "<think>\nOkay, let's tackle this evaluation. The user wants to know if the changes in the diff move the code closer to the source code structure or not. \n\nFirst, I need to look at the structural isomorphism. The original source code has a while loop that trims spaces from the end of the input string. The condition checks if the last character is a space or null, and decrements src_len until it's not. \n\nLooking at the diff, Candidate A uses a for loop: for (; param_4 != 0; param_4--). The body checks if the character at param_4-1 (masked with 0xdf) is non-zero, then jumps to LAB_00101160. \n\nCandidate B changes this to an if statement that wraps a do-while loop. The loop runs while param_4 != 0, and inside the loop, it checks the same condition and decrements param_4. \n\nThe original source code's loop is a while loop that continues as long as the last character is a space or null. The structure here is a loop that decrements the length until a non-space is found. \n\nIn the original code, the loop is a while loop that checks the condition each time. The Candidate A uses a for loop with the condition in the loop header, which is similar to the original's while loop. However, the original's loop is a while loop that checks the condition once per iteration. \n\nCandidate B's structure is a do-while loop. The key difference is that in Candidate B, the loop body is executed at least once, and then the condition is checked. However, in the original code, the loop might not execute at all if param_4 is zero from the start. \n\nWait, but the original code's loop is a while loop that checks the condition before each iteration. So if param_4 is zero, the loop doesn't run. In Candidate B's do-while, the loop body runs once, then checks the condition. So if param_4 is zero, the loop doesn't run. Wait, no: the do-while loop in Candidate B is written as:\n\nif (param_4 != 0) {\n   do {\n      ... check condition ...\n      param_4--;\n   } while (param_4 != 0);\n}\n\nSo the do-while loop will execute the body once, then check if param_4 is not zero. So if param_4 starts at 1, it would run once, then check again. But in the original code, the loop is a while loop that checks the condition before each iteration. \n\nBut the original code's loop is a while loop that continues as long as the last character is a space. The loop condition in the original is src_len && (src[src_len-1] is space or null). \n\nIn the decompiled code, the loop is over param_4 (which I assume represents src_len) and checks if the character at param_4-1 meets the condition. \n\nThe original code's loop is a while loop that decrements src_len until the condition is false. The Candidate A uses a for loop with the condition in the loop header. The Candidate B uses a do-while loop. \n\nIn terms of control flow structure, the original uses a while loop. Candidate A's for loop is structurally similar to a while loop, but with the decrement in the loop header. However, the original's loop is a while loop that checks the condition each time. \n\nBut the key point is whether the structure matches the source code. The original uses a while loop. Candidate A uses a for loop, which is a different structure. Candidate B uses a do-while loop. \n\nWait, but the original code's loop is a while loop that checks the condition once per iteration. The Candidate A's for loop is structured as for (; param_4 !=0; param_4--), which is equivalent to a while loop. However, the original code's loop is a while loop that checks the condition before each iteration. \n\nBut the original code's loop is written as:\n\nwhile (src_len && (src[src_len-1] == ' ' || src[src_len-1] == '\\0')) {\n    src_len--;\n}\n\nSo the loop condition is checked each time. \n\nIn Candidate A, the loop is a for loop that runs as long as param_4 !=0, and decrements param_4 each time. That's equivalent to a while loop that checks param_4 !=0 and decrements inside. But in the original code, the loop is a while loop that checks the condition (src_len and the character) and then decrements. \n\nWait, but the original code's loop is a while loop that checks the condition (src_len is not zero and the last character is space or null), then decrements src_len. So the loop condition is checked each time, and the body is executed if the condition is true. \n\nIn Candidate A, the for loop is structured as for (; param_4 !=0; param_4--). So the loop condition is checked before each iteration. The body is executed if param_4 is not zero. Then, after the body, param_4 is decremented. \n\nBut in the original code, the loop is a while loop that checks the condition (src_len and the character) and then decrements src_len. So the loop condition is more complex than just checking param_4. \n\nWait, but the decompiled code's loop is for trimming spaces, which is similar to the original code's loop. However, the original code's loop is a while loop, and the Candidate A uses a for loop. Candidate B uses a do-while loop. \n\nThe evaluation criteria say that structural isomorphism is important. The original code uses a while loop. Which of the candidates uses a loop structure that's closer to that? \n\nCandidate A uses a for loop. Candidate B uses a do-while loop. \n\nIn terms of structure, a while loop is more similar to a do-while loop in terms of the loop's condition checking. However, the original code's loop is a while loop that checks the condition before each iteration. The Candidate B's loop is a do-while, which executes the body once before checking the condition. \n\nBut in the original code, the loop might not execute at all if the condition is false initially. In Candidate B's case, the loop is wrapped in an if (param_4 !=0) check, so the do-while will only run if param_4 is non-zero. \n\nBut the original code's loop is a while loop. So the structural isomorphism would prefer a while loop. However, the candidates don't have a while loop. Candidate A uses a for loop, which is a different structure. Candidate B uses a do-while loop. \n\nBut perhaps the original code's loop is more similar to a for loop in terms of the loop control. Wait, the original code's loop is a while loop that decrements the counter. The Candidate A's for loop is structured as for (; param_4 !=0; param_4--). That's a for loop with no initialization, a condition, and a decrement. That's equivalent to a while loop. \n\nBut the original code's loop is a while loop. So in terms of structural isomorphism, Candidate A's for loop is more similar to the original's while loop in terms of the loop structure. However, the original code's loop is a while loop, and Candidate B's is a do-while. \n\nBut the original code's loop is a while loop that checks the condition before each iteration. The Candidate A's for loop is equivalent to a while loop. So perhaps Candidate A is closer in structure. \n\nBut wait, the original code's loop is a while loop that checks the condition (src_len and the character) and then decrements. The decompiled code's loop is for trimming spaces, which is similar. However, the decompiled code's loop is using a different variable (param_4) and checking (param_3[param_4 -1] & 0xdfU) !=0. \n\nBut the main point is the loop structure. The original uses a while loop. Candidate A uses a for loop. Candidate B uses a do-while loop. \n\nIn terms of structural isomorphism, which is closer? A while loop is more similar to a for loop than a do-while loop? Or is the for loop a different structure? \n\nIn C, a for loop can be rewritten as a while loop. So the original code's while loop could be represented as a for loop. So Candidate A's structure is a for loop, which is structurally similar to the original's while loop. \n\nBut the original code's loop is a while loop. So if the decompiled code uses a for loop, that's a different structure. However, the evaluation criteria say that the winner must have the same structure as the source code. \n\nWait, the first evaluation criterion says: \"Structural Isomorphism: Which version (A or B) matches the control flow structures of the Source Code? Source switch -> Winner must have switch. Source for -> Winner must have for.\"\n\nIn this case, the source code uses a while loop. So the winner must have a while loop. However, neither Candidate A nor B has a while loop. Candidate A uses a for loop, Candidate B uses a do-while loop. \n\nSo in this case, neither candidate has a while loop. Therefore, the structural isomorphism is not met by either. But perhaps the closest in terms of structure. \n\nAlternatively, perhaps the original code's loop is a while loop, but the decompiled code's loop is a for loop. The evaluation criteria might not require the exact same loop type, but rather the same control flow structure. \n\nAlternatively, maybe the original code's loop is a while loop that decrements the counter. The Candidate A's for loop is equivalent to a while loop. The Candidate B's do-while loop is equivalent to a while loop but with the condition checked after the body. \n\nIn terms of control flow, the original code's loop is a while loop that checks the condition before each iteration. Candidate A's for loop does the same. Candidate B's do-while loop checks after the first iteration. \n\nSo, in terms of control flow, the original code's loop is more similar to Candidate A's for loop, which checks the condition before each iteration, just like the original's while loop. \n\nTherefore, Candidate A's structure is closer to the original's while loop. \n\nNow, looking at the correction vs regression. The original code's loop is a while loop that trims spaces. The Candidate A uses a for loop that decrements param_4 each time. The Candidate B uses a do-while loop. \n\nIn the original code, the loop condition is checked before each iteration. So if param_4 is 0, the loop doesn't execute. In Candidate B's code, the do-while loop is inside an if (param_4 !=0) block. So the do-while will execute once, then check if param_4 is not zero again. \n\nWait, the code in Candidate B is:\n\nif (param_4 != 0) {\n    do {\n        if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n        param_4 = param_4 - 1;\n    } while (param_4 != 0);\n}\n\nSo the do-while loop will execute the body once, then check if param_4 is not zero. So if param_4 starts at 1, the loop runs once, then checks again. But the original code's loop is a while loop that checks the condition each time. \n\nIn the original code, the loop is:\n\nwhile (src_len && (src[src_len-1] is space or null)) {\n    src_len--;\n}\n\nSo the loop runs as long as the condition is true. \n\nIn Candidate A's code, the for loop is:\n\nfor (; param_4 != 0; param_4--) {\n    if (condition) goto ...\n}\n\nSo the loop runs while param_4 is not zero. Each iteration, after the body, param_4 is decremented. \n\nIn the original code, the loop is a while loop that checks the condition before each iteration. So the for loop in Candidate A is equivalent to a while loop. \n\nIn Candidate B's code, the loop is a do-while loop, which executes the body once before checking the condition. So if param_4 is 1, the body runs once, then param_4 is decremented to 0, and the loop stops. \n\nBut in the original code, the loop would check the condition each time. So if param_4 is 1, the loop runs once (since param_4 !=0 is true), then decrements to 0, and the loop stops. So the behavior is the same as Candidate A's for loop. \n\nWait, but in Candidate A's for loop, the condition is checked before each iteration. So the loop runs while param_4 is not zero. \n\nIn Candidate B's code, the do-while loop runs once, then checks the condition. So the loop will run as long as param_4 is not zero. \n\nSo the control flow of both Candidate A and B would be the same. However, the structure is different. \n\nBut the evaluation criteria focus on structural isomorphism. Since the original code uses a while loop, which is structurally similar to a for loop (Candidate A) than a do-while loop (Candidate B). \n\nSo, the winner would be Candidate A, as it uses a for loop which is structurally closer to the original's while loop. \n\nBut wait, the original code's loop is a while loop. The Candidate A's code uses a for loop. The evaluation criteria say that the winner must have the same structure. However, since the original uses a while loop, and neither candidate has a while loop, perhaps the evaluation is based on the closest possible structure. \n\nAlternatively, maybe the original code's loop is a while loop, but the decompiled code's loop is a for loop. So Candidate A's structure is closer to the original's structure. \n\nIn terms of correction vs regression: does the Candidate B fix a logic error in Candidate A or introduce noise? \n\nLooking at the code, Candidate A's loop is:\n\nfor (; param_4 != 0; param_4--) {\n    if (condition) goto ...\n}\n\nThis loop will run while param_4 is not zero. Each iteration, after the body, param_4 is decremented. \n\nCandidate B's code is:\n\nif (param_4 !=0) {\n    do {\n        if (condition) goto ...\n        param_4--;\n    } while (param_4 !=0);\n}\n\nThis is equivalent to a while loop that checks param_4 !=0 before each iteration. \n\nWait, the do-while loop in Candidate B will execute the body once, then check if param_4 is not zero. So the loop condition is checked after the body. \n\nIn contrast, the original code's while loop checks the condition before each iteration. \n\nSo the control flow of Candidate B's loop is different from the original. Because the original's loop checks the condition before each iteration, while Candidate B's loop checks after. \n\nBut in the original code, the loop is:\n\nwhile (condition) {\n    body\n    decrement\n}\n\nWhich is equivalent to:\n\nif (condition) {\n    do {\n        body\n        decrement\n    } while (condition);\n}\n\nWhich is what Candidate B does. \n\nWait, no. The original code's loop is:\n\nwhile (condition) {\n    body\n    decrement\n}\n\nWhich is equivalent to:\n\nif (condition) {\n    do {\n        body\n        decrement\n    } while (condition);\n}\n\nBut in Candidate B's code, the loop is:\n\nif (param_4 !=0) {\n    do {\n        body\n        decrement\n    } while (param_4 !=0);\n}\n\nWhich is equivalent to the original's while loop. \n\nSo the control flow is the same. \n\nBut Candidate A's loop is:\n\nfor (; param_4 !=0; param_4--) {\n    body\n}\n\nWhich is equivalent to:\n\nwhile (param_4 !=0) {\n    body\n    param_4--;\n}\n\nWhich is the same as the original's loop. \n\nSo both Candidate A and B have the same control flow. \n\nBut the structure is different. The original uses a while loop. Candidate A uses a for loop. Candidate B uses a do-while loop. \n\nIn terms of structural isomorphism, the original uses a while loop. So which candidate is closer? \n\nThe for loop in Candidate A is structurally different from the while loop. The do-while loop in Candidate B is also different. \n\nBut perhaps the evaluation criteria consider that the original's loop is a while loop, and the decompiled code's loop is a for loop (Candidate A), which is a different structure. However, the do-while loop (Candidate B) is also different. \n\nBut since the original code's loop is a while loop, and the decompiled code's loop is a for loop (Candidate A), which is a different structure, but the do-while loop (Candidate B) is also different. \n\nBut the evaluation criteria say that the winner must have the same structure as the source code. Since neither candidate has a while loop, perhaps the evaluation is based on which is closer in terms of loop structure. \n\nAlternatively, perhaps the original code's loop is a while loop that decrements the counter. The Candidate A's for loop is equivalent to a while loop. The Candidate B's do-while loop is also equivalent. \n\nBut the original code's loop is a while loop, so the structural isomorphism is not met by either. However, the evaluation criteria might prioritize the correction vs regression. \n\nIn terms of correction vs regression: does the Candidate B fix a logic error in Candidate A or introduce noise? \n\nLooking at the code, Candidate A's loop is a for loop that checks param_4 !=0 before each iteration. The body of the loop is the if statement that checks the condition and jumps. \n\nIn Candidate B's code, the loop is a do-while loop that runs the body once, then checks the condition. \n\nBut the original code's loop is a while loop that checks the condition before each iteration. \n\nIf the original code's loop is equivalent to Candidate A's for loop, then Candidate A's structure is closer. However, if the original code's loop is equivalent to Candidate B's do-while loop, then Candidate B is closer. \n\nBut the original code's loop is:\n\nwhile (src_len && (src[src_len-1] == ' ' || src[src_len-1] == '\\0')) {\n    src_len--;\n}\n\nThis loop continues as long as the last character is a space or null. Each iteration, it decrements src_len. \n\nIn terms of loop structure, this is a while loop that checks the condition before each iteration. \n\nCandidate A's for loop is:\n\nfor (; param_4 !=0; param_4--) {\n    if (condition) goto ...\n}\n\nThis is equivalent to a while loop that checks param_4 !=0 before each iteration. \n\nCandidate B's code is:\n\nif (param_4 !=0) {\n    do {\n        if (condition) goto ...\n        param_4--;\n    } while (param_4 !=0);\n"
        },
        "llm_ast": {
          "motivation": "Candidate A uses a `for` loop, which is a high-level semantic structure that cleanly encapsulates the loop condition and decrement in a single construct. Candidate B replaces this with a `do-while` loop wrapped in an `if` statement, introducing artificial nesting. While both candidates use semantic structures, Candidate A avoids redundant conditional checks and maintains a flatter control flow, aligning more closely with idiomatic, human-like design.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE.",
          "raw_response": ""
        }
      },
      {
        "binary": "task-readstat_readstat_convert-O3.so",
        "function": "readstat_convert",
        "source_code": "readstat_error_t readstat_convert(char *dst, size_t dst_len, const char *src, size_t src_len, iconv_t converter) {\n    /* strip off spaces from the input because the programs use ASCII space\n     * padding even with non-ASCII encoding. */\n    while (src_len && (src[src_len-1] == ' ' || src[src_len-1] == '\\0')) {\n        src_len--;\n    }\n    if (dst_len == 0) {\n        return READSTAT_ERROR_CONVERT_LONG_STRING;\n    } else if (converter) {\n        size_t dst_left = dst_len - 1;\n        char *dst_end = dst;\n        size_t status = iconv(converter, (readstat_iconv_inbuf_t)&src, &src_len, &dst_end, &dst_left);\n        if (status == (size_t)-1) {\n            if (errno == E2BIG) {\n                return READSTAT_ERROR_CONVERT_LONG_STRING;\n            } else if (errno == EILSEQ) {\n                return READSTAT_ERROR_CONVERT_BAD_STRING;\n            } else if (errno != EINVAL) { /* EINVAL indicates improper truncation; accept it */\n                return READSTAT_ERROR_CONVERT;\n            }\n        }\n        dst[dst_len - dst_left - 1] = '\\0';\n    } else if (src_len + 1 > dst_len) {\n        return READSTAT_ERROR_CONVERT_LONG_STRING;\n    } else {\n        memcpy(dst, src, src_len);\n        dst[src_len] = '\\0';\n    }\n    return READSTAT_OK;\n}\n",
        "function_base": "\nundefined8\nreadstat_convert(char *param_1,ulong param_2,char *param_3,size_t param_4,iconv_t param_5)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  size_t sVar3;\n  int *piVar4;\n  ulong local_30;\n  char *local_28;\n  size_t local_20;\n  char *local_18;\n  \n  for (; param_4 != 0; param_4 = param_4 - 1) {\n    if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n  }\n  param_4 = 0;\nLAB_00101160:\n  uVar2 = 0x13;\n  if (param_2 != 0) {\n    local_20 = param_4;\n    local_18 = param_3;\n    if (param_5 == (iconv_t)0x0) {\n      if (param_2 < param_4 + 1) {\n        return 0x13;\n      }\n      memcpy(param_1,param_3,param_4);\n      param_1[param_4] = '\\0';\n    }\n    else {\n      local_30 = param_2 - 1;\n      local_28 = param_1;\n      sVar3 = iconv(param_5,&local_18,&local_20,&local_28,&local_30);\n      if (sVar3 == 0xffffffffffffffff) {\n        piVar4 = __errno_location();\n        iVar1 = *piVar4;\n        if (iVar1 == 7) {\n          return 0x13;\n        }\n        if (iVar1 != 0x16) {\n          if (iVar1 != 0x54) {\n            return 0x10;\n          }\n          return 0x11;\n        }\n      }\n      param_1[param_2 + ~local_30] = '\\0';\n    }\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nundefined8\nreadstat_convert(char *param_1,ulong param_2,char *param_3,size_t param_4,iconv_t param_5)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  size_t sVar3;\n  int *piVar4;\n  ulong local_30;\n  char *local_28;\n  size_t local_20;\n  char *local_18;\n  \n  if (param_4 != 0) {\n    do {\n      if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n      param_4 = param_4 - 1;\n    } while (param_4 != 0);\n  }\n  param_4 = 0;\nLAB_00101160:\n  uVar2 = 0x13;\n  if (param_2 != 0) {\n    local_20 = param_4;\n    local_18 = param_3;\n    if (param_5 == (iconv_t)0x0) {\n      if (param_2 < param_4 + 1) {\n        return 0x13;\n      }\n      memcpy(param_1,param_3,param_4);\n      param_1[param_4] = '\\0';\n    }\n    else {\n      local_30 = param_2 - 1;\n      local_28 = param_1;\n      sVar3 = iconv(param_5,&local_18,&local_20,&local_28,&local_30);\n      if (sVar3 == 0xffffffffffffffff) {\n        piVar4 = __errno_location();\n        iVar1 = *piVar4;\n        if (iVar1 == 7) {\n          return 0x13;\n        }\n        if (iVar1 != 0x16) {\n          if (iVar1 == 0x54) {\n            return 0x11;\n          }\n          return 0x10;\n        }\n      }\n      param_1[param_2 + ~local_30] = '\\0';\n    }\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type id){\n  while(id && (id[id - 1] == str || id[id - 1] == str)){\n    id--;\n  }\n  if(id == 0){\n    return id;\n  }elseif(id){\n    type id = id - 1;\n    type *id = id;\n    type id = call(id, (id) & id, &id, &id, &id);\n    if(id == (type)-1){\n      if(id == id){\n        return id;\n      }elseif(id == id){\n        return id;\n      }elseif(id != id){\n        return id;\n      }\n    }\n    id[id - id - 1] = str;\n  }elseif(id + 1 > id){\n    return id;\n  }else{\n    call(id, id, id);\n    id[id] = str;\n  }\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  for(; id != 0; id = id - 1){\n    if((id[id - 1] & 0xdfU) != 0)goto lbl;\n  }\n  id = 0;\n  lbl:\n  id = 0x13;\n  if(id != 0){\n    id = id;\n    id = id;\n    if(id == (type)0x0){\n      if(id < id + 1){\n        return 0x13;\n      }\n      call(id, id, id);\n      id[id] = str;\n    }else{\n      id = id - 1;\n      id = id;\n      id = call(id, &id, &id, &id, &id);\n      if(id == 0xffffffffffffffff){\n        id = call();\n        id = *id;\n        if(id == 7){\n          return 0x13;\n        }\n        if(id != 0x16){\n          if(id != 0x54){\n            return 0x10;\n          }\n          return 0x11;\n        }\n      }\n      id[id + ~id] = str;\n    }\n    id = 0;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type *id, type id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  if(id != 0){\n    do{\n      if((id[id - 1] & 0xdfU) != 0)goto lbl;\n      id = id - 1;\n    }while(id != 0);\n  }\n  id = 0;\n  lbl:\n  id = 0x13;\n  if(id != 0){\n    id = id;\n    id = id;\n    if(id == (type)0x0){\n      if(id < id + 1){\n        return 0x13;\n      }\n      call(id, id, id);\n      id[id] = str;\n    }else{\n      id = id - 1;\n      id = id;\n      id = call(id, &id, &id, &id, &id);\n      if(id == 0xffffffffffffffff){\n        id = call();\n        id = *id;\n        if(id == 7){\n          return 0x13;\n        }\n        if(id != 0x16){\n          if(id == 0x54){\n            return 0x11;\n          }\n          return 0x10;\n        }\n      }\n      id[id + ~id] = str;\n    }\n    id = 0;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.40625,
          "base_ppl": 2.140625,
          "pr_ppl": 2.109375,
          "source_ast_ppl": 4.4375,
          "base_ast_ppl": 3.921875,
          "pr_ast_ppl": 3.75,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A retains a for-loop structure, which aligns more closely with the original source code's while-loop logic (both check conditions before iteration). Candidate B introduces a do-while loop, which executes the body before checking the condition\u2014a structural divergence from the original's pre-check behavior. Additionally, the error-handling logic in Candidate B inverts return values, potentially introducing a regression.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate A uses a standard `for` loop with a clear, concise structure that directly maps to the logical intent of iterating while `id != 0`. Candidate B introduces an artificial wrapper `if (id != 0)` before a `do-while` loop, which is redundant and adds unnecessary nesting. The `for` loop in A avoids this redundancy and aligns with idiomatic control flow by leveraging a single, well-scoped loop structure. The `do-while` in B, while functionally equivalent, introduces a graph artifact (redundant condition check) and less idiomatic nesting.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "<think>\nOkay, let's tackle this problem step by step. The goal is to determine whether Candidate A or Candidate B in the AST diff matches the original Source AST topology. The criteria given are Topology Match and Complexity, specifically looking at node types and nesting depth.\n\nFirst, I need to understand the original Source AST. The function provided has a while loop, several if-else conditions, and some assignments. The key nodes here are the while loop, if-else statements, and possibly switch statements. Wait, the original code doesn't have a switch statement, but the first criterion mentions a node type like SwitchStatement. However, in the Source AST, there's no switch, so maybe that's not relevant here. Let me check the diff.\n\nLooking at the diff, the original code (Candidate A) has a for loop that's replaced in Candidate B with an if statement followed by a do-while loop. The original Source's structure might have a different loop structure. Let me compare the loop parts.\n\nIn the Source, the initial loop is a while loop that decrements id until a condition is met. In Candidate A, the loop is a for loop with id != 0 and id = id -1. In Candidate B, it's an if statement that wraps a do-while loop. The structure here is different. The original Source's loop is a while loop, but the diff shows that Candidate A uses a for loop, and Candidate B uses a do-while. However, the original Source's code might have a different structure. Wait, the original Source code's loop is a while loop, but the diff shows that in the Ground Truth (Source AST), the loop is a while loop. Wait, the Ground Truth code starts with a while loop. But in the diff, the original code (Candidate A) has a for loop. Wait, the Ground Truth is the original code. Wait, the user provided the Ground Truth as the Source AST. Let me check again.\n\nThe Ground Truth (Source AST) code starts with:\n\nwhile(id && (id[id - 1] == str || id[id - 1] == str)){\n    id--;\n}\n\nBut in the diff, the original code (Candidate A) has a for loop:\n\nfor(; id != 0; id = id - 1){\n    if((id[id - 1] & 0xdfU) != 0)goto lbl;\n}\n\nWait, that seems different. The original Source's loop condition is checking if id is not zero and the id[id-1] is str, but in the diff, Candidate A's loop is a for loop that runs while id != 0, decrementing id each time. The Source's loop is a while loop that checks both id and the condition. So the diff's Candidate A and B are modifying that loop structure. But the original Source's loop is a while loop. However, the Ground Truth is the original code. Wait, the user says that the Ground Truth is the Source AST. So the original code (the Source) has a while loop. But in the diff, the original code (Candidate A) has a for loop. That suggests that the original code (the Source AST) might have been modified in the diff. Wait, perhaps the Ground Truth is the original code, and the diff shows changes between Candidate A and B. So the user is comparing which of the two candidates (A or B) is closer to the original Source AST.\n\nWait, the user says: \"You are a Decompilation Architect comparing AST changes against a Ground Truth. Your goal: Determine which version in the Diff (A or B) mirrors the Source AST topology.\"\n\nSo the Ground Truth is the original Source AST. The diff shows changes between Candidate A and B. The user wants to know which of the two candidates (A or B) is more aligned with the original Source AST.\n\nSo the original Source AST's loop is a while loop. But in the diff, Candidate A has a for loop, and Candidate B has an if statement with a do-while loop. So the original Source's loop structure is different from both A and B. Wait, but maybe the original Source's loop is a while loop, and the candidates are different versions. So the question is, which candidate (A or B) is closer to the original Source's structure.\n\nLooking at the first part of the diff:\n\nIn the original (Candidate A), the loop is a for loop:\n\nfor(; id != 0; id = id - 1){\n    if((id[id - 1] & 0xdfU) != 0)goto lbl;\n}\n\nIn Candidate B, it's replaced with:\n\nif(id != 0){\n    do{\n        if((id[id - 1] & 0xdfU) != 0)goto lbl;\n        id = id - 1;\n    }while(id != 0);\n}\n\nSo the original Source's loop is a while loop. But the candidates are different. However, the original Source's code (the Ground Truth) has a while loop. Wait, the Ground Truth code starts with:\n\nwhile(id && (id[id - 1] == str || id[id - 1] == str)){\n    id--;\n}\n\nSo the original loop is a while loop that checks id and the condition. The candidates have different structures. So the question is, which of the candidates (A or B) is closer to the original structure.\n\nBut the original Source's loop is a while loop, but the candidates have for and do-while. However, the Ground Truth's loop is a while loop, which is different from both A and B. Wait, perhaps the original code (the Source AST) was modified, and the candidates are different versions. So the user is comparing which of A or B is closer to the original.\n\nWait, perhaps the original code (the Ground Truth) has a while loop, and the diff shows that in the original code (Candidate A), the loop was a for loop, but in Candidate B, it's a do-while loop. So the original code (the Source AST) might have a different structure. But this is confusing.\n\nAlternatively, perhaps the Ground Truth is the original code, and the diff shows that Candidate A and B are two versions that have been modified. The user wants to know which of these two (A or B) is closer to the original Source AST.\n\nSo, the first part of the diff is about the loop structure. The original Source's loop is a while loop, but in the diff, Candidate A has a for loop, and Candidate B has a do-while loop. However, the original Source's loop is a while loop. So perhaps neither A nor B exactly matches the original loop structure. But maybe the other parts of the code have more relevant changes.\n\nLooking at the second part of the diff:\n\nIn the original code (Candidate A), there's a section:\n\nif(id != 0x16){\n    if(id != 0x54){\n        return 0x10;\n    }\n    return 0x11;\n}\n\nIn Candidate B, it's:\n\nif(id != 0x16){\n    if(id == 0x54){\n        return 0x11;\n    }\n    return 0x10;\n}\n\nThe original Source AST's code (Ground Truth) has:\n\nif(id == 0x54){\n    return 0x11;\n}elseif(id == id){\n    return id;\n}elseif(id != id){\n    return id;\n}\n\nWait, no, looking back at the Ground Truth code:\n\nIn the Ground Truth, after the initial loop, there's:\n\nif(id == 0){\n    return id;\n} elseif(id){\n    type id = id - 1;\n    type *id = id;\n    type id = call(id, (id) & id, &id, &id, &id);\n    if(id == (type)-1){\n        if(id == id){\n            return id;\n        } elseif(id == id){\n            return id;\n        } elseif(id != id){\n            return id;\n        }\n    }\n    id[id - id - 1] = str;\n} elseif(id + 1 > id){\n    return id;\n} else {\n    call(id, id, id);\n    id[id] = str;\n}\nreturn id;\n\nWait, the part in the diff that's changed is in the later part. The original code (Candidate A) has:\n\nif(id != 0x16){\n    if(id != 0x54){\n        return 0x10;\n    }\n    return 0x11;\n}\n\nIn Candidate B, it's:\n\nif(id != 0x16){\n    if(id == 0x54){\n        return 0x11;\n    }\n    return 0x10;\n}\n\nComparing to the Ground Truth code, which part is this? The Ground Truth code has a section with:\n\nif(id != 0x16){\n    if(id != 0x54){\n        return 0x10;\n    }\n    return 0x11;\n}\n\nWait, no. Looking back, the Ground Truth code's later part (after the initial loop) has:\n\nif(id == 0){\n    return id;\n} elseif(id){\n    ... some code ...\n} elseif(id + 1 > id){\n    return id;\n} else {\n    call(...);\n    id[id] = str;\n}\nreturn id;\n\nBut the diff is about a different part. The diff's second part is about:\n\nIn the original code (Candidate A), there's:\n\nif(id != 0x16){\n    if(id != 0x54){\n        return 0x10;\n    }\n    return 0x11;\n}\n\nIn Candidate B, it's:\n\nif(id != 0x16){\n    if(id == 0x54){\n        return 0x11;\n    }\n    return 0x10;\n}\n\nBut the Ground Truth code's corresponding part is not provided. Wait, the Ground Truth code is the original code, which the user provided. However, the diff is between Candidate A and B, and the Ground Truth is the original code. So the user is asking which of A or B is closer to the original code.\n\nBut the original code (the Ground Truth) is the one that the user provided. So the user is saying that the Ground Truth is the original code, and the diff shows changes between A and B. The user wants to know which of A or B is closer to the original code.\n\nBut the original code (Ground Truth) has a certain structure. Let's look at the first part of the diff again.\n\nIn the Ground Truth code (original), the loop is a while loop. However, in the diff, Candidate A has a for loop, and Candidate B has an if with do-while. So the original code's loop is a while loop, which is different from both A and B. However, maybe the original code's loop is not the same as the Ground Truth's loop. Wait, the Ground Truth code is the original code. So the original code's loop is a while loop. But in the diff, the original code (Candidate A) has a for loop. That suggests that the original code (the Ground Truth) is different from Candidate A. Wait, this is confusing. Maybe the Ground Truth is the original code, and the diff is between two modified versions (A and B) of that code. The user wants to know which of A or B is closer to the original.\n\nAlternatively, perhaps the Ground Truth is the original code, and the diff shows that Candidate A is the original code, and Candidate B is a modified version. But the user's instructions say that the diff is between A and B, and the Ground Truth is the original. So the user wants to know which of A or B is closer to the original.\n\nBut without seeing the original code's structure, it's hard to compare. However, the user provided the Ground Truth code. Let me recheck that.\n\nThe Ground Truth code (Source AST) starts with:\n\ntype id(type *id, type id, type *id, type id, type id){\n  while(id && (id[id - 1] == str || id[id - 1] == str)){\n    id--;\n  }\n  if(id == 0){\n    return id;\n  }elseif(id){\n    type id = id - 1;\n    type *id = id;\n    type id = call(id, (id) & id, &id, &id, &id);\n    if(id == (type)-1){\n      if(id == id){\n        return id;\n      }elseif(id == id){\n        return id;\n      }elseif(id != id){\n        return id;\n      }\n    }\n    id[id - id - 1] = str;\n  }elseif(id + 1 > id){\n    return id;\n  }else{\n    call(id, id, id);\n    id[id] = str;\n  }\n  return id;\n}\n\nSo the original code has a while loop that checks id and the condition. Then, there are if-else conditions.\n\nIn the diff, the first change is in the loop structure. The original code (Candidate A) has a for loop, but the Ground Truth's loop is a while loop. Wait, no\u2014the Ground Truth is the original code. So perhaps the diff is showing that the original code (the Ground Truth) was modified into Candidate A and B. But the user is asking which of A or B is closer to the original.\n\nWait, this is confusing. Let me re-express the problem.\n\nThe user says that the Ground Truth is the Source AST. The diff is between Candidate A and Candidate B. The user wants to know which of A or B is closer to the original Source AST.\n\nSo the original code (the Source AST) is the one provided. The diff shows that Candidate A and B are two versions that have been modified from the original. The user wants to know which of A or B is closer to the original.\n\nBut how can we compare if the original code is the Source AST? For example, in the first part of the diff, the original code (Candidate A) has a for loop, while the Ground Truth (original) has a while loop. Therefore, Candidate A is different from the original. But Candidate B may have a different structure. However, the user hasn't provided the original code's exact structure in the diff. Wait, the user provided the Ground Truth code as the original, and the diff is between A and B. So the original code is the Ground Truth, and the diff shows changes from the original to A and B. But the user is comparing A and B to see which is closer to the original.\n\nWait, perhaps the diff is showing that the original code (the Source AST) has been modified into A and B. So the user wants to know which of A or B is closer to the original.\n\nBut without knowing the original code's structure, how can we compare? Wait, the user provided the original code (Ground Truth), so we can compare the diff's A and B to the original.\n\nLet me look at the first part of the diff again. The original code (Ground Truth) has a while loop. In the diff, Candidate A has a for loop, and Candidate B has an if with do-while. So the original code's loop is a while loop, which is different from both A and B. However, the user's criteria are about Topology Match and Complexity.\n\nThe first criterion is Topology Match: Does the + code (Candidate B) restore a node type present in the Source but missing in Candidate A?\n\nIn the original code, there's a while loop. In Candidate A, the loop is a for loop. In Candidate B, it's an if statement with a do-while loop. So the node types (loop types) are different. However, the original code's loop is a while loop. So neither A nor B has a while loop. Therefore, the Topology Match criterion may not apply here. Alternatively, perhaps the original code has a switch statement, but the Ground Truth code doesn't have one. So the first criterion may not be applicable here.\n\nThe second criterion is Complexity: Does the + code (Candidate B) match the nesting depth of the Source?\n\nThe nesting depth refers to how nested the structures are. For example, the original code's loop is a while loop, which is a single level. In Candidate A, the loop is a for loop, which is also a single level. In Candidate B, it's an if statement followed by a do-while loop, which might be more nested. However, without knowing the exact structure of the original code, it's hard to assess.\n\nLooking at the second part of the diff: the original code (Candidate A) has:\n\nif(id != 0x16){\n    if(id != 0x54){\n        return 0x10;\n    }\n    return 0x11;\n}\n\nIn Candidate B, it's:\n\nif(id != 0x16){\n    if(id == 0x54){\n        return 0x11;\n    }\n    return 0x10;\n}\n\nComparing to the Ground Truth code, which part is this? The Ground Truth code has a section with:\n\nif(id == 0){\n    return id;\n} elseif(id){\n    ... some code ...\n} elseif(id + 1 > id){\n    return id;\n} else {\n    call(...);\n    id[id] = str;\n}\nreturn id;\n\nBut the diff's second part is about different conditions. However, the Ground Truth code's structure may have different nesting. For example, the original code has an if-else chain with multiple conditions. The diff's changes are about the conditions and returns.\n\nIn the Ground Truth code, after the initial loop, there's an if-else structure. The diff's changes are in a part that may be part of that structure. However, without seeing the exact original code's structure in that area, it's challenging.\n\nAlternatively, looking at the criteria again:\n\n1. Topology Match: Does the + code (Candidate B) restore a node type present in the Source but missing in Candidate A?\n\nIf the Source has a certain node type (like a switch statement), but Candidate A doesn't have it, and Candidate B does, then B would win. However, the Ground Truth code doesn't have a switch statement, so this criterion may not apply.\n\n2. Complexity: Does the + code match the nesting depth of the Source?\n\nIf the Source has a certain nesting depth, and Candidate B matches that, while Candidate A doesn't, then B would be better.\n\nAlternatively, looking at the loop structures. The original code's loop is a while loop. Candidate A uses a for loop, which is structurally different. Candidate B uses an if statement with a do-while loop, which is also different. However, perhaps the original code's loop structure is more similar to Candidate B's structure in terms of nesting. For example, the do-while loop may have a similar nesting depth as the original while loop.\n\nBut this is speculative. Another angle: the original code's loop is a while loop that decrements id until a condition is met. Candidate B's structure uses a do-while loop, which executes the body first and then checks the condition. This is similar to the original loop's behavior, which also checks the condition after decrementing. However, the original loop's condition is id && (condition), while Candidate B's do-while checks id != 0. This may not be directly comparable.\n\nIn terms of nesting depth,"
        }
      },
      {
        "binary": "task-file_file_printable-O2.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,long param_4,long param_5)\n\n{\n  byte bVar1;\n  ushort **ppuVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  bool bVar5;\n  \n  pbVar3 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    uVar4 = param_4 + 1;\n    while( true ) {\n      bVar1 = *(byte *)(uVar4 - 1);\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar2 = __ctype_b_loc(), (*(byte *)((long)*ppuVar2 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar3) break;\n        *pbVar3 = 0x5c;\n        pbVar3[1] = *(byte *)(uVar4 - 1) >> 6 | 0x30;\n        pbVar3[2] = *(byte *)(uVar4 - 1) >> 3 & 7 | 0x30;\n        pbVar3[3] = *(byte *)(uVar4 - 1) & 7 | 0x30;\n        pbVar3 = pbVar3 + 4;\n      }\n      else {\n        *pbVar3 = bVar1;\n        pbVar3 = pbVar3 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar3) ||\n         (bVar5 = (ulong)(param_5 + param_4) <= uVar4, uVar4 = uVar4 + 1, bVar5)) break;\n    }\n  }\n  *pbVar3 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, *id = id + id - 1;\n  type *id = call(id unsigned char id);\n  type *id = id + id;\n  for(id = id;  id < id && id < id && *id; id++){\n    if((id->id & id) != 0 || call(*id)){\n      *id++ = *id;\n      continue;\n    }\n    if(id >= id - 3)break;\n    *id++ = str;\n    *id++ = ((type)&7) + str;\n    *id++ = ((type)&7) + str;\n    *id++ = ((type)&7) + str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id + id + -1) && (0 < id)){\n    id = id;\n    while(bool){\n      id = id + 1;\n      id = *id;\n      if((type)id == 0)break;\n      if(((*(type)(id + 0x45) & 1) == 0) && (id = call()(*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0)){\n        if(id + id + -4 <= id)break;\n        *id = 0x5c;\n        id[1] = *id >> 6 | 0x30;\n        id[2] = *id >> 3 & 7 | 0x30;\n        id[3] = *id & 7 | 0x30;\n        id = id + 4;\n      }else{\n        *id = id;\n        id = id + 1;\n      }\n      if((id + id + -1 <= id) || (id = idid + id <= id))break;\n    }\n  }\n  *id = 0;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id,  id,  id){\n  type id;\n  type **id;\n  type *id;\n  type id;\n  type id;\n  id = id;\n  if((id < id + id + -1) && (0 < id)){\n    id = id + 1;\n    while(bool){\n      id = *(type)(id - 1);\n      if((type)id == 0)break;\n      if(((*(type)(id + 0x45) & 1) == 0) && (id = call()(*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0)){\n        if(id + id + -4 <= id)break;\n        *id = 0x5c;\n        id[1] = *(type)(id - 1) >> 6 | 0x30;\n        id[2] = *(type)(id - 1) >> 3 & 7 | 0x30;\n        id[3] = *(type)(id - 1) & 7 | 0x30;\n        id = id + 4;\n      }else{\n        *id = id;\n        id = id + 1;\n      }\n      if((id + id + -1 <= id) || (id = call(id + id) <= idid = id + 1id))break;\n    }\n  }\n  *id = 0;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.59375,
          "base_ppl": 2.46875,
          "pr_ppl": 2.5625,
          "source_ast_ppl": 5.75,
          "base_ast_ppl": 4.53125,
          "pr_ast_ppl": 4.53125,
          "delta_ppl": 0.09375
        },
        "llm_qualitative": {
          "motivation": "Candidate A uses clearer variable names (pbVar4, pbVar5) and avoids the comma operator in the loop condition, which makes the logic more straightforward and easier to follow. Candidate B's use of the comma operator in the break condition (bVar5 = ... , uVar4 = ...) introduces complexity and potential confusion, making the code feel more machine-like. The loop structure in A maintains a direct pointer-based approach, which aligns better with human-readable control flow.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "motivation": "Candidate A uses simpler, more direct conditions and pointer operations without convoluted function calls or ambiguous assignments in the break condition. While both candidates use low-level constructs, Candidate A's structure avoids the complexity of nested function calls and unclear variable manipulations in Candidate B, aligning closer with human-readable logic.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_printable-O3.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,long param_4,long param_5)\n\n{\n  byte bVar1;\n  ushort **ppuVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  bool bVar5;\n  \n  pbVar3 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    uVar4 = param_4 + 1;\n    while( true ) {\n      bVar1 = *(byte *)(uVar4 - 1);\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar2 = __ctype_b_loc(), (*(byte *)((long)*ppuVar2 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar3) break;\n        *pbVar3 = 0x5c;\n        pbVar3[1] = *(byte *)(uVar4 - 1) >> 6 | 0x30;\n        pbVar3[2] = *(byte *)(uVar4 - 1) >> 3 & 7 | 0x30;\n        pbVar3[3] = *(byte *)(uVar4 - 1) & 7 | 0x30;\n        pbVar3 = pbVar3 + 4;\n      }\n      else {\n        *pbVar3 = bVar1;\n        pbVar3 = pbVar3 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar3) ||\n         (bVar5 = (ulong)(param_5 + param_4) <= uVar4, uVar4 = uVar4 + 1, bVar5)) break;\n    }\n  }\n  *pbVar3 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, *id = id + id - 1;\n  type *id = call(id unsigned char id);\n  type *id = id + id;\n  for(id = id;  id < id && id < id && *id; id++){\n    if((id->id & id) != 0 || call(*id)){\n      *id++ = *id;\n      continue;\n    }\n    if(id >= id - 3)break;\n    *id++ = str;\n    *id++ = ((type)&7) + str;\n    *id++ = ((type)&7) + str;\n    *id++ = ((type)&7) + str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id + id + -1) && (0 < id)){\n    id = id;\n    while(bool){\n      id = id + 1;\n      id = *id;\n      if((type)id == 0)break;\n      if(((*(type)(id + 0x45) & 1) == 0) && (id = call()(*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0)){\n        if(id + id + -4 <= id)break;\n        *id = 0x5c;\n        id[1] = *id >> 6 | 0x30;\n        id[2] = *id >> 3 & 7 | 0x30;\n        id[3] = *id & 7 | 0x30;\n        id = id + 4;\n      }else{\n        *id = id;\n        id = id + 1;\n      }\n      if((id + id + -1 <= id) || (id = idid + id <= id))break;\n    }\n  }\n  *id = 0;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id,  id,  id){\n  type id;\n  type **id;\n  type *id;\n  type id;\n  type id;\n  id = id;\n  if((id < id + id + -1) && (0 < id)){\n    id = id + 1;\n    while(bool){\n      id = *(type)(id - 1);\n      if((type)id == 0)break;\n      if(((*(type)(id + 0x45) & 1) == 0) && (id = call()(*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0)){\n        if(id + id + -4 <= id)break;\n        *id = 0x5c;\n        id[1] = *(type)(id - 1) >> 6 | 0x30;\n        id[2] = *(type)(id - 1) >> 3 & 7 | 0x30;\n        id[3] = *(type)(id - 1) & 7 | 0x30;\n        id = id + 4;\n      }else{\n        *id = id;\n        id = id + 1;\n      }\n      if((id + id + -1 <= id) || (id = call(id + id) <= idid = id + 1id))break;\n    }\n  }\n  *id = 0;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.59375,
          "base_ppl": 2.46875,
          "pr_ppl": 2.5625,
          "source_ast_ppl": 5.75,
          "base_ast_ppl": 4.53125,
          "pr_ast_ppl": 4.53125,
          "delta_ppl": 0.09375
        },
        "llm_qualitative": {
          "motivation": "Candidate A uses clearer variable names (pbVar4, pbVar5) and avoids complex comma-operator expressions in loop conditions. Its control flow is more straightforward, with explicit checks for buffer boundaries and input exhaustion. Candidate B introduces a cryptic uVar4 with a comma-operator increment in the loop condition, which obscures the logic and increases cognitive load. The use of pointer arithmetic (uVar4 - 1) instead of direct variable references also reduces readability.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns closer with the Source Code structure by preserving the core logic of character processing and escape sequence handling. While both candidates use while loops instead of the original for loop, Candidate B maintains the conditional checks for printable characters and escape sequences more accurately. It also avoids introducing extraneous variables (e.g., `uVar4`) that complicate the logic, preserving the original's intent of copying or escaping characters based on their printable status.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      }
    ],
    "deepseek-r1": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type *id){\n  if(!id)return id;\n  type id = id0id0;\n  type id = id0id0;\n  type *id = null;\n  type id = 0;\n  type id = id;\n  call(str);\n  do{\n    if(id > 10){\n      call(str, (type)id->id);\n      call(str, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, 1, 4, id->id) != 4){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == null){\n        if(id)call(id, str, (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, 1, id.id, id->id) != id.id){\n        if(id)call(id, str);\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[0] + (id[1] << 8) != 0x600);\n        id->id = id[2] + (id[3] << 8);\n        if(id){\n          call(str, (id->id ? str : str));\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id->id = id[0] + (id[1] << 8);\n        if(id)call(str, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call(str);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }else{\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type *id;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            if(id)call(str, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type *id;\n          id = (type)id;\n          call(str, id->id & 0x07FF);\n          if(id->id & 0x8000){\n            call(str, id->id);\n            call(str, id->id);\n          }else{\n            type *id = call((type)&id[2], id.id - 2, 1, id);\n            call(str, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > 10){\n          type *id = id + 2;\n          type id, id;\n          id = id[0] + (id[1] << 8);\n          for(id = 0;  id < id; ++id){\n            call(str, id + 8, id[0], id[1], id[2]);\n            id = 4;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call(str);\n          for(id = 0;  id < id.id; ++id)call(str, id[id]);\n          call(str);\n        }\n        break;\n      case def:\n        if(id){\n          call(str, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = 1;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = call(id) * id;\n            *(type)((type)id + 0xd) = (id) * id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (type)(type)id[id * 2 + 1], (id) * (type)((type)id + id * 4 + 3), (type)(type)id[id * 2 + 2]);\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (type)(type)id[1]);\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = (type)call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = call(id) * id;\n            *(type)((type)id + 0xd) = (id) * id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (type)(type)id[id * 2 + 1], (id) * (type)((type)id + id * 4 + 3), (type)(type)id[id * 2 + 2]);\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (type)(type)id[1]);\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.0625,
          "base_ppl": 2.453125,
          "pr_ppl": 2.4375,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.328125,
          "pr_ast_ppl": 2.359375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A matches the source code structure better as it does not include the unnecessary cast to (ushort *) which is not present in the source. The change in Candidate B introduces noise without improving the logic.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate A maintains a cleaner and more natural structure without unnecessary type casting, which doesn't improve the semantic flow or reduce artificial nesting.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type *id){\n  if(!id)return id;\n  type id = id0id0;\n  type id = id0id0;\n  type *id = null;\n  type id = 0;\n  type id = id;\n  call(str);\n  do{\n    if(id > 10){\n      call(str, (type)id->id);\n      call(str, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, 1, 4, id->id) != 4){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == null){\n        if(id)call(id, str, (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, 1, id.id, id->id) != id.id){\n        if(id)call(id, str);\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[0] + (id[1] << 8) != 0x600);\n        id->id = id[2] + (id[3] << 8);\n        if(id){\n          call(str, (id->id ? str : str));\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id->id = id[0] + (id[1] << 8);\n        if(id)call(str, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call(str);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }else{\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type *id;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            if(id)call(str, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type *id;\n          id = (type)id;\n          call(str, id->id & 0x07FF);\n          if(id->id & 0x8000){\n            call(str, id->id);\n            call(str, id->id);\n          }else{\n            type *id = call((type)&id[2], id.id - 2, 1, id);\n            call(str, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > 10){\n          type *id = id + 2;\n          type id, id;\n          id = id[0] + (id[1] << 8);\n          for(id = 0;  id < id; ++id){\n            call(str, id + 8, id[0], id[1], id[2]);\n            id = 4;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call(str);\n          for(id = 0;  id < id.id; ++id)call(str, id[id]);\n          call(str);\n        }\n        break;\n      case def:\n        if(id){\n          call(str, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = 1;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = call(id) * id;\n            *(type)((type)id + 0xd) = (id) * id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (type)(type)id[id * 2 + 1], (id) * (type)((type)id + id * 4 + 3), (type)(type)id[id * 2 + 2]);\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (type)(type)id[1]);\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = (type)call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = call(id) * id;\n            *(type)((type)id + 0xd) = (id) * id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (type)(type)id[id * 2 + 1], (id) * (type)((type)id + id * 4 + 3), (type)(type)id[id * 2 + 2]);\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (type)(type)id[1]);\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.0625,
          "base_ppl": 2.453125,
          "pr_ppl": 2.4375,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.328125,
          "pr_ast_ppl": 2.359375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces an unnecessary type cast, deviating from the Source's structure. The Source does not use such a cast, making Candidate A more faithful.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "The change adds an explicit type cast, which is a concrete operation rather than enhancing the semantic structure. It doesn't improve the control flow's abstraction or reduce artificial constructs.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "type id(type *id){\n  if(!id)return id;\n  type id = id0id0;\n  type id = id0id0;\n  type *id = null;\n  type id = 0;\n  type id = id;\n  call(str);\n  do{\n    if(id > 10){\n      call(str, (type)id->id);\n      call(str, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, 1, 4, id->id) != 4){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == null){\n        if(id)call(id, str, (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, 1, id.id, id->id) != id.id){\n        if(id)call(id, str);\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[0] + (id[1] << 8) != 0x600);\n        id->id = id[2] + (id[3] << 8);\n        if(id){\n          call(str, (id->id ? str : str));\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id->id = id[0] + (id[1] << 8);\n        if(id)call(str, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call(str);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }else{\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type *id;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            if(id)call(str, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type *id;\n          id = (type)id;\n          call(str, id->id & 0x07FF);\n          if(id->id & 0x8000){\n            call(str, id->id);\n            call(str, id->id);\n          }else{\n            type *id = call((type)&id[2], id.id - 2, 1, id);\n            call(str, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > 10){\n          type *id = id + 2;\n          type id, id;\n          id = id[0] + (id[1] << 8);\n          for(id = 0;  id < id; ++id){\n            call(str, id + 8, id[0], id[1], id[2]);\n            id = 4;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call(str);\n          for(id = 0;  id < id.id; ++id)call(str, id[id]);\n          call(str);\n        }\n        break;\n      case def:\n        if(id){\n          call(str, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = 1;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = id;\n    call(&id, 0, 4);\n    call(&id, 0, 4);\n    id = (type)0x0;\n    id = bool;\n    id = 0;\n    call(str);\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        call(str, (id) * (type)(*id + 8), *(type)(*id + 0x10) & 0xffffffff, *(type)(*id + 0x20) & 0xffffffff, *(type)(*id + 0x28) & 0xffffffff);\n      }\n      id = call(&id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(&id);\n      if(*(type)id != 0){\n        call(&id);\n      }\n      if(id.id != 0){\n        id = call(id, (type)id.id);\n        if(id == (type)0x0){\n          if(*(type)id != 0){\n            call(*(type)id, str, (type)id.id);\n          }\n          id = 5;\n          break;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != 0){\n            call(*(type)id, str);\n          }\n          id = 3;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      id = id & 0xffff;\n      if(id != 10){\n        if(id == 0x18){\n          if(*(type)id != 0){\n            call(str);\n            for(id = 0;  id < (type)(id >> 0x10); id = id + 1){\n              call(str, (id) * (type)((type)id + (type)id));\n            }\n            call(str);\n          }\n        }elseif(id == 0x22){\n          *(type)((type)id + 0xd) = (id) * id;\n          if(*(type)id != 0){\n            call(str, (id) * (type)((type)id + 0xd));\n          }\n        }else{\n          if(id == 0x2f){\n            id = 6;\n            break;\n          }\n          if(id == 0x31){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n          }elseif(id == 0x3c){\n            if(id){\n              if(((type)id == 0xfc) && (id = call(id, id, id.id)id != 0))break;\n              id = id;\n            }\n          }elseif(id == 0x3d){\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, (id) * id / 0x14, (id) * id % 0x14);\n              call(str, (type)id[1] / 0x14, (type)id[1] % 0x14);\n              call(str, (type)id[2] / 0x14, (type)id[2] % 0x14);\n              call(str, (type)id[3] / 0x14, (type)id[3] % 0x14);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              call(str, (type)id[8]);\n            }\n          }elseif(id == 0x42){\n            *(type)((type)id + 0x12) = call(id) * id + (id) * (type)((type)id + 1) * 0x100;\n            if(*(type)id != 0){\n              call(str, (id) * (type)((type)id + 0x12));\n            }\n          }elseif(id == 0x85){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != 0)break;\n          }elseif(id == 0x92){\n            if(10 < *(type)id){\n              id = id + 1;\n              id = *id;\n              id = *(type)((type)id + 1);\n              for(id = 0;  id < (type)((type)(type)id + (type)id * 0x100); id = id + 1){\n                call(str, call(id + 8), call(id) * id, (id) * (type)((type)id + 1), (type)(type)id[1]);\n                id = id + 2;\n              }\n            }\n          }elseif(id == 0xe0){\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(str, (id) * id);\n                call(str, (type)id[1]);\n                call(str, (type)id[2]);\n                call(str, (type)id[3]);\n                call(str, (type)id[4]);\n                call(str, (type)id[5]);\n                call(str, (type)id[6]);\n                call(str, (type)id[7]);\n              }\n            }\n          }else{\n            if(id == 0xfc){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != 0xff){\n              if(id == 0x231)goto lbl;\n              if(id == 0x293){\n                if(*(type)id != 0){\n                  call(str, call(*id & 0x7ff));\n                  if((*id & 0x8000) == 0){\n                    id = (type)call(id + 1, (type)(type)((id >> 0x10) - 2), 1, id);\n                    call(str, id);\n                    call(id);\n                  }else{\n                    call(str, (type)(type)id[1]);\n                    call(str, (id) * (type)((type)id + 3));\n                  }\n                }\n              }else{\n                if(id == 0x41e){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == 0x809){\n                  *(type)((type)id + 0xc) = call(id) * id + (id) * (type)((type)id + 1) * 0x100 != 0x600;\n                  *(type)((type)id + 0xe) = (type)(type)id[1] + (id) * (type)((type)id + 3) * 0x100;\n                  if(*(type)id != 0){\n                    id = str;\n                    if(*(type)((type)id + 0xc) != str){\n                      id = str;\n                    }\n                    call(str, id);\n                    call(str, (id) * (type)((type)id + 0xe));\n                  }\n                }elseif(*(type)id != 0){\n                  call(str, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id + 0x3c) == str){\n        id = (type)id != 10;\n      }\n    }while(id);\n    if(id != (type)0x0){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = id;\n    call(&id, 0, 4);\n    call(&id, 0, 4);\n    id = (type)0x0;\n    id = bool;\n    id = 0;\n    call(str);\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        call(str, (id) * (type)(*id + 8), *(type)(*id + 0x10) & 0xffffffff, *(type)(*id + 0x20) & 0xffffffff, *(type)(*id + 0x28) & 0xffffffff);\n      }\n      id = call(&id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(&id);\n      if(*(type)id != 0){\n        call(&id);\n      }\n      if(id.id != 0){\n        id = (type)call(id, (type)id.id);\n        if(id == (type)0x0){\n          if(*(type)id != 0){\n            call(*(type)id, str, (type)id.id);\n          }\n          id = 5;\n          break;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != 0){\n            call(*(type)id, str);\n          }\n          id = 3;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      id = id & 0xffff;\n      if(id != 10){\n        if(id == 0x18){\n          if(*(type)id != 0){\n            call(str);\n            for(id = 0;  id < (type)(id >> 0x10); id = id + 1){\n              call(str, (id) * (type)((type)id + (type)id));\n            }\n            call(str);\n          }\n        }elseif(id == 0x22){\n          *(type)((type)id + 0xd) = (id) * id;\n          if(*(type)id != 0){\n            call(str, (id) * (type)((type)id + 0xd));\n          }\n        }else{\n          if(id == 0x2f){\n            id = 6;\n            break;\n          }\n          if(id == 0x31){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n          }elseif(id == 0x3c){\n            if(id){\n              if(((type)id == 0xfc) && (id = call(id, id, id.id)id != 0))break;\n              id = id;\n            }\n          }elseif(id == 0x3d){\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, (id) * id / 0x14, (id) * id % 0x14);\n              call(str, (type)id[1] / 0x14, (type)id[1] % 0x14);\n              call(str, (type)id[2] / 0x14, (type)id[2] % 0x14);\n              call(str, (type)id[3] / 0x14, (type)id[3] % 0x14);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              call(str, (type)id[8]);\n            }\n          }elseif(id == 0x42){\n            *(type)((type)id + 0x12) = call(id) * id + (id) * (type)((type)id + 1) * 0x100;\n            if(*(type)id != 0){\n              call(str, (id) * (type)((type)id + 0x12));\n            }\n          }elseif(id == 0x85){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != 0)break;\n          }elseif(id == 0x92){\n            if(10 < *(type)id){\n              id = id + 1;\n              id = *id;\n              id = *(type)((type)id + 1);\n              for(id = 0;  id < (type)((type)(type)id + (type)id * 0x100); id = id + 1){\n                call(str, call(id + 8), call(id) * id, (id) * (type)((type)id + 1), (type)(type)id[1]);\n                id = id + 2;\n              }\n            }\n          }elseif(id == 0xe0){\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(str, (id) * id);\n                call(str, (type)id[1]);\n                call(str, (type)id[2]);\n                call(str, (type)id[3]);\n                call(str, (type)id[4]);\n                call(str, (type)id[5]);\n                call(str, (type)id[6]);\n                call(str, (type)id[7]);\n              }\n            }\n          }else{\n            if(id == 0xfc){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != 0xff){\n              if(id == 0x231)goto lbl;\n              if(id == 0x293){\n                if(*(type)id != 0){\n                  call(str, call(*id & 0x7ff));\n                  if((*id & 0x8000) == 0){\n                    id = (type)call(id + 1, (type)(type)((id >> 0x10) - 2), 1, id);\n                    call(str, id);\n                    call(id);\n                  }else{\n                    call(str, (type)(type)id[1]);\n                    call(str, (id) * (type)((type)id + 3));\n                  }\n                }\n              }else{\n                if(id == 0x41e){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == 0x809){\n                  *(type)((type)id + 0xc) = call(id) * id + (id) * (type)((type)id + 1) * 0x100 != 0x600;\n                  *(type)((type)id + 0xe) = (type)(type)id[1] + (id) * (type)((type)id + 3) * 0x100;\n                  if(*(type)id != 0){\n                    id = str;\n                    if(*(type)((type)id + 0xc) != str){\n                      id = str;\n                    }\n                    call(str, id);\n                    call(str, (id) * (type)((type)id + 0xe));\n                  }\n                }elseif(*(type)id != 0){\n                  call(str, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id + 0x3c) == str){\n        id = (type)id != 10;\n      }\n    }while(id);\n    if(id != (type)0x0){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.0625,
          "base_ppl": 2.328125,
          "pr_ppl": 2.328125,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.453125,
          "pr_ast_ppl": 2.453125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A aligns with the Source Code's use of a void pointer for the buffer, maintaining the correct handling of arbitrary bytes without unnecessary type casting. Candidate B introduces a (ushort *) cast, which may not be necessary and could lead to incorrect data handling.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate A avoids unnecessary explicit casting, relying on the language's type system, which is more abstract and human-like. It reduces noise and artificial nesting, making the code cleaner and more idiomatic.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A correctly mirrors the source AST by not introducing a type cast, which preserves the original node structure. Candidate B adds an unnecessary type cast, altering the AST topology.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 + 1];\n  type id[64 + 1];\n  type *id = null;\n  type id = 0;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id++;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 5:\n        {\n          id = id;\n        }\n        break;\n        case 6:\n        {\n          id = id - id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id++;\n              }\n            }\n          }\n          break;\n          case 4:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case 6:\n          {\n            id = id - id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id - id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = (type)call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = (type)call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.296875,
          "pr_ast_ppl": 2.28125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more concise and avoids unnecessary type casting, which doesn't change the logic flow and thus is cleaner and more aligned with human engineering practices by preferring less artificial structure.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate A matches the Source AST exactly without adding unnecessary type casts, preserving the original structure.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 + 1];\n  type id[64 + 1];\n  type *id = null;\n  type id = 0;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id++;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 5:\n        {\n          id = id;\n        }\n        break;\n        case 6:\n        {\n          id = id - id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id++;\n              }\n            }\n          }\n          break;\n          case 4:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case 6:\n          {\n            id = id - id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id - id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = (type)call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = (type)call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.296875,
          "pr_ast_ppl": 2.28125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A matches the Source Code's structure without unnecessary casting, maintaining the original logic and control flow.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 * 4 + 1];\n  type id = 0;\n  type *id = null;\n  type id = 0;\n  type id = 1024 + id;\n  type *id = null;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id - 1;\n            while(id >= id && call(id->id, id) == 0){\n              id = id;\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              id = id;\n              id++;\n            }\n            for(id = id;  id <= id; id++){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          if((*id) != str){\n            type id = (*id) - str;\n            if(id <= (id - id) / 10){\n              id = 10 * id + id;\n            }else{\n              {\n                id++;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case 5:\n        {\n          id = 0;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id - 1;\n              while(id >= id && call(id->id, id) == 0){\n                id = id;\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                id = id;\n                id++;\n              }\n              for(id = id;  id <= id; id++){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id - id), (type)(id - id), (type)(id - id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = (type)call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = (type)call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.671875,
          "base_ppl": 2.28125,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 2.640625,
          "base_ast_ppl": 2.546875,
          "pr_ast_ppl": 2.546875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A matches the source code structure more closely as it does not include the unnecessary cast to `char *` which is not present in the source. Candidate B introduces a cast that alters the type, deviating from the source.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 * 4 + 1];\n  type id = 0;\n  type *id = null;\n  type id = 0;\n  type id = 1024 + id;\n  type *id = null;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id - 1;\n            while(id >= id && call(id->id, id) == 0){\n              id = id;\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              id = id;\n              id++;\n            }\n            for(id = id;  id <= id; id++){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          if((*id) != str){\n            type id = (*id) - str;\n            if(id <= (id - id) / 10){\n              id = 10 * id + id;\n            }else{\n              {\n                id++;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case 5:\n        {\n          id = 0;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id - 1;\n              while(id >= id && call(id->id, id) == 0){\n                id = id;\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                id = id;\n                id++;\n              }\n              for(id = id;  id <= id; id++){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id - id), (type)(id - id), (type)(id - id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = (type)call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = (type)call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.671875,
          "base_ppl": 2.296875,
          "pr_ppl": 2.28125,
          "source_ast_ppl": 2.640625,
          "base_ast_ppl": 2.546875,
          "pr_ast_ppl": 2.546875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "motivation": "Candidate A avoids unnecessary type casting, which reduces artificial complexity and keeps the code cleaner. This aligns with high-level human thinking by maintaining clarity and semantic structure.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A mirrors the Source AST as it doesn't introduce unnecessary type casting, matching the Source's structure exactly. Candidate B adds a type cast node, altering the topology.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 + 1];\n  type id[64 + 1];\n  type *id = null;\n  type id = 0;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id++;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 5:\n        {\n          id = id;\n        }\n        break;\n        case 6:\n        {\n          id = id - id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id++;\n              }\n            }\n          }\n          break;\n          case 4:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case 6:\n          {\n            id = id - id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id - id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[8192];\n  type id;\n  type *id;\n  type id[79];\n  type id[9];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + (type)id;\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)*(type)(id + (type)id * 2);\n    id = (id) * (type)(id + (type)id * 2);\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] + 0x2c];\n      id = &id + (type)(type)id[id];\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id == (type)0x0){\n              call(id, 0x2000, str, id);\n              if(*(type)(id + 0x30) != 0){\n                call(id, *(type)(id + 0x50));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id + -0x28;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id;\n              }\n            }\n            break;\n          case 4:\n            call(id, id, id);\n            id[id] = 0;\n            break;\n          case 5:\n            id = id;\n            break;\n          case 6:\n            id = (type)id - (type)id;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] + 0x2c];\n    id = &id + (type)(type)id[id];\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, 0x28, id);\n        id = id;\n        if(id == (type)0x0){\n          call(id, 0x2000, str, id);\n          if(*(type)(id + 0x30) != 0){\n            call(id, *(type)(id + 0x50));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id + -0x28;\n          }\n          while(bool){\n            id = id + 0x28;\n            id = bool;\n            if(((type)id - (type)id) / 0x28 < (type)id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = 0;\n      }elseif(id == str){\n        id = (type)id - (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, (type)id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[8192];\n  type id;\n  type *id;\n  type id[79];\n  type id[9];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + (type)id;\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)*(type)(id + (type)id * 2);\n    id = (id) * (type)(id + (type)id * 2);\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] + 0x2c];\n      id = &id + (type)(type)id[id];\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = (type)call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id == (type)0x0){\n              call(id, 0x2000, str, id);\n              if(*(type)(id + 0x30) != 0){\n                call(id, *(type)(id + 0x50));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id + -0x28;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id;\n              }\n            }\n            break;\n          case 4:\n            call(id, id, id);\n            id[id] = 0;\n            break;\n          case 5:\n            id = id;\n            break;\n          case 6:\n            id = (type)id - (type)id;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] + 0x2c];\n    id = &id + (type)(type)id[id];\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = (type)call(id, id, (type)id, 0x28, id);\n        id = id;\n        if(id == (type)0x0){\n          call(id, 0x2000, str, id);\n          if(*(type)(id + 0x30) != 0){\n            call(id, *(type)(id + 0x50));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id + -0x28;\n          }\n          while(bool){\n            id = id + 0x28;\n            id = bool;\n            if(((type)id - (type)id) / 0x28 < (type)id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = 0;\n      }elseif(id == str){\n        id = (type)id - (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, (type)id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 1.9921875,
          "pr_ppl": 1.9765625,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.21875,
          "pr_ast_ppl": 2.203125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A aligns with the Source Code structure as it does not include unnecessary type casting, which is absent in the Source. Candidate B introduces a cast that is not present in the Source, deviating from its structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate B introduces an unnecessary line `id = id;`, which adds artificial nesting and depth without improving the logic. This makes the code more machine-like by adding redundant steps, whereas Candidate A maintains cleaner, more semantic structure.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 * 4 + 1];\n  type id = 0;\n  type *id = null;\n  type id = 0;\n  type id = 1024 + id;\n  type *id = null;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id - 1;\n            while(id >= id && call(id->id, id) == 0){\n              id = id;\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              id = id;\n              id++;\n            }\n            for(id = id;  id <= id; id++){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          if((*id) != str){\n            type id = (*id) - str;\n            if(id <= (id - id) / 10){\n              id = 10 * id + id;\n            }else{\n              {\n                id++;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case 5:\n        {\n          id = 0;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id - 1;\n              while(id >= id && call(id->id, id) == 0){\n                id = id;\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                id = id;\n                id++;\n              }\n              for(id = id;  id <= id; id++){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id - id), (type)(id - id), (type)(id - id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + 0x400;\n  id = id + id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id + (type)(type)(type)id[id] + 1;\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id != (type)0x0){\n              while(bool){\n                id = id + -0x28;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id + 0x28){\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n              }\n            }\n            break;\n          case 4:\n            if(*id != 0){\n              if((-call(*id - 0x30) - 1) / 10 < id){\n                id = id + 1;\n                goto lbl;\n              }\n              id = id * 10 + call(*id - 0x30);\n            }\n            break;\n          case 5:\n            id = 0;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id + (type)(type)(type)id[id] + 1;\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        while(bool){\n          id = id + -0x28;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id + 0x28;\n          id = bool;\n          if(((type)id - (type)id) / 0x28 < (type)id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id + 0x28){\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)id, str, (type)id - (type)id, (type)id - (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + 0x400;\n  id = id + id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id + (type)(type)(type)id[id] + 1;\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = (type)call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id != (type)0x0){\n              while(bool){\n                id = id + -0x28;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id + 0x28){\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n              }\n            }\n            break;\n          case 4:\n            if(*id != 0){\n              if((-call(*id - 0x30) - 1) / 10 < id){\n                id = id + 1;\n                goto lbl;\n              }\n              id = id * 10 + call(*id - 0x30);\n            }\n            break;\n          case 5:\n            id = 0;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id + (type)(type)(type)id[id] + 1;\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = (type)call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        while(bool){\n          id = id + -0x28;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id + 0x28;\n          id = bool;\n          if(((type)id - (type)id) / 0x28 < (type)id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id + 0x28){\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)id, str, (type)id - (type)id, (type)id - (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.671875,
          "base_ppl": 2.0625,
          "pr_ppl": 2.046875,
          "source_ast_ppl": 2.640625,
          "base_ast_ppl": 2.15625,
          "pr_ast_ppl": 2.15625,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A aligns with the Source Code structure by correctly assigning the pointer without an unnecessary cast, preserving the correct type. Candidate B introduces a cast to (char *), which deviates from the Source's varlookup_t * pointer, leading to a type mismatch and thus is less faithful.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[0].id == id)return id;\n  type id = 0;\n  type id = bool;\n  type id = bool;\n  type id = 0;\n  do{\n    type id;\n    for(id = 0;  id[id].id != id[id].id; ++id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[++id].id != id);\n  if(id > id || !id || id > 3)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if(id != (type)0x0){\n    id = *id;\n    if(id != -1){\n      id = 0;\n      id = 0;\n      id = 8;\n      id = bool;\n      do{\n        id = id + 2;\n        id = 1;\n        id = bool;\n        switch(id){\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 0xb:\n            id = bool;\n            id = 0;\n            break;\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x18:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n            goto lbl;\n          case 0x21:\n            break;\n          case def:\n            id = 1;\n            id = bool;\n            if(1 < id + 0xbfffffffffffffffU)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id + id;\n        id = id + 1;\n        id = *id;\n        id = id;\n      }while(id != -1);\n      if((id == 1 && id < 5) && (id < 4)){\n        *id = id;\n        id = 0;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if(id != (type)0x0){\n    id = *id;\n    if(id != -1){\n      id = id + 2;\n      id = 0;\n      id = 0;\n      id = 8;\n      id = bool;\n      do{\n        id = 1;\n        id = bool;\n        switch(id){\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 0xb:\n            id = bool;\n            id = 0;\n            break;\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x18:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n            goto lbl;\n          case 0x21:\n            break;\n          case def:\n            id = 1;\n            id = bool;\n            if(1 < id + 0xbfffffffffffffffU)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id + id;\n        id = id + 1;\n        id = *id;\n        id = id + 2;\n        id = id;\n      }while(id != -1);\n      if((id == 1 && id < 5) && (id < 4)){\n        *id = id;\n        id = 0;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 2.140625,
          "pr_ppl": 2.109375,
          "source_ast_ppl": 7.09375,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.65625,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[0].id == id)return id;\n  type id = 0;\n  type id = bool;\n  type id = bool;\n  type id = 0;\n  do{\n    type id;\n    for(id = 0;  id[id].id != id[id].id; ++id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[++id].id != id);\n  if(id > id || !id || id > 3)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if(id != (type)0x0){\n    id = *id;\n    if(id != -1){\n      id = 0;\n      id = 0;\n      id = 8;\n      id = bool;\n      do{\n        id = id + 2;\n        id = 1;\n        id = bool;\n        switch(id){\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 0xb:\n            id = bool;\n            id = 0;\n            break;\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x18:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n            goto lbl;\n          case 0x21:\n            break;\n          case def:\n            id = 1;\n            id = bool;\n            if(1 < id + 0xbfffffffffffffffU)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id + id;\n        id = id + 1;\n        id = *id;\n        id = id;\n      }while(id != -1);\n      if((id == 1 && id < 5) && (id < 4)){\n        *id = id;\n        id = 0;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if(id != (type)0x0){\n    id = *id;\n    if(id != -1){\n      id = id + 2;\n      id = 0;\n      id = 0;\n      id = 8;\n      id = bool;\n      do{\n        id = 1;\n        id = bool;\n        switch(id){\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 0xb:\n            id = bool;\n            id = 0;\n            break;\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x18:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n            goto lbl;\n          case 0x21:\n            break;\n          case def:\n            id = 1;\n            id = bool;\n            if(1 < id + 0xbfffffffffffffffU)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id + id;\n        id = id + 1;\n        id = *id;\n        id = id + 2;\n        id = id;\n      }while(id != -1);\n      if((id == 1 && id < 5) && (id < 4)){\n        *id = id;\n        id = 0;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 2.140625,
          "pr_ppl": 2.109375,
          "source_ast_ppl": 7.09375,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.65625,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_zmagic-O2.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type *id = null;\n  type id, id;\n  type *id;\n  type *id;\n  type id, id, id = 0;\n  type id = id->id & id;\n  type id = id->id;\n  type *id = call(id unsigned char id->id);\n  type id = id->id;\n  type id = 0;\n  type id;\n  if((id->id & id) == 0)return 0;\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, -1, null, id, id, id);\n        if(id == -1)goto lbl;\n        id = 1;\n        if((id->id & id) != 0)goto lbl;\n        if(id != id && id != 0)goto lbl;\n        if((call(id, (id ? str : str))) == -1)goto lbl;\n        if((id = call(id)) == null)goto lbl;\n        if(call(id, -1, null, null, id, id) == -1){\n          if(call(id, id) != null)call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != null){\n          if(call(id, str, id) == -1){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, str) == -1)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = -1;\n        break;\n    }\n  }\n  lbl:\n  call(str, id);\n  if(id && id.id != id)(type)call(id, &id, null);\n  call(id);\n  id->id = id;\n  call(str, id);\n  return id;\n}",
        "base_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < 0){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "pr_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(0 < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.28125,
          "base_ppl": 3.03125,
          "pr_ppl": 3.03125,
          "source_ast_ppl": 4.59375,
          "base_ast_ppl": 3.59375,
          "pr_ast_ppl": 3.578125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B's condition is more direct and readable. It avoids unnecessary negation and clearly expresses the intended check, making the code more idiomatic and easier to understand.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B simplifies the condition to be more readable without changing the logic, aligning better with the Source Code's structure.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate B's condition aligns with the Source's structure, using a standard comparison after a cast, which is common in the Source's if statements.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-file_file_zmagic-O3.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type *id = null;\n  type id, id;\n  type *id;\n  type *id;\n  type id, id, id = 0;\n  type id = id->id & id;\n  type id = id->id;\n  type *id = call(id unsigned char id->id);\n  type id = id->id;\n  type id = 0;\n  type id;\n  if((id->id & id) == 0)return 0;\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, -1, null, id, id, id);\n        if(id == -1)goto lbl;\n        id = 1;\n        if((id->id & id) != 0)goto lbl;\n        if(id != id && id != 0)goto lbl;\n        if((call(id, (id ? str : str))) == -1)goto lbl;\n        if((id = call(id)) == null)goto lbl;\n        if(call(id, -1, null, null, id, id) == -1){\n          if(call(id, id) != null)call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != null){\n          if(call(id, str, id) == -1){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, str) == -1)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = -1;\n        break;\n    }\n  }\n  lbl:\n  call(str, id);\n  if(id && id.id != id)(type)call(id, &id, null);\n  call(id);\n  id->id = id;\n  call(str, id);\n  return id;\n}",
        "base_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < 0){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "pr_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(0 < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.28125,
          "base_ppl": 3.03125,
          "pr_ppl": 3.03125,
          "source_ast_ppl": 4.59375,
          "base_ast_ppl": 3.59375,
          "pr_ast_ppl": 3.578125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by simplifying the condition to check if uVar1 is positive directly, which is more idiomatic and easier to understand. The change makes the logic clearer and reduces the cognitive load, aligning with human-like abstraction.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Both versions are structurally isomorphic as they maintain the same control flow. However, Candidate B's condition is clearer and more direct, aligning better with typical code readability without altering functionality.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate A correctly restores the condition that checks if the negated id is less than 0, which aligns with the Source's structure where after negating id, a negative check is performed.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O0.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "function_pr": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id = 0;\n  type id = id;\n  type *id = id->id;\n  type *id = call(1, (id));\n  type *id = call(1, (id));\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id > 0)id->id = id->id;\n  if(call(id, id->id) == -1){\n    id = id;\n    goto lbl;\n  }\n  if((id->id = call(0, id, id->id)) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if(call(0, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id, id, id->id.id, id)) != id){\n    goto lbl;\n  }\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = call() ^ id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = (id->id ? 8 : 4);\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id == null){\n    id->id = id->id;\n  }\n  if((id->id = call(id->id)) == null){\n    id = id;\n    goto lbl;\n  }\n  if(id->id && id->id && call(id->id, id->id) != 0){\n    type id = call(id->id, id->id);\n    if(id == (id) - 1){\n      id = id;\n      goto lbl;\n    }\n    id->id = id;\n  }\n  if((id = call(id->id, (id->id), id->id, (id->id), id->id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, &id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, id)) != id){\n    goto lbl;\n  }\n  if(call(id->id, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, 0)) != id){\n    goto lbl;\n  }\n  if(id->id.id && id->id != id->id){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  lbl:\n  call(id->id);\n  if(id == id || id == id || id == id){\n    if(id->id.id){\n      call(id->id, (id->id), str, call(id), id, call(id), id);\n      call(id->id, id);\n    }\n  }\n  if(id)call(id);\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = *(type)((type)id + 0x40);\n  id = id;\n  id = id;\n  id = id;\n  id = call(1, 0xdd0);\n  id = call(1, 0x180);\n  call(id, id, 0x40);\n  *(type)((type)id + 0x120) = *(type)((type)id + 0x48);\n  *(type)((type)id + 0x128) = *(type)((type)id + 0x50);\n  *(type)((type)id + 0x58) = id;\n  *(type)((type)id + 0x60) = *(type)((type)id + 0x40);\n  *(type)((type)id + 0x80) = (type)*(type)((type)id + 0x58);\n  if(0 < *(type)((type)id + 0x60)){\n    *(type)((type)id + 0x84) = (type)*(type)((type)id + 0x60);\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n  }else{\n    id = call(0, 2, id[5]);\n    *(type)((type)id + 0x40) = id;\n    if(id == -1){\n      id = 0xf;\n      if(*(type)((type)id + 0x30) != 0){\n        call((type)((type)id + 0x5ce), 0x800, str);\n        call((type)id + 0x5ce, *(type)((type)id + 0x58));\n      }\n    }else{\n      id = call(0, 0, id[5]);\n      if(id == -1){\n        id = 0xf;\n        if(*(type)((type)id + 0x30) != 0){\n          call((type)((type)id + 0x5ce), 0x800, str);\n          call((type)id + 0x5ce, *(type)((type)id + 0x58));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id + 0x30), id);\n        if(id == 0){\n          *(type)((type)id + 0x4c) = id[1];\n          *(type)((type)id + 0x48) = *id;\n          *(type)((type)id + 0x50) = id[2];\n          id = call();\n          *(type)((type)id + 0x68) = id ^ *id;\n          *(type)((type)id + 0x88) = *(type)(id + 0x10);\n          *(type)((type)id + 0x90) = *(type)(id + 0xe);\n          *(type)((type)id + 0x98) = *(type)(id + 8);\n          *(type)((type)id + 0xb0) = *(type)(id + 10);\n          *(type)((type)id + 0xc0) = *(type)(id + 0xc);\n          id = 4;\n          if(*(type)((type)id + 0x4c) != 0){\n            id = 8;\n          }\n          *(type)((type)id + 0xb8) = (type)id;\n          *(type)((type)id + 0x138) = *(type)(id + 0x12);\n          *(type)((type)id + 0x140) = *(type)(id + 0x14);\n          *(type)((type)id + 0x148) = id[3];\n          if(*(type)((type)id + 0x120) == 0){\n            *(type)((type)id + 0x120) = *(type)(id + 0x5e);\n          }\n          id = call(*(type)((type)id + 0x98));\n          *(type)((type)id + 0xa0) = id;\n          if(id == 0){\n            id = 3;\n          }else{\n            if(((*(type)((type)id + 0x120) != 0) && (*(type)((type)id + 0x128) != 0)) && (id = call(*(type)((type)id + 0x120), *(type)((type)id + 0x128))id != 0)){\n              id = call(*(type)((type)id + 0x128), *(type)((type)id + 0x120));\n              if(id == (type)0xffffffffffffffff){\n                id = 7;\n                goto lbl;\n              }\n              *(type)((type)id + 0x130) = id;\n            }\n            id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, *(type)((type)id + 0x130));\n            if(((id == 0) && (id = call(id, &id)id == 0)) && (id = call(id, id)id == 0)){\n              id = call(*(type)((type)id + 0x88), 0, id[5]);\n              if(id == -1){\n                id = 0xf;\n                if(*(type)((type)id + 0x30) != 0){\n                  call((type)((type)id + 0x5ce), 0x800, str, *(type)((type)id + 0x88));\n                  call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                }\n              }else{\n                id = call(id);\n                if((id == 0) && (id = call(id, 0)id == 0)){\n                  if((*(type)((type)id + 0x20) == 0) || (*(type)((type)id + 0x78) == *(type)((type)id + 0x80))){\n                    id = call(id);\n                  }else{\n                    id = 9;\n                    if(*(type)((type)id + 0x30) != 0){\n                      call((type)((type)id + 0x5ce), 0x800, str, (id) * (type)((type)id + 0x80), (id) * (type)((type)id + 0x78));\n                      call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[5]);\n  if((((id == 1) || (id == 2)) || (id == 0xf)) && (*(type)((type)id + 0x30) != 0)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id + 0x5ce), 0x800, str, id, (type)id, id, *id);\n    call((type)id + 0x5ce, id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = *(type)((type)id + 0x40);\n  id = id;\n  id = id;\n  id = id;\n  id = call(1, 0xdd0);\n  id = (type)call(1, 0x180);\n  call(id, id, 0x40);\n  *(type)((type)id + 0x120) = *(type)((type)id + 0x48);\n  *(type)((type)id + 0x128) = *(type)((type)id + 0x50);\n  *(type)((type)id + 0x58) = id;\n  *(type)((type)id + 0x60) = *(type)((type)id + 0x40);\n  *(type)((type)id + 0x80) = (type)*(type)((type)id + 0x58);\n  if(0 < *(type)((type)id + 0x60)){\n    *(type)((type)id + 0x84) = (type)*(type)((type)id + 0x60);\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n  }else{\n    id = call(0, 2, id[5]);\n    *(type)((type)id + 0x40) = id;\n    if(id == -1){\n      id = 0xf;\n      if(*(type)((type)id + 0x30) != 0){\n        call((type)((type)id + 0x5ce), 0x800, str);\n        call((type)id + 0x5ce, *(type)((type)id + 0x58));\n      }\n    }else{\n      id = call(0, 0, id[5]);\n      if(id == -1){\n        id = 0xf;\n        if(*(type)((type)id + 0x30) != 0){\n          call((type)((type)id + 0x5ce), 0x800, str);\n          call((type)id + 0x5ce, *(type)((type)id + 0x58));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id + 0x30), id);\n        if(id == 0){\n          *(type)((type)id + 0x4c) = id[1];\n          *(type)((type)id + 0x48) = *id;\n          *(type)((type)id + 0x50) = id[2];\n          id = call();\n          *(type)((type)id + 0x68) = id ^ *id;\n          *(type)((type)id + 0x88) = *(type)(id + 0x10);\n          *(type)((type)id + 0x90) = *(type)(id + 0xe);\n          *(type)((type)id + 0x98) = *(type)(id + 8);\n          *(type)((type)id + 0xb0) = *(type)(id + 10);\n          *(type)((type)id + 0xc0) = *(type)(id + 0xc);\n          id = 4;\n          if(*(type)((type)id + 0x4c) != 0){\n            id = 8;\n          }\n          *(type)((type)id + 0xb8) = (type)id;\n          *(type)((type)id + 0x138) = *(type)(id + 0x12);\n          *(type)((type)id + 0x140) = *(type)(id + 0x14);\n          *(type)((type)id + 0x148) = id[3];\n          if(*(type)((type)id + 0x120) == 0){\n            *(type)((type)id + 0x120) = *(type)(id + 0x5e);\n          }\n          id = call(*(type)((type)id + 0x98));\n          *(type)((type)id + 0xa0) = id;\n          if(id == 0){\n            id = 3;\n          }else{\n            if(((*(type)((type)id + 0x120) != 0) && (*(type)((type)id + 0x128) != 0)) && (id = call(*(type)((type)id + 0x120), *(type)((type)id + 0x128))id != 0)){\n              id = call(*(type)((type)id + 0x128), *(type)((type)id + 0x120));\n              if(id == (type)0xffffffffffffffff){\n                id = 7;\n                goto lbl;\n              }\n              *(type)((type)id + 0x130) = id;\n            }\n            id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, *(type)((type)id + 0x130));\n            if(((id == 0) && (id = call(id, &id)id == 0)) && (id = call(id, id)id == 0)){\n              id = call(*(type)((type)id + 0x88), 0, id[5]);\n              if(id == -1){\n                id = 0xf;\n                if(*(type)((type)id + 0x30) != 0){\n                  call((type)((type)id + 0x5ce), 0x800, str, *(type)((type)id + 0x88));\n                  call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                }\n              }else{\n                id = call(id);\n                if((id == 0) && (id = call(id, 0)id == 0)){\n                  if((*(type)((type)id + 0x20) == 0) || (*(type)((type)id + 0x78) == *(type)((type)id + 0x80))){\n                    id = call(id);\n                  }else{\n                    id = 9;\n                    if(*(type)((type)id + 0x30) != 0){\n                      call((type)((type)id + 0x5ce), 0x800, str, (id) * (type)((type)id + 0x80), (id) * (type)((type)id + 0x78));\n                      call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[5]);\n  if((((id == 1) || (id == 2)) || (id == 0xf)) && (*(type)((type)id + 0x30) != 0)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id + 0x5ce), 0x800, str, id, (type)id, id, *id);\n    call((type)id + 0x5ce, id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.484375,
          "base_ppl": 2.140625,
          "pr_ppl": 2.140625,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B adds an explicit type cast, making the code more readable and type-safe, which aligns with good human engineering practices by improving clarity.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O2.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "function_pr": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = (undefined8 *)calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id = 0;\n  type id = id;\n  type *id = id->id;\n  type *id = call(1, (id));\n  type *id = call(1, (id));\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id > 0)id->id = id->id;\n  if(call(id, id->id) == -1){\n    id = id;\n    goto lbl;\n  }\n  if((id->id = call(0, id, id->id)) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if(call(0, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id, id, id->id.id, id)) != id){\n    goto lbl;\n  }\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = call() ^ id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = (id->id ? 8 : 4);\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id == null){\n    id->id = id->id;\n  }\n  if((id->id = call(id->id)) == null){\n    id = id;\n    goto lbl;\n  }\n  if(id->id && id->id && call(id->id, id->id) != 0){\n    type id = call(id->id, id->id);\n    if(id == (id) - 1){\n      id = id;\n      goto lbl;\n    }\n    id->id = id;\n  }\n  if((id = call(id->id, (id->id), id->id, (id->id), id->id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, &id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, id)) != id){\n    goto lbl;\n  }\n  if(call(id->id, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, 0)) != id){\n    goto lbl;\n  }\n  if(id->id.id && id->id != id->id){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  lbl:\n  call(id->id);\n  if(id == id || id == id || id == id){\n    if(id->id.id){\n      call(id->id, (id->id), str, call(id), id, call(id), id);\n      call(id->id, id);\n    }\n  }\n  if(id)call(id);\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type id){\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = (type)id[8];\n  id = call(1, 0xdd0);\n  id = call(1, 0x180);\n  id = id[1];\n  *id = *id;\n  id[1] = id;\n  id[2] = id[2];\n  id[3] = id[3];\n  id[4] = id[4];\n  id[5] = id[5];\n  id[6] = id[6];\n  id[7] = id[7];\n  id[0x24] = id[9];\n  id[0x25] = id[10];\n  id[0xb] = id;\n  id[0xc] = id;\n  *(type)(id + 0x10) = *(type)(id + 0xb);\n  if(0 < (type)id[0xc]){\n    *(type)((type)id + 0x84) = (type)id[0xc];\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n    lbl:\n    call(id[5]);\n    id = id[6];\n    lbl:\n    if(id != 0){\n      id = call(id);\n      id = call();\n      id = id;\n      id = call(*id);\n      call((type)((type)id + 0x5ce), 0x800, str, id, id, id, *id);\n      id = id;\n      call((type)((type)id + 0x5ce), id);\n    }\n  }else{\n    id = call(0, 2, id[5]);\n    id[8] = id;\n    if(id == -1){\n      id = 0xf;\n      if((type)id[6] != (type)0x0){\n        *(type)((type)id + 0x5ee) = 0x656c696620666f;\n        *(type)((type)id + 0x5e6) = 0x20646e65206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(0, 0, id[5]);\n    id = (type)id[6];\n    if(id == -1){\n      id = 0xf;\n      if(id != (type)0x0){\n        *(type)((type)id + 0x5f4) = 0x656c696620666f;\n        *(type)((type)id + 0x5ee) = 0x666f20676e696e6e;\n        *(type)((type)id + 0x5e6) = 0x69676562206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(id, id, id, id);\n    id = (type)id;\n    if(id == 0){\n      *(type)((type)id + 0x4c) = id[1];\n      *(type)(id + 9) = *id;\n      *(type)(id + 10) = id[2];\n      id = call();\n      *(type)(id + 0xd) = id ^ *id;\n      id[0x11] = *(type)(id + 0x10);\n      id[0x12] = *(type)(id + 0xe);\n      id[0x13] = *(type)(id + 8);\n      id[0x16] = *(type)(id + 10);\n      id[0x18] = *(type)(id + 0xc);\n      id[0x17] = call(*(type)((type)id + 0x4c) != 0) * 4 + 4;\n      id[0x27] = *(type)(id + 0x12);\n      id[0x28] = *(type)(id + 0x14);\n      *(type)(id + 0x29) = id[3];\n      if(id[0x24] == 0){\n        id[0x24] = *(type)(id + 0x5e);\n      }\n      id = call();\n      id[0x14] = id;\n      if(id == 0){\n        id = 3;\n        lbl:\n        call(id[5]);\n        call(id);\n        goto lbl;\n      }\n      id = (type)id[0x24];\n      if(((id != (type)0x0) && (id = (type)id[0x25]id != (type)0x0)) && (id = call(id, id)id != 0)){\n        id = call(id, id);\n        if(id == (type)0xffffffffffffffff){\n          id = 7;\n          goto lbl;\n        }\n        id[0x26] = id;\n      }\n      id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, id[0x26]);\n      id = (type)id;\n      if(id == 0){\n        id = call(id, &id);\n        id = (type)id;\n        if(id == 0){\n          id = call(id, id);\n          id = (type)id;\n          if(id == 0){\n            id = call(id[0x11], 0, id[5]);\n            if(id == -1){\n              id = 0xf;\n              if(id[6] != 0){\n                call((type)((type)id + 0x5ce), 0x800, str, id[0x11]);\n                id = 0xf;\n                call((type)((type)id + 0x5ce), id[0xb]);\n              }\n              goto lbl;\n            }\n            id = call(id);\n            id = (type)id;\n            if(id == 0){\n              id = call(id, 0);\n              id = (type)id;\n              if(id == 0){\n                if((id[4] != 0) && (*(type)(id + 0xf) != *(type)(id + 0x10))){\n                  id = 9;\n                  if(id[6] != 0){\n                    call((type)((type)id + 0x5ce), 0x800, str);\n                    call((type)((type)id + 0x5ce), id[0xb]);\n                  }\n                  goto lbl;\n                }\n                id = call(id);\n                id = (type)id;\n              }\n            }\n          }\n        }\n      }\n    }\n    call(id[5]);\n    if(((type)id < 0x10) && ((0x8006U >> ((type)id & 0x1f) & 1) != 0)){\n      id = id[6];\n      goto lbl;\n    }\n  }\n  call(id);\n  if(id == (type)0x0){\n    return id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type id){\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = (type)id[8];\n  id = (type)call(1, 0xdd0);\n  id = (type)call(1, 0x180);\n  id = id[1];\n  *id = *id;\n  id[1] = id;\n  id[2] = id[2];\n  id[3] = id[3];\n  id[4] = id[4];\n  id[5] = id[5];\n  id[6] = id[6];\n  id[7] = id[7];\n  id[0x24] = id[9];\n  id[0x25] = id[10];\n  id[0xb] = id;\n  id[0xc] = id;\n  *(type)(id + 0x10) = *(type)(id + 0xb);\n  if(0 < (type)id[0xc]){\n    *(type)((type)id + 0x84) = (type)id[0xc];\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n    lbl:\n    call(id[5]);\n    id = id[6];\n    lbl:\n    if(id != 0){\n      id = call(id);\n      id = call();\n      id = id;\n      id = call(*id);\n      call((type)((type)id + 0x5ce), 0x800, str, id, id, id, *id);\n      id = id;\n      call((type)((type)id + 0x5ce), id);\n    }\n  }else{\n    id = call(0, 2, id[5]);\n    id[8] = id;\n    if(id == -1){\n      id = 0xf;\n      if((type)id[6] != (type)0x0){\n        *(type)((type)id + 0x5ee) = 0x656c696620666f;\n        *(type)((type)id + 0x5e6) = 0x20646e65206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(0, 0, id[5]);\n    id = (type)id[6];\n    if(id == -1){\n      id = 0xf;\n      if(id != (type)0x0){\n        *(type)((type)id + 0x5f4) = 0x656c696620666f;\n        *(type)((type)id + 0x5ee) = 0x666f20676e696e6e;\n        *(type)((type)id + 0x5e6) = 0x69676562206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(id, id, id, id);\n    id = (type)id;\n    if(id == 0){\n      *(type)((type)id + 0x4c) = id[1];\n      *(type)(id + 9) = *id;\n      *(type)(id + 10) = id[2];\n      id = call();\n      *(type)(id + 0xd) = id ^ *id;\n      id[0x11] = *(type)(id + 0x10);\n      id[0x12] = *(type)(id + 0xe);\n      id[0x13] = *(type)(id + 8);\n      id[0x16] = *(type)(id + 10);\n      id[0x18] = *(type)(id + 0xc);\n      id[0x17] = call(*(type)((type)id + 0x4c) != 0) * 4 + 4;\n      id[0x27] = *(type)(id + 0x12);\n      id[0x28] = *(type)(id + 0x14);\n      *(type)(id + 0x29) = id[3];\n      if(id[0x24] == 0){\n        id[0x24] = *(type)(id + 0x5e);\n      }\n      id = call();\n      id[0x14] = id;\n      if(id == 0){\n        id = 3;\n        lbl:\n        call(id[5]);\n        call(id);\n        goto lbl;\n      }\n      id = (type)id[0x24];\n      if(((id != (type)0x0) && (id = (type)id[0x25]id != (type)0x0)) && (id = call(id, id)id != 0)){\n        id = call(id, id);\n        if(id == (type)0xffffffffffffffff){\n          id = 7;\n          goto lbl;\n        }\n        id[0x26] = id;\n      }\n      id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, id[0x26]);\n      id = (type)id;\n      if(id == 0){\n        id = call(id, &id);\n        id = (type)id;\n        if(id == 0){\n          id = call(id, id);\n          id = (type)id;\n          if(id == 0){\n            id = call(id[0x11], 0, id[5]);\n            if(id == -1){\n              id = 0xf;\n              if(id[6] != 0){\n                call((type)((type)id + 0x5ce), 0x800, str, id[0x11]);\n                id = 0xf;\n                call((type)((type)id + 0x5ce), id[0xb]);\n              }\n              goto lbl;\n            }\n            id = call(id);\n            id = (type)id;\n            if(id == 0){\n              id = call(id, 0);\n              id = (type)id;\n              if(id == 0){\n                if((id[4] != 0) && (*(type)(id + 0xf) != *(type)(id + 0x10))){\n                  id = 9;\n                  if(id[6] != 0){\n                    call((type)((type)id + 0x5ce), 0x800, str);\n                    call((type)((type)id + 0x5ce), id[0xb]);\n                  }\n                  goto lbl;\n                }\n                id = call(id);\n                id = (type)id;\n              }\n            }\n          }\n        }\n      }\n    }\n    call(id[5]);\n    if(((type)id < 0x10) && ((0x8006U >> ((type)id & 0x1f) & 1) != 0)){\n      id = id[6];\n      goto lbl;\n    }\n  }\n  call(id);\n  if(id == (type)0x0){\n    return id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.484375,
          "base_ppl": 2.296875,
          "pr_ppl": 2.296875,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.5,
          "pr_ast_ppl": 2.484375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O3.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "function_pr": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = (undefined8 *)calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id = 0;\n  type id = id;\n  type *id = id->id;\n  type *id = call(1, (id));\n  type *id = call(1, (id));\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id > 0)id->id = id->id;\n  if(call(id, id->id) == -1){\n    id = id;\n    goto lbl;\n  }\n  if((id->id = call(0, id, id->id)) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if(call(0, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id, id, id->id.id, id)) != id){\n    goto lbl;\n  }\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = call() ^ id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = (id->id ? 8 : 4);\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id == null){\n    id->id = id->id;\n  }\n  if((id->id = call(id->id)) == null){\n    id = id;\n    goto lbl;\n  }\n  if(id->id && id->id && call(id->id, id->id) != 0){\n    type id = call(id->id, id->id);\n    if(id == (id) - 1){\n      id = id;\n      goto lbl;\n    }\n    id->id = id;\n  }\n  if((id = call(id->id, (id->id), id->id, (id->id), id->id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, &id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, id)) != id){\n    goto lbl;\n  }\n  if(call(id->id, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, 0)) != id){\n    goto lbl;\n  }\n  if(id->id.id && id->id != id->id){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  lbl:\n  call(id->id);\n  if(id == id || id == id || id == id){\n    if(id->id.id){\n      call(id->id, (id->id), str, call(id), id, call(id), id);\n      call(id->id, id);\n    }\n  }\n  if(id)call(id);\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type id){\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = (type)id[8];\n  id = call(1, 0xdd0);\n  id = call(1, 0x180);\n  id = id[1];\n  *id = *id;\n  id[1] = id;\n  id[2] = id[2];\n  id[3] = id[3];\n  id[4] = id[4];\n  id[5] = id[5];\n  id[6] = id[6];\n  id[7] = id[7];\n  id[0x24] = id[9];\n  id[0x25] = id[10];\n  id[0xb] = id;\n  id[0xc] = id;\n  *(type)(id + 0x10) = *(type)(id + 0xb);\n  if(0 < (type)id[0xc]){\n    *(type)((type)id + 0x84) = (type)id[0xc];\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n    lbl:\n    call(id[5]);\n    id = id[6];\n    lbl:\n    if(id != 0){\n      id = call(id);\n      id = call();\n      id = id;\n      id = call(*id);\n      call((type)((type)id + 0x5ce), 0x800, str, id, id, id, *id);\n      id = id;\n      call((type)((type)id + 0x5ce), id);\n    }\n  }else{\n    id = call(0, 2, id[5]);\n    id[8] = id;\n    if(id == -1){\n      id = 0xf;\n      if((type)id[6] != (type)0x0){\n        *(type)((type)id + 0x5ee) = 0x656c696620666f;\n        *(type)((type)id + 0x5e6) = 0x20646e65206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(0, 0, id[5]);\n    id = (type)id[6];\n    if(id == -1){\n      id = 0xf;\n      if(id != (type)0x0){\n        *(type)((type)id + 0x5f4) = 0x656c696620666f;\n        *(type)((type)id + 0x5ee) = 0x666f20676e696e6e;\n        *(type)((type)id + 0x5e6) = 0x69676562206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(id, id, id, id);\n    id = (type)id;\n    if(id == 0){\n      *(type)((type)id + 0x4c) = id[1];\n      *(type)(id + 9) = *id;\n      *(type)(id + 10) = id[2];\n      id = call();\n      *(type)(id + 0xd) = id ^ *id;\n      id[0x11] = *(type)(id + 0x10);\n      id[0x12] = *(type)(id + 0xe);\n      id[0x13] = *(type)(id + 8);\n      id[0x16] = *(type)(id + 10);\n      id[0x18] = *(type)(id + 0xc);\n      id[0x17] = call(*(type)((type)id + 0x4c) != 0) * 4 + 4;\n      id[0x27] = *(type)(id + 0x12);\n      id[0x28] = *(type)(id + 0x14);\n      *(type)(id + 0x29) = id[3];\n      if(id[0x24] == 0){\n        id[0x24] = *(type)(id + 0x5e);\n      }\n      id = call();\n      id[0x14] = id;\n      if(id == 0){\n        id = 3;\n        lbl:\n        call(id[5]);\n        call(id);\n        goto lbl;\n      }\n      id = (type)id[0x24];\n      if(((id != (type)0x0) && (id = (type)id[0x25]id != (type)0x0)) && (id = call(id, id)id != 0)){\n        id = call(id, id);\n        if(id == (type)0xffffffffffffffff){\n          id = 7;\n          goto lbl;\n        }\n        id[0x26] = id;\n      }\n      id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, id[0x26]);\n      id = (type)id;\n      if(id == 0){\n        id = call(id, &id);\n        id = (type)id;\n        if(id == 0){\n          id = call(id, id);\n          id = (type)id;\n          if(id == 0){\n            id = call(id[0x11], 0, id[5]);\n            if(id == -1){\n              id = 0xf;\n              if(id[6] != 0){\n                call((type)((type)id + 0x5ce), 0x800, str, id[0x11]);\n                id = 0xf;\n                call((type)((type)id + 0x5ce), id[0xb]);\n              }\n              goto lbl;\n            }\n            id = call(id);\n            id = (type)id;\n            if(id == 0){\n              id = call(id, 0);\n              id = (type)id;\n              if(id == 0){\n                if((id[4] != 0) && (*(type)(id + 0xf) != *(type)(id + 0x10))){\n                  id = 9;\n                  if(id[6] != 0){\n                    call((type)((type)id + 0x5ce), 0x800, str);\n                    call((type)((type)id + 0x5ce), id[0xb]);\n                  }\n                  goto lbl;\n                }\n                id = call(id);\n                id = (type)id;\n              }\n            }\n          }\n        }\n      }\n    }\n    call(id[5]);\n    if(((type)id < 0x10) && ((0x8006U >> ((type)id & 0x1f) & 1) != 0)){\n      id = id[6];\n      goto lbl;\n    }\n  }\n  call(id);\n  if(id == (type)0x0){\n    return id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type id){\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = (type)id[8];\n  id = (type)call(1, 0xdd0);\n  id = (type)call(1, 0x180);\n  id = id[1];\n  *id = *id;\n  id[1] = id;\n  id[2] = id[2];\n  id[3] = id[3];\n  id[4] = id[4];\n  id[5] = id[5];\n  id[6] = id[6];\n  id[7] = id[7];\n  id[0x24] = id[9];\n  id[0x25] = id[10];\n  id[0xb] = id;\n  id[0xc] = id;\n  *(type)(id + 0x10) = *(type)(id + 0xb);\n  if(0 < (type)id[0xc]){\n    *(type)((type)id + 0x84) = (type)id[0xc];\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n    lbl:\n    call(id[5]);\n    id = id[6];\n    lbl:\n    if(id != 0){\n      id = call(id);\n      id = call();\n      id = id;\n      id = call(*id);\n      call((type)((type)id + 0x5ce), 0x800, str, id, id, id, *id);\n      id = id;\n      call((type)((type)id + 0x5ce), id);\n    }\n  }else{\n    id = call(0, 2, id[5]);\n    id[8] = id;\n    if(id == -1){\n      id = 0xf;\n      if((type)id[6] != (type)0x0){\n        *(type)((type)id + 0x5ee) = 0x656c696620666f;\n        *(type)((type)id + 0x5e6) = 0x20646e65206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(0, 0, id[5]);\n    id = (type)id[6];\n    if(id == -1){\n      id = 0xf;\n      if(id != (type)0x0){\n        *(type)((type)id + 0x5f4) = 0x656c696620666f;\n        *(type)((type)id + 0x5ee) = 0x666f20676e696e6e;\n        *(type)((type)id + 0x5e6) = 0x69676562206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(id, id, id, id);\n    id = (type)id;\n    if(id == 0){\n      *(type)((type)id + 0x4c) = id[1];\n      *(type)(id + 9) = *id;\n      *(type)(id + 10) = id[2];\n      id = call();\n      *(type)(id + 0xd) = id ^ *id;\n      id[0x11] = *(type)(id + 0x10);\n      id[0x12] = *(type)(id + 0xe);\n      id[0x13] = *(type)(id + 8);\n      id[0x16] = *(type)(id + 10);\n      id[0x18] = *(type)(id + 0xc);\n      id[0x17] = call(*(type)((type)id + 0x4c) != 0) * 4 + 4;\n      id[0x27] = *(type)(id + 0x12);\n      id[0x28] = *(type)(id + 0x14);\n      *(type)(id + 0x29) = id[3];\n      if(id[0x24] == 0){\n        id[0x24] = *(type)(id + 0x5e);\n      }\n      id = call();\n      id[0x14] = id;\n      if(id == 0){\n        id = 3;\n        lbl:\n        call(id[5]);\n        call(id);\n        goto lbl;\n      }\n      id = (type)id[0x24];\n      if(((id != (type)0x0) && (id = (type)id[0x25]id != (type)0x0)) && (id = call(id, id)id != 0)){\n        id = call(id, id);\n        if(id == (type)0xffffffffffffffff){\n          id = 7;\n          goto lbl;\n        }\n        id[0x26] = id;\n      }\n      id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, id[0x26]);\n      id = (type)id;\n      if(id == 0){\n        id = call(id, &id);\n        id = (type)id;\n        if(id == 0){\n          id = call(id, id);\n          id = (type)id;\n          if(id == 0){\n            id = call(id[0x11], 0, id[5]);\n            if(id == -1){\n              id = 0xf;\n              if(id[6] != 0){\n                call((type)((type)id + 0x5ce), 0x800, str, id[0x11]);\n                id = 0xf;\n                call((type)((type)id + 0x5ce), id[0xb]);\n              }\n              goto lbl;\n            }\n            id = call(id);\n            id = (type)id;\n            if(id == 0){\n              id = call(id, 0);\n              id = (type)id;\n              if(id == 0){\n                if((id[4] != 0) && (*(type)(id + 0xf) != *(type)(id + 0x10))){\n                  id = 9;\n                  if(id[6] != 0){\n                    call((type)((type)id + 0x5ce), 0x800, str);\n                    call((type)((type)id + 0x5ce), id[0xb]);\n                  }\n                  goto lbl;\n                }\n                id = call(id);\n                id = (type)id;\n              }\n            }\n          }\n        }\n      }\n    }\n    call(id[5]);\n    if(((type)id < 0x10) && ((0x8006U >> ((type)id & 0x1f) & 1) != 0)){\n      id = id[6];\n      goto lbl;\n    }\n  }\n  call(id);\n  if(id == (type)0x0){\n    return id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.484375,
          "base_ppl": 2.296875,
          "pr_ppl": 2.296875,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.5,
          "pr_ast_ppl": 2.484375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A matches the Source Code structure more closely as it avoids unnecessary type casting, which wasn't present in the Source. Candidate B introduces explicit casts that add noise without improving the logic.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_zmagic-O0.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined4 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  int iVar3;\n  _union_1457 local_1b8 [19];\n  uint local_11c;\n  _union_1457 local_118 [19];\n  uint local_7c;\n  ulong local_78;\n  void *local_70;\n  undefined4 local_64;\n  uint local_60;\n  undefined4 local_5c;\n  int local_58;\n  int local_54;\n  long local_50;\n  void *local_48;\n  ulong local_40;\n  ulong local_38;\n  void *local_30;\n  undefined8 local_28;\n  undefined4 *local_20;\n  long local_18;\n  undefined4 local_c;\n  \n  local_30 = (void *)0x0;\n  local_5c = 0;\n  local_60 = *(uint *)(param_1 + 0x44) & 0x410;\n  local_64 = *param_2;\n  local_70 = *(void **)(param_2 + 0x26);\n  local_78 = *(ulong *)(param_2 + 0x28);\n  local_7c = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) == 0) {\n    local_c = 0;\n  }\n  else {\n    local_28 = param_3;\n    local_20 = param_2;\n    local_18 = param_1;\n    for (local_38 = 0; local_38 < ncompr; local_38 = local_38 + 1) {\n      iVar3 = -*(int *)(compr + local_38 * 0x20 + 8);\n      iVar1 = *(int *)(compr + local_38 * 0x20 + 8);\n      if (-1 < iVar3) {\n        iVar1 = iVar3;\n      }\n      if ((ulong)(long)iVar1 <= local_78) {\n        if (*(int *)(compr + local_38 * 0x20 + 8) < 0) {\n          local_11c = (**(code **)(compr + local_38 * 0x20))(local_70);\n        }\n        else {\n          iVar1 = memcmp(local_70,*(void **)(compr + local_38 * 0x20),\n                         (long)*(int *)(compr + local_38 * 0x20 + 8));\n          local_11c = (uint)(iVar1 == 0);\n        }\n        if (local_11c != 0) {\n          if (local_7c == 0) {\n            memset(local_1b8,0,0x98);\n            local_1b8[0] = (_union_1457)0x1;\n            iVar1 = sigaction(0xd,(sigaction *)local_1b8,(sigaction *)local_118);\n            local_7c = (uint)(iVar1 != -1);\n          }\n          local_40 = local_78;\n          free(local_30);\n          local_54 = uncompressbuf(local_64,*(undefined8 *)(local_18 + 0x120),local_38,\n                                   *(uint *)(local_18 + 0x44) & 0x4000000,local_70,&local_30,\n                                   &local_40);\n          if (local_54 != 0) {\n            if (local_54 == 1) goto LAB_00102adf;\n            if (local_54 != 2) {\n                    /* WARNING: Subroutine does not return */\n              abort();\n            }\n          }\n          *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) & 0xfffffffb;\n          if (local_54 == 2) {\n            local_58 = format_decompression_error(local_18,local_38,local_30);\n          }\n          else {\n            local_58 = file_buffer(local_18,0xffffffff,0,local_28,local_30,local_40);\n          }\n          if (local_58 != -1) {\n            local_5c = 1;\n            if (((*(uint *)(local_18 + 0x44) & 0x2000000) != 0) ||\n               ((local_60 != 0x410 && (local_60 != 0)))) break;\n            iVar1 = file_printf(local_18);\n            if ((iVar1 != -1) && (local_50 = file_push_buffer(local_18), local_50 != 0)) {\n              iVar1 = file_buffer(local_18,0xffffffff,0,0,local_70,local_78);\n              if (iVar1 == -1) {\n                lVar2 = file_pop_buffer(local_18);\n                if (lVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n                  abort();\n                }\n              }\n              else {\n                local_48 = (void *)file_pop_buffer(local_18);\n                if (local_48 != (void *)0x0) {\n                  iVar1 = file_printf(local_18,\"%s\",local_48);\n                  if (iVar1 == -1) {\n                    free(local_48);\n                    goto LAB_00102ad3;\n                  }\n                  free(local_48);\n                }\n                if ((local_60 != 0) || (iVar1 = file_printf(local_18), iVar1 != -1))\n                goto LAB_00102adf;\n              }\n            }\n          }\nLAB_00102ad3:\n          local_5c = 0xffffffff;\n        }\n      }\nLAB_00102adf:\n    }\n    if ((local_7c != 0) && (local_118[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_118,(sigaction *)0x0);\n    }\n    free(local_30);\n    *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) | 4;\n    local_c = local_5c;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nundefined4 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  _union_1457 local_1b8 [19];\n  uint local_11c;\n  _union_1457 local_118 [19];\n  uint local_7c;\n  ulong local_78;\n  void *local_70;\n  undefined4 local_64;\n  uint local_60;\n  undefined4 local_5c;\n  int local_58;\n  int local_54;\n  long local_50;\n  void *local_48;\n  ulong local_40;\n  ulong local_38;\n  void *local_30;\n  undefined8 local_28;\n  undefined4 *local_20;\n  long local_18;\n  undefined4 local_c;\n  \n  local_30 = (void *)0x0;\n  local_5c = 0;\n  local_60 = *(uint *)(param_1 + 0x44) & 0x410;\n  local_64 = *param_2;\n  local_70 = *(void **)(param_2 + 0x26);\n  local_78 = *(ulong *)(param_2 + 0x28);\n  local_7c = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) == 0) {\n    local_c = 0;\n  }\n  else {\n    local_28 = param_3;\n    local_20 = param_2;\n    local_18 = param_1;\n    for (local_38 = 0; local_38 < ncompr; local_38 = local_38 + 1) {\n      iVar1 = *(int *)(compr + local_38 * 0x20 + 8);\n      if (iVar1 < 1) {\n        iVar1 = -iVar1;\n      }\n      if ((ulong)(long)iVar1 <= local_78) {\n        if (*(int *)(compr + local_38 * 0x20 + 8) < 0) {\n          local_11c = (**(code **)(compr + local_38 * 0x20))(local_70);\n        }\n        else {\n          iVar1 = memcmp(local_70,*(void **)(compr + local_38 * 0x20),\n                         (long)*(int *)(compr + local_38 * 0x20 + 8));\n          local_11c = (uint)(iVar1 == 0);\n        }\n        if (local_11c != 0) {\n          if (local_7c == 0) {\n            memset(local_1b8,0,0x98);\n            local_1b8[0] = (_union_1457)0x1;\n            iVar1 = sigaction(0xd,(sigaction *)local_1b8,(sigaction *)local_118);\n            local_7c = (uint)(iVar1 != -1);\n          }\n          local_40 = local_78;\n          free(local_30);\n          local_54 = uncompressbuf(local_64,*(undefined8 *)(local_18 + 0x120),local_38,\n                                   *(uint *)(local_18 + 0x44) & 0x4000000,local_70,&local_30,\n                                   &local_40);\n          if (local_54 != 0) {\n            if (local_54 == 1) goto LAB_00102adf;\n            if (local_54 != 2) {\n                    /* WARNING: Subroutine does not return */\n              abort();\n            }\n          }\n          *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) & 0xfffffffb;\n          if (local_54 == 2) {\n            local_58 = format_decompression_error(local_18,local_38,local_30);\n          }\n          else {\n            local_58 = file_buffer(local_18,0xffffffff,0,local_28,local_30,local_40);\n          }\n          if (local_58 != -1) {\n            local_5c = 1;\n            if (((*(uint *)(local_18 + 0x44) & 0x2000000) != 0) ||\n               ((local_60 != 0x410 && (local_60 != 0)))) break;\n            iVar1 = file_printf(local_18);\n            if ((iVar1 != -1) && (local_50 = file_push_buffer(local_18), local_50 != 0)) {\n              iVar1 = file_buffer(local_18,0xffffffff,0,0,local_70,local_78);\n              if (iVar1 == -1) {\n                lVar2 = file_pop_buffer(local_18);\n                if (lVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n                  abort();\n                }\n              }\n              else {\n                local_48 = (void *)file_pop_buffer(local_18);\n                if (local_48 != (void *)0x0) {\n                  iVar1 = file_printf(local_18,\"%s\",local_48);\n                  if (iVar1 == -1) {\n                    free(local_48);\n                    goto LAB_00102ad3;\n                  }\n                  free(local_48);\n                }\n                if ((local_60 != 0) || (iVar1 = file_printf(local_18), iVar1 != -1))\n                goto LAB_00102adf;\n              }\n            }\n          }\nLAB_00102ad3:\n          local_5c = 0xffffffff;\n        }\n      }\nLAB_00102adf:\n    }\n    if ((local_7c != 0) && (local_118[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_118,(sigaction *)0x0);\n    }\n    free(local_30);\n    *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) | 4;\n    local_c = local_5c;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type *id = null;\n  type id, id;\n  type *id;\n  type *id;\n  type id, id, id = 0;\n  type id = id->id & id;\n  type id = id->id;\n  type *id = call(id unsigned char id->id);\n  type id = id->id;\n  type id = 0;\n  type id;\n  if((id->id & id) == 0)return 0;\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, -1, null, id, id, id);\n        if(id == -1)goto lbl;\n        id = 1;\n        if((id->id & id) != 0)goto lbl;\n        if(id != id && id != 0)goto lbl;\n        if((call(id, (id ? str : str))) == -1)goto lbl;\n        if((id = call(id)) == null)goto lbl;\n        if(call(id, -1, null, null, id, id) == -1){\n          if(call(id, id) != null)call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != null){\n          if(call(id, str, id) == -1){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, str) == -1)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = -1;\n        break;\n    }\n  }\n  lbl:\n  call(str, id);\n  if(id && id.id != id)(type)call(id, &id, null);\n  call(id);\n  id->id = id;\n  call(str, id);\n  return id;\n}",
        "base_ast": "type id( id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type id[19];\n  type id;\n  type id[19];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  id = (type)0x0;\n  id = 0;\n  id = *(type)(id + 0x44) & 0x410;\n  id = *id;\n  id = *(type)(id + 0x26);\n  id = *(type)(id + 0x28);\n  id = 0;\n  if((*(type)(id + 0x44) & 4) == 0){\n    id = 0;\n  }else{\n    id = id;\n    id = id;\n    id = id;\n    for(id = 0;  id < id; id = id + 1){\n      id = -*(type)(id + id * 0x20 + 8);\n      id = *(type)(id + id * 0x20 + 8);\n      if(-1 < id){\n        id = id;\n      }\n      if((type)(type)id <= id){\n        if(*(type)(id + id * 0x20 + 8) < 0){\n          id = call(id);\n        }else{\n          id = call(id, *(type)(id + id * 0x20), (type)*(type)(id + id * 0x20 + 8));\n          id = call(id == 0);\n        }\n        if(id != 0){\n          if(id == 0){\n            call(id, 0, 0x98);\n            id[0] = (type)0x1;\n            id = call(0xd, (type)id, (type)id);\n            id = call(id != -1);\n          }\n          id = id;\n          call(id);\n          id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n          if(id != 0){\n            if(id == 1)goto lbl;\n            if(id != 2){\n              call();\n            }\n          }\n          *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfffffffb;\n          if(id == 2){\n            id = call(id, id, id);\n          }else{\n            id = call(id, 0xffffffff, 0, id, id, id);\n          }\n          if(id != -1){\n            id = 1;\n            if(((*(type)(id + 0x44) & 0x2000000) != 0) || ((id != 0x410 && (id != 0))))break;\n            id = call(id);\n            if((id != -1) && (id = call(id)id != 0)){\n              id = call(id, 0xffffffff, 0, 0, id, id);\n              if(id == -1){\n                id = call(id);\n                if(id != 0){\n                  call();\n                }\n              }else{\n                id = (type)call(id);\n                if(id != (type)0x0){\n                  id = call(id, str, id);\n                  if(id == -1){\n                    call(id);\n                    goto lbl;\n                  }\n                  call(id);\n                }\n                if((id != 0) || (id = call(id)id != -1))goto lbl;\n              }\n            }\n          }\n          lbl:\n          id = 0xffffffff;\n        }\n      }\n      lbl:\n      ;\n    }\n    if((id != 0) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n    id = id;\n  }\n  return id;\n}",
        "pr_ast": "type id( id, type *id, type id){\n  type id;\n  type id;\n  type id[19];\n  type id;\n  type id[19];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  id = (type)0x0;\n  id = 0;\n  id = *(type)(id + 0x44) & 0x410;\n  id = *id;\n  id = *(type)(id + 0x26);\n  id = *(type)(id + 0x28);\n  id = 0;\n  if((*(type)(id + 0x44) & 4) == 0){\n    id = 0;\n  }else{\n    id = id;\n    id = id;\n    id = id;\n    for(id = 0;  id < id; id = id + 1){\n      id = *(type)(id + id * 0x20 + 8);\n      if(id < 1){\n        id = -id;\n      }\n      if((type)(type)id <= id){\n        if(*(type)(id + id * 0x20 + 8) < 0){\n          id = call(id);\n        }else{\n          id = call(id, *(type)(id + id * 0x20), (type)*(type)(id + id * 0x20 + 8));\n          id = call(id == 0);\n        }\n        if(id != 0){\n          if(id == 0){\n            call(id, 0, 0x98);\n            id[0] = (type)0x1;\n            id = call(0xd, (type)id, (type)id);\n            id = call(id != -1);\n          }\n          id = id;\n          call(id);\n          id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n          if(id != 0){\n            if(id == 1)goto lbl;\n            if(id != 2){\n              call();\n            }\n          }\n          *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfffffffb;\n          if(id == 2){\n            id = call(id, id, id);\n          }else{\n            id = call(id, 0xffffffff, 0, id, id, id);\n          }\n          if(id != -1){\n            id = 1;\n            if(((*(type)(id + 0x44) & 0x2000000) != 0) || ((id != 0x410 && (id != 0))))break;\n            id = call(id);\n            if((id != -1) && (id = call(id)id != 0)){\n              id = call(id, 0xffffffff, 0, 0, id, id);\n              if(id == -1){\n                id = call(id);\n                if(id != 0){\n                  call();\n                }\n              }else{\n                id = (type)call(id);\n                if(id != (type)0x0){\n                  id = call(id, str, id);\n                  if(id == -1){\n                    call(id);\n                    goto lbl;\n                  }\n                  call(id);\n                }\n                if((id != 0) || (id = call(id)id != -1))goto lbl;\n              }\n            }\n          }\n          lbl:\n          id = 0xffffffff;\n        }\n      }\n      lbl:\n      ;\n    }\n    if((id != 0) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n    id = id;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.28125,
          "base_ppl": 2.578125,
          "pr_ppl": 2.5625,
          "source_ast_ppl": 4.59375,
          "base_ast_ppl": 3.171875,
          "pr_ast_ppl": 3.203125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B simplifies the logic by removing the unnecessary variable iVar3 and directly using iVar1. This reduces artificial nesting and makes the code more readable and maintainable, aligning with higher-level human thinking patterns.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "motivation": "Candidate B simplifies the control flow by removing unnecessary operations and redundant checks, making the code more logical and reflective of high-level human thinking. The changes reduce artificial nesting and improve readability, which are key aspects of idiomatic design.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_checkfmt-O2.so",
        "function": "file_checkfmt",
        "source_code": "file_protected int\nfile_checkfmt(char *msg, size_t mlen, const char *fmt)\n{\n\tconst char *p;\n\tfor (p = fmt; *p; p++) {\n\t\tif (*p != '%')\n\t\t\tcontinue;\n\t\tif (*++p == '%')\n\t\t\tcontinue;\n\t\tif (*p == '\\0') {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"incomplete %% format\");\n\t\t\treturn -1;\n\t\t}\n\t\t// Skip uninteresting.\n\t\twhile (*p != '\\0' && strchr(\"#0.'+- \", *p) != NULL)\n\t\t\tp++;\n\t\tif (*p == '*') {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"* not allowed in format\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!file_checkfield(msg, mlen, \"width\", &p))\n\t\t\treturn -1;\n\n\t\tif (*p == '.') {\n\t\t\tp++;\n\t\t\tif (!file_checkfield(msg, mlen, \"precision\", &p))\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (!isalpha((unsigned char)*p)) {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"bad format char: %c\", *p);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "function_base": "\nundefined8 file_checkfmt(char *param_1,size_t param_2,byte *param_3)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  char *__format;\n  byte bVar3;\n  byte *local_38;\n  \n  do {\n    for (; *param_3 != 0x25; param_3 = param_3 + 1) {\n      if (*param_3 == 0) {\n        return 0;\n      }\nLAB_0010122d:\n    }\n    local_38 = param_3 + 1;\n    bVar3 = param_3[1];\n    if (bVar3 != 0x25) {\n      if (bVar3 == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        __format = \"incomplete %% format\";\nLAB_00101278:\n        snprintf(param_1,param_2,__format);\n        return 0xffffffff;\n      }\n      do {\n        if ((0x3f < bVar3) || ((1L << (bVar3 & 0x3f) & 0x1688900000001U) == 0)) {\n          if (bVar3 == 0x2a) {\n            if (param_1 == (char *)0x0) {\n              return 0xffffffff;\n            }\n            __format = \"* not allowed in format\";\n            goto LAB_00101278;\n          }\n          break;\n        }\n        bVar3 = local_38[1];\n        local_38 = local_38 + 1;\n      } while (bVar3 != 0);\n      iVar1 = file_checkfield(param_1,param_2,\"width\",&local_38);\n      if (iVar1 == 0) {\n        return 0xffffffff;\n      }\n      bVar3 = *local_38;\n      if (bVar3 == 0x2e) {\n        local_38 = local_38 + 1;\n        iVar1 = file_checkfield(param_1,param_2,\"precision\",&local_38);\n        if (iVar1 == 0) {\n          return 0xffffffff;\n        }\n        bVar3 = *local_38;\n      }\n      param_3 = local_38;\n      ppuVar2 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar2 + (ulong)bVar3 * 2 + 1) & 4) == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        snprintf(param_1,param_2,\"bad format char: %c\",(ulong)(uint)(int)(char)bVar3);\n        return 0xffffffff;\n      }\n      goto LAB_0010122d;\n    }\n    param_3 = param_3 + 2;\n  } while( true );\n}\n\n",
        "function_pr": "\nulong file_checkfmt(char *param_1,size_t param_2,byte *param_3)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  char *__format;\n  byte bVar3;\n  byte *local_38;\n  \n  do {\n    while( true ) {\n      bVar3 = *param_3;\n      if (bVar3 == 0x25) break;\n      if (bVar3 == 0) {\n        return (ulong)bVar3;\n      }\nLAB_0010122d:\n      param_3 = param_3 + 1;\n    }\n    local_38 = param_3 + 1;\n    bVar3 = param_3[1];\n    if (bVar3 != 0x25) {\n      if (bVar3 == 0) {\n        if (param_1 != (char *)0x0) {\n          __format = \"incomplete %% format\";\nLAB_00101278:\n          snprintf(param_1,param_2,__format);\n        }\n        return 0xffffffff;\n      }\n      do {\n        if ((0x3f < bVar3) || ((1L << (bVar3 & 0x3f) & 0x1688900000001U) == 0)) {\n          if (bVar3 == 0x2a) {\n            if (param_1 == (char *)0x0) {\n              return 0xffffffff;\n            }\n            __format = \"* not allowed in format\";\n            goto LAB_00101278;\n          }\n          break;\n        }\n        bVar3 = local_38[1];\n        local_38 = local_38 + 1;\n      } while (bVar3 != 0);\n      iVar1 = file_checkfield(param_1,param_2,\"width\",&local_38);\n      if (iVar1 == 0) {\n        return 0xffffffff;\n      }\n      bVar3 = *local_38;\n      if (bVar3 == 0x2e) {\n        local_38 = local_38 + 1;\n        iVar1 = file_checkfield(param_1,param_2,\"precision\",&local_38);\n        if (iVar1 == 0) {\n          return 0xffffffff;\n        }\n        bVar3 = *local_38;\n      }\n      param_3 = local_38;\n      ppuVar2 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar2 + (ulong)bVar3 * 2 + 1) & 4) == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        snprintf(param_1,param_2,\"bad format char: %c\",(ulong)(uint)(int)(char)bVar3);\n        return 0xffffffff;\n      }\n      goto LAB_0010122d;\n    }\n    param_3 = param_3 + 2;\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id;\n  for(id = id;  *id; id++){\n    if(*id != str)continue;\n    if(*++id == str)continue;\n    if(*id == str){\n      if(id)call(id, id, str);\n      return -1;\n    }\n    while(*id != str && call(str, *id) != null)id++;\n    if(*id == str){\n      if(id)call(id, id, str);\n      return -1;\n    }\n    if(!call(id, id, str, &id))return -1;\n    if(*id == str){\n      id++;\n      if(!call(id, id, str, &id))return -1;\n    }\n    if(!call((type)*id)){\n      if(id)call(id, id, str, *id);\n      return -1;\n    }\n  }\n  return 0;\n}",
        "base_ast": "typeid(type *id, type id, type *id)type id;type **id;type *id;type id;type *id;{\n  for(; *id != 0x25; id = id + 1){\n    if(*id == 0){\n      return 0;\n    }\n    lbl:\n    id = id + 1;\n    id = id[1];\n    if(id != 0x25){\n      if(id == 0){\n        if(id == (type)0x0){\n          return 0xffffffff;\n        }\n        id = str;\n        lbl:\n        call(id, id, id);\n        return 0xffffffff;\n      }\n      do{\n        if((0x3f < id) || ((1L << (id & 0x3f) & 0x1688900000001U) == 0)){\n          if(id == 0x2a){\n            if(id == (type)0x0){\n              return 0xffffffff;\n            }\n            id = str;\n            goto lbl;\n          }\n          break;\n        }\n        id = id[1];\n        id = id + 1;\n      }while(id != 0);\n      id = call(id, id, str, &id);\n      if(id == 0){\n        return 0xffffffff;\n      }\n      id = *id;\n      if(id == 0x2e){\n        id = id + 1;\n        id = call(id, id, str, &id);\n        if(id == 0){\n          return 0xffffffff;\n        }\n        id = *id;\n      }\n      id = id;\n      id = call();\n      if((*(type)((type)*id + (type)id * 2 + 1) & 4) == 0){\n        if(id == (type)0x0){\n          return 0xffffffff;\n        }\n        call(id, id, str, (type)(type)(type)(type)id);\n        return 0xffffffff;\n      }\n      goto lbl;\n    }\n    id = id + 2;\n  }\n  while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id){\n  type id;\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  do{\n    while(bool){\n      id = *id;\n      if(id == 0x25)break;\n      if(id == 0){\n        return (type)id;\n      }\n      lbl:\n      id = id + 1;\n    }\n    id = id + 1;\n    id = id[1];\n    if(id != 0x25){\n      if(id == 0){\n        if(id != (type)0x0){\n          id = str;\n          lbl:\n          call(id, id, id);\n        }\n        return 0xffffffff;\n      }\n      do{\n        if((0x3f < id) || ((1L << (id & 0x3f) & 0x1688900000001U) == 0)){\n          if(id == 0x2a){\n            if(id == (type)0x0){\n              return 0xffffffff;\n            }\n            id = str;\n            goto lbl;\n          }\n          break;\n        }\n        id = id[1];\n        id = id + 1;\n      }while(id != 0);\n      id = call(id, id, str, &id);\n      if(id == 0){\n        return 0xffffffff;\n      }\n      id = *id;\n      if(id == 0x2e){\n        id = id + 1;\n        id = call(id, id, str, &id);\n        if(id == 0){\n          return 0xffffffff;\n        }\n        id = *id;\n      }\n      id = id;\n      id = call();\n      if((*(type)((type)*id + (type)id * 2 + 1) & 4) == 0){\n        if(id == (type)0x0){\n          return 0xffffffff;\n        }\n        call(id, id, str, (type)(type)(type)(type)id);\n        return 0xffffffff;\n      }\n      goto lbl;\n    }\n    id = id + 2;\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 3.65625,
          "base_ppl": 3.015625,
          "pr_ppl": 3.171875,
          "source_ast_ppl": 4.8125,
          "base_ast_ppl": 4.1875,
          "pr_ast_ppl": 4.1875,
          "delta_ppl": 0.15625
        },
        "llm_qualitative": {
          "motivation": "Candidate A uses a `for` loop, which is a higher-level construct and more idiomatic. It has a clear structure with the condition and increment in the loop statement, making the logic straightforward and easier to follow. Candidate B replaces the `for` loop with a `while (true)` loop, which, although functional, introduces more labels and potential for less readable control flow. Additionally, Candidate A has less artificial nesting, making it the better choice.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A preserves the for loop structure from the Source, closely matching the control flow. Candidate B replaces it with a do-while loop, deviating structurally. Additionally, A's loop is simpler and matches the Source's logic better.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_getbuffer-O2.so",
        "function": "file_getbuffer",
        "source_code": "file_protected const char *\nfile_getbuffer(struct magic_set *ms)\n{\n\tchar *pbuf, *op, *np;\n\tsize_t psize, len;\n\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn NULL;\n\n\tif (ms->flags & MAGIC_RAW)\n\t\treturn ms->o.buf;\n\n\tif (ms->o.buf == NULL)\n\t\treturn NULL;\n\n\t/* * 4 is for octal representation, + 1 is for NUL */\n\tlen = strlen(ms->o.buf);\n\tif (len > (SIZE_MAX - 1) / 4) {\n\t\tfile_oomem(ms, len);\n\t\treturn NULL;\n\t}\n\tpsize = len * 4 + 1;\n\tif ((pbuf = CAST(char *, realloc(ms->o.pbuf, psize))) == NULL) {\n\t\tfile_oomem(ms, psize);\n\t\treturn NULL;\n\t}\n\tms->o.pbuf = pbuf;\n\n#if defined(HAVE_WCHAR_H) && defined(HAVE_MBRTOWC) && defined(HAVE_WCWIDTH)\n\t{\n\t\tmbstate_t state;\n\t\twchar_t nextchar;\n\t\tint mb_conv = 1;\n\t\tsize_t bytesconsumed;\n\t\tchar *eop;\n\t\t(void)memset(&state, 0, sizeof(mbstate_t));\n\n\t\tnp = ms->o.pbuf;\n\t\top = ms->o.buf;\n\t\teop = op + len;\n\n\t\twhile (op < eop) {\n\t\t\tbytesconsumed = mbrtowc(&nextchar, op,\n\t\t\t    CAST(size_t, eop - op), &state);\n\t\t\tif (bytesconsumed == CAST(size_t, -1) ||\n\t\t\t    bytesconsumed == CAST(size_t, -2)) {\n\t\t\t\tmb_conv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iswprint(nextchar)) {\n\t\t\t\t(void)memcpy(np, op, bytesconsumed);\n\t\t\t\top += bytesconsumed;\n\t\t\t\tnp += bytesconsumed;\n\t\t\t} else {\n\t\t\t\twhile (bytesconsumed-- > 0)\n\t\t\t\t\tOCTALIFY(np, op);\n\t\t\t}\n\t\t}\n\t\t*np = '\\0';\n\n\t\t/* Parsing succeeded as a multi-byte sequence */\n\t\tif (mb_conv != 0)\n\t\t\treturn ms->o.pbuf;\n\t}\n#endif\n\n\tfor (np = ms->o.pbuf, op = ms->o.buf; *op;) {\n\t\tif (isprint(CAST(unsigned char, *op))) {\n\t\t\t*np++ = *op++;\n\t\t} else {\n\t\t\tOCTALIFY(np, op);\n\t\t}\n\t}\n\t*np = '\\0';\n\treturn ms->o.pbuf;\n}\n",
        "function_base": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                    }\n                    bVar5 = pbVar6[1];\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "function_pr": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = (undefined1 *)realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                    }\n                    bVar5 = pbVar6[1];\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "source_ast": "type *id(type *id){\n  type *id, *id, *id;\n  type id, id;\n  if(id->id & id)return null;\n  if(id->id & id)return id->id.id;\n  if(id->id.id == null)return null;\n  id = call(id->id.id);\n  if(id > (id - 1) / 4){\n    call(id, id);\n    return null;\n  }\n  id = id * 4 + 1;\n  if((id = call(id * call(id->id.id, id))) == null){\n    call(id, id);\n    return null;\n  }\n  id->id.id = id;\n  id && id && id{\n    type id;\n    type id;\n    type id = 1;\n    type id;\n    type *id;\n    (type)call(&id, 0, (id));\n    id = id->id.id;\n    id = id->id.id;\n    id = id + id;\n    while(id < id){\n      id = call(&id, id, call(id, id - id), &id);\n      if(id == call(id, -1) || id == call(id, -2)){\n        id = 0;\n        break;\n      }\n      if(call(id)){\n        (type)call(id, id, id);\n        id = id;\n        id = id;\n      }else{\n        while(id-- > 0)call(id, id);\n      }\n    }\n    *id = str;\n    if(id != 0)return id->id.id;\n  }\n  for(id = id->id.idid = id->id.id;  *id; ){\n    if(call(call(id, id, *id))){\n      *id++ = *id++;\n    }else{\n      call(id, id);\n    }\n  }\n  *id = str;\n  return id->id.id;\n}",
        "base_ast": "type *id( id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type **id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  if((*(type)(id + 0x48) & 1) == 0){\n    id = *(type)(id + 0x20);\n    if((*(type)(id + 0x45) & 1) != 0){\n      return id;\n    }\n    if(id != (type)0x0){\n      id = call(id);\n      id = id;\n      if(id >> 0x3e == 0){\n        id = id * 4 + 1;\n        id = call(*(type)(id + 0x30), id);\n        if(id != (type)0x0){\n          *(type)(id + 0x30) = id;\n          id.id = 0;\n          id.id = (type)0x0;\n          if(id != 0){\n            id = *(type)(id + 0x20);\n            id = id + id;\n            do{\n              id = call(&id, (type)id, (type)id - (type)id, &id);\n              if(0xfffffffffffffffd < id){\n                *id = 0;\n                id = *(type)(id + 0x20);\n                id = *(type)(id + 0x30);\n                id = *id;\n                if(id != 0){\n                  id = call();\n                  do{\n                    if((*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0){\n                      *id = 0x5c;\n                      id[1] = *id >> 6 | 0x30;\n                      id[2] = *id >> 3 & 7 | 0x30;\n                      id[3] = *id & 7 | 0x30;\n                      id = id + 4;\n                    }else{\n                      *id = id;\n                      id = id + 1;\n                    }\n                    id = id[1];\n                    id = id + 1;\n                  }while(id != 0);\n                }\n                *id = 0;\n                return *(type)(id + 0x30);\n              }\n              id = call(id);\n              if(id == 0){\n                for(; id != 0; id = id - 1){\n                  *id = 0x5c;\n                  id[1] = *id >> 6 | 0x30;\n                  id[2] = *id >> 3 & 7 | 0x30;\n                  id = *id;\n                  id = id + 1;\n                  id[3] = id & 7 | 0x30;\n                  id = id + 4;\n                }\n              }else{\n                call(id, id, id);\n                id = id + id;\n                id = id + id;\n              }\n            }while(id < id);\n          }\n          *id = 0;\n          return *(type)(id + 0x30);\n        }\n      }\n      call(id, id);\n      return (type)0x0;\n    }\n  }\n  return (type)0x0;\n}",
        "pr_ast": "type *id( id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type **id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  if((*(type)(id + 0x48) & 1) == 0){\n    id = *(type)(id + 0x20);\n    if((*(type)(id + 0x45) & 1) != 0){\n      return id;\n    }\n    if(id != (type)0x0){\n      id = call(id);\n      id = id;\n      if(id >> 0x3e == 0){\n        id = id * 4 + 1;\n        id = (type)call(*(type)(id + 0x30), id);\n        if(id != (type)0x0){\n          *(type)(id + 0x30) = id;\n          id.id = 0;\n          id.id = (type)0x0;\n          if(id != 0){\n            id = *(type)(id + 0x20);\n            id = id + id;\n            do{\n              id = call(&id, (type)id, (type)id - (type)id, &id);\n              if(0xfffffffffffffffd < id){\n                *id = 0;\n                id = *(type)(id + 0x20);\n                id = *(type)(id + 0x30);\n                id = *id;\n                if(id != 0){\n                  id = call();\n                  do{\n                    if((*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0){\n                      *id = 0x5c;\n                      id[1] = *id >> 6 | 0x30;\n                      id[2] = *id >> 3 & 7 | 0x30;\n                      id[3] = *id & 7 | 0x30;\n                      id = id + 4;\n                    }else{\n                      *id = id;\n                      id = id + 1;\n                    }\n                    id = id[1];\n                    id = id + 1;\n                  }while(id != 0);\n                }\n                *id = 0;\n                return *(type)(id + 0x30);\n              }\n              id = call(id);\n              if(id == 0){\n                for(; id != 0; id = id - 1){\n                  *id = 0x5c;\n                  id[1] = *id >> 6 | 0x30;\n                  id[2] = *id >> 3 & 7 | 0x30;\n                  id = *id;\n                  id = id + 1;\n                  id[3] = id & 7 | 0x30;\n                  id = id + 4;\n                }\n              }else{\n                call(id, id, id);\n                id = id + id;\n                id = id + id;\n              }\n            }while(id < id);\n          }\n          *id = 0;\n          return *(type)(id + 0x30);\n        }\n      }\n      call(id, id);\n      return (type)0x0;\n    }\n  }\n  return (type)0x0;\n}",
        "metrics": {
          "source_ppl": 3.578125,
          "base_ppl": 2.46875,
          "pr_ppl": 2.46875,
          "source_ast_ppl": 5.375,
          "base_ast_ppl": 2.84375,
          "pr_ast_ppl": 2.828125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_getbuffer-O3.so",
        "function": "file_getbuffer",
        "source_code": "file_protected const char *\nfile_getbuffer(struct magic_set *ms)\n{\n\tchar *pbuf, *op, *np;\n\tsize_t psize, len;\n\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn NULL;\n\n\tif (ms->flags & MAGIC_RAW)\n\t\treturn ms->o.buf;\n\n\tif (ms->o.buf == NULL)\n\t\treturn NULL;\n\n\t/* * 4 is for octal representation, + 1 is for NUL */\n\tlen = strlen(ms->o.buf);\n\tif (len > (SIZE_MAX - 1) / 4) {\n\t\tfile_oomem(ms, len);\n\t\treturn NULL;\n\t}\n\tpsize = len * 4 + 1;\n\tif ((pbuf = CAST(char *, realloc(ms->o.pbuf, psize))) == NULL) {\n\t\tfile_oomem(ms, psize);\n\t\treturn NULL;\n\t}\n\tms->o.pbuf = pbuf;\n\n#if defined(HAVE_WCHAR_H) && defined(HAVE_MBRTOWC) && defined(HAVE_WCWIDTH)\n\t{\n\t\tmbstate_t state;\n\t\twchar_t nextchar;\n\t\tint mb_conv = 1;\n\t\tsize_t bytesconsumed;\n\t\tchar *eop;\n\t\t(void)memset(&state, 0, sizeof(mbstate_t));\n\n\t\tnp = ms->o.pbuf;\n\t\top = ms->o.buf;\n\t\teop = op + len;\n\n\t\twhile (op < eop) {\n\t\t\tbytesconsumed = mbrtowc(&nextchar, op,\n\t\t\t    CAST(size_t, eop - op), &state);\n\t\t\tif (bytesconsumed == CAST(size_t, -1) ||\n\t\t\t    bytesconsumed == CAST(size_t, -2)) {\n\t\t\t\tmb_conv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iswprint(nextchar)) {\n\t\t\t\t(void)memcpy(np, op, bytesconsumed);\n\t\t\t\top += bytesconsumed;\n\t\t\t\tnp += bytesconsumed;\n\t\t\t} else {\n\t\t\t\twhile (bytesconsumed-- > 0)\n\t\t\t\t\tOCTALIFY(np, op);\n\t\t\t}\n\t\t}\n\t\t*np = '\\0';\n\n\t\t/* Parsing succeeded as a multi-byte sequence */\n\t\tif (mb_conv != 0)\n\t\t\treturn ms->o.pbuf;\n\t}\n#endif\n\n\tfor (np = ms->o.pbuf, op = ms->o.buf; *op;) {\n\t\tif (isprint(CAST(unsigned char, *op))) {\n\t\t\t*np++ = *op++;\n\t\t} else {\n\t\t\tOCTALIFY(np, op);\n\t\t}\n\t}\n\t*np = '\\0';\n\treturn ms->o.pbuf;\n}\n",
        "function_base": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                      bVar5 = pbVar6[1];\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                      bVar5 = pbVar6[1];\n                    }\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "function_pr": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = (undefined1 *)realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                      bVar5 = pbVar6[1];\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                      bVar5 = pbVar6[1];\n                    }\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "source_ast": "type *id(type *id){\n  type *id, *id, *id;\n  type id, id;\n  if(id->id & id)return null;\n  if(id->id & id)return id->id.id;\n  if(id->id.id == null)return null;\n  id = call(id->id.id);\n  if(id > (id - 1) / 4){\n    call(id, id);\n    return null;\n  }\n  id = id * 4 + 1;\n  if((id = call(id * call(id->id.id, id))) == null){\n    call(id, id);\n    return null;\n  }\n  id->id.id = id;\n  id && id && id{\n    type id;\n    type id;\n    type id = 1;\n    type id;\n    type *id;\n    (type)call(&id, 0, (id));\n    id = id->id.id;\n    id = id->id.id;\n    id = id + id;\n    while(id < id){\n      id = call(&id, id, call(id, id - id), &id);\n      if(id == call(id, -1) || id == call(id, -2)){\n        id = 0;\n        break;\n      }\n      if(call(id)){\n        (type)call(id, id, id);\n        id = id;\n        id = id;\n      }else{\n        while(id-- > 0)call(id, id);\n      }\n    }\n    *id = str;\n    if(id != 0)return id->id.id;\n  }\n  for(id = id->id.idid = id->id.id;  *id; ){\n    if(call(call(id, id, *id))){\n      *id++ = *id++;\n    }else{\n      call(id, id);\n    }\n  }\n  *id = str;\n  return id->id.id;\n}",
        "base_ast": "type *id( id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type **id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  if((*(type)(id + 0x48) & 1) == 0){\n    id = *(type)(id + 0x20);\n    if((*(type)(id + 0x45) & 1) != 0){\n      return id;\n    }\n    if(id != (type)0x0){\n      id = call(id);\n      id = id;\n      if(id >> 0x3e == 0){\n        id = id * 4 + 1;\n        id = call(*(type)(id + 0x30), id);\n        if(id != (type)0x0){\n          *(type)(id + 0x30) = id;\n          id.id = 0;\n          id.id = (type)0x0;\n          if(id != 0){\n            id = *(type)(id + 0x20);\n            id = id + id;\n            do{\n              id = call(&id, (type)id, (type)id - (type)id, &id);\n              if(0xfffffffffffffffd < id){\n                *id = 0;\n                id = *(type)(id + 0x20);\n                id = *(type)(id + 0x30);\n                id = *id;\n                if(id != 0){\n                  id = call();\n                  do{\n                    if((*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0){\n                      *id = 0x5c;\n                      id[1] = *id >> 6 | 0x30;\n                      id[2] = *id >> 3 & 7 | 0x30;\n                      id[3] = *id & 7 | 0x30;\n                      id = id + 4;\n                      id = id[1];\n                    }else{\n                      *id = id;\n                      id = id + 1;\n                      id = id[1];\n                    }\n                    id = id + 1;\n                  }while(id != 0);\n                }\n                *id = 0;\n                return *(type)(id + 0x30);\n              }\n              id = call(id);\n              if(id == 0){\n                for(; id != 0; id = id - 1){\n                  *id = 0x5c;\n                  id[1] = *id >> 6 | 0x30;\n                  id[2] = *id >> 3 & 7 | 0x30;\n                  id = *id;\n                  id = id + 1;\n                  id[3] = id & 7 | 0x30;\n                  id = id + 4;\n                }\n              }else{\n                call(id, id, id);\n                id = id + id;\n                id = id + id;\n              }\n            }while(id < id);\n          }\n          *id = 0;\n          return *(type)(id + 0x30);\n        }\n      }\n      call(id, id);\n      return (type)0x0;\n    }\n  }\n  return (type)0x0;\n}",
        "pr_ast": "type *id( id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type **id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  if((*(type)(id + 0x48) & 1) == 0){\n    id = *(type)(id + 0x20);\n    if((*(type)(id + 0x45) & 1) != 0){\n      return id;\n    }\n    if(id != (type)0x0){\n      id = call(id);\n      id = id;\n      if(id >> 0x3e == 0){\n        id = id * 4 + 1;\n        id = (type)call(*(type)(id + 0x30), id);\n        if(id != (type)0x0){\n          *(type)(id + 0x30) = id;\n          id.id = 0;\n          id.id = (type)0x0;\n          if(id != 0){\n            id = *(type)(id + 0x20);\n            id = id + id;\n            do{\n              id = call(&id, (type)id, (type)id - (type)id, &id);\n              if(0xfffffffffffffffd < id){\n                *id = 0;\n                id = *(type)(id + 0x20);\n                id = *(type)(id + 0x30);\n                id = *id;\n                if(id != 0){\n                  id = call();\n                  do{\n                    if((*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0){\n                      *id = 0x5c;\n                      id[1] = *id >> 6 | 0x30;\n                      id[2] = *id >> 3 & 7 | 0x30;\n                      id[3] = *id & 7 | 0x30;\n                      id = id + 4;\n                      id = id[1];\n                    }else{\n                      *id = id;\n                      id = id + 1;\n                      id = id[1];\n                    }\n                    id = id + 1;\n                  }while(id != 0);\n                }\n                *id = 0;\n                return *(type)(id + 0x30);\n              }\n              id = call(id);\n              if(id == 0){\n                for(; id != 0; id = id - 1){\n                  *id = 0x5c;\n                  id[1] = *id >> 6 | 0x30;\n                  id[2] = *id >> 3 & 7 | 0x30;\n                  id = *id;\n                  id = id + 1;\n                  id[3] = id & 7 | 0x30;\n                  id = id + 4;\n                }\n              }else{\n                call(id, id, id);\n                id = id + id;\n                id = id + id;\n              }\n            }while(id < id);\n          }\n          *id = 0;\n          return *(type)(id + 0x30);\n        }\n      }\n      call(id, id);\n      return (type)0x0;\n    }\n  }\n  return (type)0x0;\n}",
        "metrics": {
          "source_ppl": 3.578125,
          "base_ppl": 2.453125,
          "pr_ppl": 2.453125,
          "source_ast_ppl": 5.375,
          "base_ast_ppl": 2.828125,
          "pr_ast_ppl": 2.796875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces a redundant assignment (sVar3 = sVar3) and additional checks that do not match the Source Code's structure, making it less faithful.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_cnxptiee-O3.so",
        "function": "cnxptiee",
        "source_code": "int cnxptiee(const void *from_bytes, int fromtype, void *to_bytes, int totype)\n{\n    unsigned char *from = (unsigned char *)from_bytes;\n    unsigned char *to = (unsigned char *)to_bytes;\n    unsigned char temp[8];\n    int i;\n\n    if (fromtype == CN_TYPE_NATIVE) {\n        fromtype = FLOATREP;\n    }\n    switch(fromtype) {\n        case CN_TYPE_IEEEL :\n            if (totype == CN_TYPE_IEEEL)\n                break;\n            for (i=7;i>=0;i--) {\n                temp[7-i] = from[i];\n            }\n            from = temp;\n            fromtype = CN_TYPE_IEEEB;\n            /* Break intentionally omitted. */\n        case CN_TYPE_IEEEB :\n            /* Break intentionally omitted. */\n        case CN_TYPE_XPORT :\n            break;\n        default:\n            return(-1);\n    }\n    if (totype == CN_TYPE_NATIVE) {\n        totype = FLOATREP;\n    }\n    switch(totype) {\n        case CN_TYPE_XPORT :\n        case CN_TYPE_IEEEB :\n        case CN_TYPE_IEEEL :\n            break;\n        default:\n            return(-2);\n    }\n    if (fromtype == totype) {\n        memcpy(to,from,8);\n        return(0);\n    }\n    switch(fromtype) {\n        case CN_TYPE_IEEEB :\n            if (totype == CN_TYPE_XPORT)\n                ieee2xpt(from,to);\n            else memcpy(to,from,8);\n            break;\n        case CN_TYPE_XPORT :\n            xpt2ieee(from,to);\n            break;\n    }\n    if (totype == CN_TYPE_IEEEL) {\n        memcpy(temp,to,8);\n        for (i=7;i>=0;i--) {\n            to[7-i] = temp[i];\n        }\n    }\n    return(0);\n}\n",
        "function_base": "\nundefined8 cnxptiee(ulong *param_1,int param_2,ulong *param_3,int param_4)\n\n{\n  ulong uVar1;\n  ulong in_RAX;\n  undefined8 local_28;\n  \n  local_28 = in_RAX;\n  if (param_2 == 0) {\n    param_2 = get_native();\n  }\n  if (1 < param_2 - 1U) {\n    if (param_2 != 3) {\n      return 0xffffffff;\n    }\n    if (param_4 == 3) goto LAB_001012ac;\n    local_28 = CONCAT17((char)*param_1,\n                        CONCAT16(*(undefined1 *)((long)param_1 + 1),\n                                 CONCAT15(*(undefined1 *)((long)param_1 + 2),\n                                          CONCAT14(*(undefined1 *)((long)param_1 + 3),\n                                                   CONCAT13(*(undefined1 *)((long)param_1 + 4),\n                                                            CONCAT12(*(undefined1 *)\n                                                                      ((long)param_1 + 5),\n                                                                     CONCAT11(*(undefined1 *)\n                                                                               ((long)param_1 + 6),\n                                                                              *(undefined1 *)\n                                                                               ((long)param_1 + 7)))\n                                                           )))));\n    param_2 = 2;\n    param_1 = &local_28;\n  }\n  if (param_4 == 0) {\n    param_4 = get_native();\n  }\n  if (2 < param_4 - 1U) {\n    return 0xfffffffe;\n  }\n  if (param_2 != param_4) {\n    if (param_2 == 1) {\n      xpt2ieee(*param_1,param_3);\n    }\n    else if (param_2 == 2) {\n      if (param_4 == 1) {\n        ieee2xpt(param_1,param_3);\n        return 0;\n      }\n      *param_3 = *param_1;\n    }\n    if (param_4 != 3) {\n      return 0;\n    }\n    uVar1 = *param_3;\n    *param_3 = uVar1 >> 0x38 | (uVar1 & 0xff000000000000) >> 0x28 | (uVar1 & 0xff0000000000) >> 0x18\n               | (uVar1 & 0xff00000000) >> 8 | (uVar1 & 0xff000000) << 8 |\n               (uVar1 & 0xff0000) << 0x18 | (uVar1 & 0xff00) << 0x28 | uVar1 << 0x38;\n    return 0;\n  }\nLAB_001012ac:\n  *param_3 = *param_1;\n  return 0;\n}\n\n",
        "function_pr": "\nundefined8 cnxptiee(ulong *param_1,int param_2,ulong *param_3,int param_4)\n\n{\n  ulong uVar1;\n  uint uVar2;\n  ulong in_RAX;\n  undefined8 local_28;\n  \n  local_28 = in_RAX;\n  if (param_2 == 0) {\n    param_2 = get_native();\n    uVar2 = param_2 - 1;\n  }\n  else {\n    uVar2 = param_2 - 1;\n  }\n  if (1 < uVar2) {\n    if (param_2 != 3) {\n      return 0xffffffff;\n    }\n    if (param_4 == 3) goto LAB_001012ac;\n    local_28 = CONCAT17((char)*param_1,\n                        CONCAT16(*(undefined1 *)((long)param_1 + 1),\n                                 CONCAT15(*(undefined1 *)((long)param_1 + 2),\n                                          CONCAT14(*(undefined1 *)((long)param_1 + 3),\n                                                   CONCAT13(*(undefined1 *)((long)param_1 + 4),\n                                                            CONCAT12(*(undefined1 *)\n                                                                      ((long)param_1 + 5),\n                                                                     CONCAT11(*(undefined1 *)\n                                                                               ((long)param_1 + 6),\n                                                                              *(undefined1 *)\n                                                                               ((long)param_1 + 7)))\n                                                           )))));\n    param_2 = 2;\n    param_1 = &local_28;\n  }\n  if (param_4 == 0) {\n    param_4 = get_native();\n    uVar2 = param_4 - 1;\n  }\n  else {\n    uVar2 = param_4 - 1;\n  }\n  if (2 < uVar2) {\n    return 0xfffffffe;\n  }\n  if (param_2 != param_4) {\n    if (param_2 == 1) {\n      xpt2ieee(*param_1,param_3);\n    }\n    else if (param_2 == 2) {\n      if (param_4 == 1) {\n        ieee2xpt(param_1,param_3);\n        return 0;\n      }\n      *param_3 = *param_1;\n    }\n    if (param_4 == 3) {\n      uVar1 = *param_3;\n      *param_3 = uVar1 >> 0x38 | (uVar1 & 0xff000000000000) >> 0x28 |\n                 (uVar1 & 0xff0000000000) >> 0x18 | (uVar1 & 0xff00000000) >> 8 |\n                 (uVar1 & 0xff000000) << 8 | (uVar1 & 0xff0000) << 0x18 | (uVar1 & 0xff00) << 0x28 |\n                 uVar1 << 0x38;\n      return 0;\n    }\n    return 0;\n  }\nLAB_001012ac:\n  *param_3 = *param_1;\n  return 0;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id){\n  type *id = (type)id;\n  type *id = (type)id;\n  type id[8];\n  type id;\n  if(id == id){\n    id = id;\n  }\n  switch(id){\n    case id:\n      if(id == id)break;\n      for(id = 7;  id >= 0; id--){\n        id[7 - id] = id[id];\n      }\n      id = id;\n      id = id;\n    case id:\n    case id:\n      break;\n    case def:\n      return (-1);\n  }\n  if(id == id){\n    id = id;\n  }\n  switch(id){\n    case id:\n    case id:\n    case id:\n      break;\n    case def:\n      return (-2);\n  }\n  if(id == id){\n    call(id, id, 8);\n    return (0);\n  }\n  switch(id){\n    case id:\n      if(id == id)call(id, id);elsecall(id, id, 8);\n      break;\n    case id:\n      call(id, id);\n      break;\n  }\n  if(id == id){\n    call(id, id, 8);\n    for(id = 7;  id >= 0; id--){\n      id[7 - id] = id[id];\n    }\n  }\n  return (0);\n}",
        "base_ast": "type id(type *id, type id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  id = id;\n  if(id == 0){\n    id = call();\n  }\n  if(1 < id - 1U){\n    if(id != 3){\n      return 0xffffffff;\n    }\n    if(id == 3)goto lbl;\n    id = call((type)*id, call(*(type)((type)id + 1), call(*(type)((type)id + 2), call(*(type)((type)id + 3), call(*(type)((type)id + 4), call(*(type)((type)id + 5), call(*(type)((type)id + 6), *(type)((type)id + 7))))))));\n    id = 2;\n    id = &id;\n  }\n  if(id == 0){\n    id = call();\n  }\n  if(2 < id - 1U){\n    return 0xfffffffe;\n  }\n  if(id != id){\n    if(id == 1){\n      call(*id, id);\n    }elseif(id == 2){\n      if(id == 1){\n        call(id, id);\n        return 0;\n      }\n      *id = *id;\n    }\n    if(id != 3){\n      return 0;\n    }\n    id = *id;\n    *id = id >> 0x38 | (id & 0xff000000000000) >> 0x28 | (id & 0xff0000000000) >> 0x18 | (id & 0xff00000000) >> 8 | (id & 0xff000000) << 8 | (id & 0xff0000) << 0x18 | (id & 0xff00) << 0x28 | id << 0x38;\n    return 0;\n  }\n  lbl:\n  *id = *id;\n  return 0;\n}",
        "pr_ast": "type id(type *id, type id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type id;\n  id = id;\n  if(id == 0){\n    id = call();\n    id = id - 1;\n  }else{\n    id = id - 1;\n  }\n  if(1 < id){\n    if(id != 3){\n      return 0xffffffff;\n    }\n    if(id == 3)goto lbl;\n    id = call((type)*id, call(*(type)((type)id + 1), call(*(type)((type)id + 2), call(*(type)((type)id + 3), call(*(type)((type)id + 4), call(*(type)((type)id + 5), call(*(type)((type)id + 6), *(type)((type)id + 7))))))));\n    id = 2;\n    id = &id;\n  }\n  if(id == 0){\n    id = call();\n    id = id - 1;\n  }else{\n    id = id - 1;\n  }\n  if(2 < id){\n    return 0xfffffffe;\n  }\n  if(id != id){\n    if(id == 1){\n      call(*id, id);\n    }elseif(id == 2){\n      if(id == 1){\n        call(id, id);\n        return 0;\n      }\n      *id = *id;\n    }\n    if(id == 3){\n      id = *id;\n      *id = id >> 0x38 | (id & 0xff000000000000) >> 0x28 | (id & 0xff0000000000) >> 0x18 | (id & 0xff00000000) >> 8 | (id & 0xff000000) << 8 | (id & 0xff0000) << 0x18 | (id & 0xff00) << 0x28 | id << 0x38;\n      return 0;\n    }\n    return 0;\n  }\n  lbl:\n  *id = *id;\n  return 0;\n}",
        "metrics": {
          "source_ppl": 2.984375,
          "base_ppl": 2.703125,
          "pr_ppl": 2.53125,
          "source_ast_ppl": 3.359375,
          "base_ast_ppl": 3.203125,
          "pr_ast_ppl": 2.890625,
          "delta_ppl": -0.171875
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B replaces switch statements with if-else conditions, diverging from the Source's control flow. It introduces new variables and changes without correcting logic errors, adding noise.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores nodes like switch cases and maintains the nesting depth of the Source AST, better aligning with its structure.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_readstat_convert-O2.so",
        "function": "readstat_convert",
        "source_code": "readstat_error_t readstat_convert(char *dst, size_t dst_len, const char *src, size_t src_len, iconv_t converter) {\n    /* strip off spaces from the input because the programs use ASCII space\n     * padding even with non-ASCII encoding. */\n    while (src_len && (src[src_len-1] == ' ' || src[src_len-1] == '\\0')) {\n        src_len--;\n    }\n    if (dst_len == 0) {\n        return READSTAT_ERROR_CONVERT_LONG_STRING;\n    } else if (converter) {\n        size_t dst_left = dst_len - 1;\n        char *dst_end = dst;\n        size_t status = iconv(converter, (readstat_iconv_inbuf_t)&src, &src_len, &dst_end, &dst_left);\n        if (status == (size_t)-1) {\n            if (errno == E2BIG) {\n                return READSTAT_ERROR_CONVERT_LONG_STRING;\n            } else if (errno == EILSEQ) {\n                return READSTAT_ERROR_CONVERT_BAD_STRING;\n            } else if (errno != EINVAL) { /* EINVAL indicates improper truncation; accept it */\n                return READSTAT_ERROR_CONVERT;\n            }\n        }\n        dst[dst_len - dst_left - 1] = '\\0';\n    } else if (src_len + 1 > dst_len) {\n        return READSTAT_ERROR_CONVERT_LONG_STRING;\n    } else {\n        memcpy(dst, src, src_len);\n        dst[src_len] = '\\0';\n    }\n    return READSTAT_OK;\n}\n",
        "function_base": "\nundefined8\nreadstat_convert(char *param_1,ulong param_2,char *param_3,size_t param_4,iconv_t param_5)\n\n{\n  int iVar1;\n  size_t sVar2;\n  int *piVar3;\n  ulong local_30;\n  char *local_28;\n  size_t local_20;\n  char *local_18;\n  \n  for (; param_4 != 0; param_4 = param_4 - 1) {\n    if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n  }\n  param_4 = 0;\nLAB_00101160:\n  if (param_2 == 0) {\n    return 0x13;\n  }\n  local_20 = param_4;\n  local_18 = param_3;\n  if (param_5 == (iconv_t)0x0) {\n    if (param_2 < param_4 + 1) {\n      return 0x13;\n    }\n    memcpy(param_1,param_3,param_4);\n    param_1[param_4] = '\\0';\n  }\n  else {\n    local_30 = param_2 - 1;\n    local_28 = param_1;\n    sVar2 = iconv(param_5,&local_18,&local_20,&local_28,&local_30);\n    if (sVar2 == 0xffffffffffffffff) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      if (iVar1 == 7) {\n        return 0x13;\n      }\n      if (iVar1 != 0x16) {\n        if (iVar1 == 0x54) {\n          return 0x11;\n        }\n        return 0x10;\n      }\n    }\n    param_1[param_2 + ~local_30] = '\\0';\n  }\n  return 0;\n}\n\n",
        "function_pr": "\nundefined8\nreadstat_convert(char *param_1,ulong param_2,char *param_3,size_t param_4,iconv_t param_5)\n\n{\n  int iVar1;\n  size_t sVar2;\n  int *piVar3;\n  ulong local_30;\n  char *local_28;\n  size_t local_20;\n  char *local_18;\n  \n  if (param_4 != 0) {\n    do {\n      if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n      param_4 = param_4 - 1;\n    } while (param_4 != 0);\n  }\n  param_4 = 0;\nLAB_00101160:\n  if (param_2 == 0) {\n    return 0x13;\n  }\n  local_20 = param_4;\n  local_18 = param_3;\n  if (param_5 == (iconv_t)0x0) {\n    if (param_2 < param_4 + 1) {\n      return 0x13;\n    }\n    memcpy(param_1,param_3,param_4);\n    param_1[param_4] = '\\0';\n  }\n  else {\n    local_30 = param_2 - 1;\n    local_28 = param_1;\n    sVar2 = iconv(param_5,&local_18,&local_20,&local_28,&local_30);\n    if (sVar2 == 0xffffffffffffffff) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      if (iVar1 == 7) {\n        return 0x13;\n      }\n      if (iVar1 != 0x16) {\n        if (iVar1 == 0x54) {\n          return 0x11;\n        }\n        return 0x10;\n      }\n    }\n    param_1[param_2 + ~local_30] = '\\0';\n  }\n  return 0;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type id){\n  while(id && (id[id - 1] == str || id[id - 1] == str)){\n    id--;\n  }\n  if(id == 0){\n    return id;\n  }elseif(id){\n    type id = id - 1;\n    type *id = id;\n    type id = call(id, (id) & id, &id, &id, &id);\n    if(id == (type)-1){\n      if(id == id){\n        return id;\n      }elseif(id == id){\n        return id;\n      }elseif(id != id){\n        return id;\n      }\n    }\n    id[id - id - 1] = str;\n  }elseif(id + 1 > id){\n    return id;\n  }else{\n    call(id, id, id);\n    id[id] = str;\n  }\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type id, type id){\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  for(; id != 0; id = id - 1){\n    if((id[id - 1] & 0xdfU) != 0)goto lbl;\n  }\n  id = 0;\n  lbl:\n  if(id == 0){\n    return 0x13;\n  }\n  id = id;\n  id = id;\n  if(id == (type)0x0){\n    if(id < id + 1){\n      return 0x13;\n    }\n    call(id, id, id);\n    id[id] = str;\n  }else{\n    id = id - 1;\n    id = id;\n    id = call(id, &id, &id, &id, &id);\n    if(id == 0xffffffffffffffff){\n      id = call();\n      id = *id;\n      if(id == 7){\n        return 0x13;\n      }\n      if(id != 0x16){\n        if(id == 0x54){\n          return 0x11;\n        }\n        return 0x10;\n      }\n    }\n    id[id + ~id] = str;\n  }\n  return 0;\n}",
        "pr_ast": "type id(type *id, type id, type *id, type id, type id){\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  if(id != 0){\n    do{\n      if((id[id - 1] & 0xdfU) != 0)goto lbl;\n      id = id - 1;\n    }while(id != 0);\n  }\n  id = 0;\n  lbl:\n  if(id == 0){\n    return 0x13;\n  }\n  id = id;\n  id = id;\n  if(id == (type)0x0){\n    if(id < id + 1){\n      return 0x13;\n    }\n    call(id, id, id);\n    id[id] = str;\n  }else{\n    id = id - 1;\n    id = id;\n    id = call(id, &id, &id, &id, &id);\n    if(id == 0xffffffffffffffff){\n      id = call();\n      id = *id;\n      if(id == 7){\n        return 0x13;\n      }\n      if(id != 0x16){\n        if(id == 0x54){\n          return 0x11;\n        }\n        return 0x10;\n      }\n    }\n    id[id + ~id] = str;\n  }\n  return 0;\n}",
        "metrics": {
          "source_ppl": 4.34375,
          "base_ppl": 2.609375,
          "pr_ppl": 2.53125,
          "source_ast_ppl": 4.9375,
          "base_ast_ppl": 4.9375,
          "pr_ast_ppl": 4.46875,
          "delta_ppl": -0.078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A uses a for loop which better matches the Source's while loop structure in terms of control flow and simplicity. Candidate B introduces a do-while loop, which adds unnecessary complexity without improving the logic.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate A maintains the loop structure similar to the Source's `while` loop, preserving the nesting depth and node type. Candidate B introduces an extra `if` statement, altering the topology and nesting depth.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_readstat_convert-O3.so",
        "function": "readstat_convert",
        "source_code": "readstat_error_t readstat_convert(char *dst, size_t dst_len, const char *src, size_t src_len, iconv_t converter) {\n    /* strip off spaces from the input because the programs use ASCII space\n     * padding even with non-ASCII encoding. */\n    while (src_len && (src[src_len-1] == ' ' || src[src_len-1] == '\\0')) {\n        src_len--;\n    }\n    if (dst_len == 0) {\n        return READSTAT_ERROR_CONVERT_LONG_STRING;\n    } else if (converter) {\n        size_t dst_left = dst_len - 1;\n        char *dst_end = dst;\n        size_t status = iconv(converter, (readstat_iconv_inbuf_t)&src, &src_len, &dst_end, &dst_left);\n        if (status == (size_t)-1) {\n            if (errno == E2BIG) {\n                return READSTAT_ERROR_CONVERT_LONG_STRING;\n            } else if (errno == EILSEQ) {\n                return READSTAT_ERROR_CONVERT_BAD_STRING;\n            } else if (errno != EINVAL) { /* EINVAL indicates improper truncation; accept it */\n                return READSTAT_ERROR_CONVERT;\n            }\n        }\n        dst[dst_len - dst_left - 1] = '\\0';\n    } else if (src_len + 1 > dst_len) {\n        return READSTAT_ERROR_CONVERT_LONG_STRING;\n    } else {\n        memcpy(dst, src, src_len);\n        dst[src_len] = '\\0';\n    }\n    return READSTAT_OK;\n}\n",
        "function_base": "\nundefined8\nreadstat_convert(char *param_1,ulong param_2,char *param_3,size_t param_4,iconv_t param_5)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  size_t sVar3;\n  int *piVar4;\n  ulong local_30;\n  char *local_28;\n  size_t local_20;\n  char *local_18;\n  \n  for (; param_4 != 0; param_4 = param_4 - 1) {\n    if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n  }\n  param_4 = 0;\nLAB_00101160:\n  uVar2 = 0x13;\n  if (param_2 != 0) {\n    local_20 = param_4;\n    local_18 = param_3;\n    if (param_5 == (iconv_t)0x0) {\n      if (param_2 < param_4 + 1) {\n        return 0x13;\n      }\n      memcpy(param_1,param_3,param_4);\n      param_1[param_4] = '\\0';\n    }\n    else {\n      local_30 = param_2 - 1;\n      local_28 = param_1;\n      sVar3 = iconv(param_5,&local_18,&local_20,&local_28,&local_30);\n      if (sVar3 == 0xffffffffffffffff) {\n        piVar4 = __errno_location();\n        iVar1 = *piVar4;\n        if (iVar1 == 7) {\n          return 0x13;\n        }\n        if (iVar1 != 0x16) {\n          if (iVar1 != 0x54) {\n            return 0x10;\n          }\n          return 0x11;\n        }\n      }\n      param_1[param_2 + ~local_30] = '\\0';\n    }\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nundefined8\nreadstat_convert(char *param_1,ulong param_2,char *param_3,size_t param_4,iconv_t param_5)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  size_t sVar3;\n  int *piVar4;\n  ulong local_30;\n  char *local_28;\n  size_t local_20;\n  char *local_18;\n  \n  if (param_4 != 0) {\n    do {\n      if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n      param_4 = param_4 - 1;\n    } while (param_4 != 0);\n  }\n  param_4 = 0;\nLAB_00101160:\n  uVar2 = 0x13;\n  if (param_2 != 0) {\n    local_20 = param_4;\n    local_18 = param_3;\n    if (param_5 == (iconv_t)0x0) {\n      if (param_2 < param_4 + 1) {\n        return 0x13;\n      }\n      memcpy(param_1,param_3,param_4);\n      param_1[param_4] = '\\0';\n    }\n    else {\n      local_30 = param_2 - 1;\n      local_28 = param_1;\n      sVar3 = iconv(param_5,&local_18,&local_20,&local_28,&local_30);\n      if (sVar3 == 0xffffffffffffffff) {\n        piVar4 = __errno_location();\n        iVar1 = *piVar4;\n        if (iVar1 == 7) {\n          return 0x13;\n        }\n        if (iVar1 != 0x16) {\n          if (iVar1 == 0x54) {\n            return 0x11;\n          }\n          return 0x10;\n        }\n      }\n      param_1[param_2 + ~local_30] = '\\0';\n    }\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type id){\n  while(id && (id[id - 1] == str || id[id - 1] == str)){\n    id--;\n  }\n  if(id == 0){\n    return id;\n  }elseif(id){\n    type id = id - 1;\n    type *id = id;\n    type id = call(id, (id) & id, &id, &id, &id);\n    if(id == (type)-1){\n      if(id == id){\n        return id;\n      }elseif(id == id){\n        return id;\n      }elseif(id != id){\n        return id;\n      }\n    }\n    id[id - id - 1] = str;\n  }elseif(id + 1 > id){\n    return id;\n  }else{\n    call(id, id, id);\n    id[id] = str;\n  }\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  for(; id != 0; id = id - 1){\n    if((id[id - 1] & 0xdfU) != 0)goto lbl;\n  }\n  id = 0;\n  lbl:\n  id = 0x13;\n  if(id != 0){\n    id = id;\n    id = id;\n    if(id == (type)0x0){\n      if(id < id + 1){\n        return 0x13;\n      }\n      call(id, id, id);\n      id[id] = str;\n    }else{\n      id = id - 1;\n      id = id;\n      id = call(id, &id, &id, &id, &id);\n      if(id == 0xffffffffffffffff){\n        id = call();\n        id = *id;\n        if(id == 7){\n          return 0x13;\n        }\n        if(id != 0x16){\n          if(id != 0x54){\n            return 0x10;\n          }\n          return 0x11;\n        }\n      }\n      id[id + ~id] = str;\n    }\n    id = 0;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type *id, type id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  if(id != 0){\n    do{\n      if((id[id - 1] & 0xdfU) != 0)goto lbl;\n      id = id - 1;\n    }while(id != 0);\n  }\n  id = 0;\n  lbl:\n  id = 0x13;\n  if(id != 0){\n    id = id;\n    id = id;\n    if(id == (type)0x0){\n      if(id < id + 1){\n        return 0x13;\n      }\n      call(id, id, id);\n      id[id] = str;\n    }else{\n      id = id - 1;\n      id = id;\n      id = call(id, &id, &id, &id, &id);\n      if(id == 0xffffffffffffffff){\n        id = call();\n        id = *id;\n        if(id == 7){\n          return 0x13;\n        }\n        if(id != 0x16){\n          if(id == 0x54){\n            return 0x11;\n          }\n          return 0x10;\n        }\n      }\n      id[id + ~id] = str;\n    }\n    id = 0;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.34375,
          "base_ppl": 2.578125,
          "pr_ppl": 2.578125,
          "source_ast_ppl": 4.9375,
          "base_ast_ppl": 4.96875,
          "pr_ast_ppl": 4.59375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "Error",
          "motivation": "Okay, so I'm trying to figure out whether the changes in the Diff make the code closer to the Source Code structure or not. Let me start by understanding the problem.\n\nThe task is to evaluate the decompilation fidelity between two candidates, A and B, based on a given diff. The Source Code is the ground truth, and I need to see which candidate (A or B) is structurally closer to it.\n\nFirst, I'll look at the evaluation criteria. There are two main points: Structural Isomorphism and Correction vs Regression.\n\nStructural Isomorphism means that the code should match the control flow structures of the Source. For example, if the Source uses a switch statement, the candidate should also use a switch. Similarly, if the Source uses a for loop, the candidate should have a for loop.\n\nThe second criterion is about whether the changes fix a logic error or introduce noise. So, if the + lines in the diff fix a bug present in the - lines, that's good. If they just add unnecessary code or make it harder to read, that's bad.\n\nNow, looking at the Input Data. The Source Code is a function called readstat_convert. It has a while loop that strips spaces from the end of src. Then it has several if-else conditions.\n\nIn the Diff, the changes are in two parts. Let me look at each part.\n\nFirst part of the diff:\n\nCandidate A has a for loop:\nfor (; param_4 != 0; param_4 = param_4 - 1) {\n    if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n}\n\nCandidate B replaces this with an if statement and a do-while loop:\nif (param_4 != 0) {\n    do {\n        if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n        param_4 = param_4 - 1;\n    } while (param_4 != 0);\n}\n\nSo, the Source Code has a while loop that decrements src_len until it finds a non-space or non-null character. In the Source, it's a while loop: while (src_len && (src[src_len-1] == ' ' || src[src_len-1] == '\\0')) { src_len--; }\n\nIn Candidate A, the code is a for loop that starts with no initializer, checks if param_4 (which is src_len) is not zero, and decrements it each iteration. Inside, it checks if the previous character is not a space or null, and if so, it jumps to the label.\n\nIn Candidate B, it's an if statement that checks if param_4 is not zero, then enters a do-while loop. The do-while loop does the same check as the for loop body, and then decrements param_4. So, the loop continues as long as param_4 is not zero.\n\nNow, comparing the control structures. The Source uses a while loop. Candidate A uses a for loop, which is structurally similar but a different construct. Candidate B uses a do-while loop, which is also a different construct but perhaps more similar in behavior to the Source's while loop.\n\nWait, the Source's while loop is equivalent to a do-while loop that runs as long as the condition is true. Let me think: the while loop runs as long as the condition is true. The for loop in Candidate A is equivalent to a while loop that runs while param_4 !=0, and each iteration decrements param_4. So, the for loop is actually similar to a while loop with a decrement after each iteration.\n\nBut in Candidate B, the do-while loop runs at least once, then continues as long as param_4 !=0. So, the structure is a bit different.\n\nBut in terms of structural isomorphism, the Source uses a while loop, so the candidate that uses a while-like structure would be better. However, neither A nor B uses a while loop. So, perhaps the structural isomorphism is not perfect in either, but which is closer?\n\nWait, the Source's loop is a while loop, and Candidate B's structure is a do-while, which is a similar construct. The for loop in A is a different construct but functionally similar. However, the Source's loop is a while, so the candidate that uses a while-like structure (do-while) might be considered closer.\n\nBut wait, the Source's loop is a while loop that decrements after each iteration. So, the for loop in A is actually a for loop that initializes with no expression, checks param_4 !=0, and decrements each time. So, it's functionally equivalent to a while loop. But structurally, it's a for loop.\n\nIn terms of isomorphism, the Source has a while loop, so a while loop in the candidate would be better. But neither A nor B uses a while loop. So, perhaps neither is perfect, but which is closer?\n\nAlternatively, perhaps the structure in B is more similar because it's a do-while, which is a variation of a while loop, whereas the for loop in A is a different construct.\n\nBut wait, the Source's loop is a while loop that decrements after each iteration. So, the for loop in A is structurally similar because it's a loop that runs as long as param_4 is non-zero, and each iteration decrements it. So, the for loop is a direct translation of the while loop.\n\nIn that case, perhaps Candidate A is more structurally isomorphic because it's a for loop that does the same thing as the Source's while loop.\n\nWait, but the Source's while loop is:\n\nwhile (src_len && (src[src_len-1] == ' ' || src[src_len-1] == '\\0')) {\n    src_len--;\n}\n\nWhich is equivalent to:\n\ndo {\n    if (src[src_len-1] == ' ' || src[src_len-1] == '\\0') {\n        src_len--;\n    } else {\n        break;\n    }\n} while (src_len != 0);\n\nWait, no. The while loop condition is src_len and the condition on the character. So, each iteration, it checks if the last character is space or null, and if so, decrements src_len. It continues until src_len is zero or the last character is not space or null.\n\nSo, the while loop is equivalent to a do-while loop that runs as long as src_len is non-zero and the condition is true.\n\nWait, no. The while loop will run as long as the condition is true. So, it's possible that in each iteration, the condition is checked, and if true, it decrements src_len. So, the loop will run until src_len is zero or the last character is not space or null.\n\nSo, in terms of structure, the Source's loop is a while loop, which is a pre-test loop. Candidate A's for loop is also a pre-test loop, which is structurally similar. Candidate B's do-while is a post-test loop, which is a different structure.\n\nTherefore, in terms of structural isomorphism, Candidate A's for loop is closer to the Source's while loop than Candidate B's do-while loop.\n\nWait, but the for loop in A is written as:\n\nfor (; param_4 != 0; param_4 = param_4 - 1) {\n    if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n}\n\nWhich is equivalent to:\n\nwhile (param_4 != 0) {\n    if ((param_3[param_4 - 1] & 0xdfU) != 0) {\n        goto LAB_00101160;\n    }\n    param_4--;\n}\n\nSo, it's a while loop with a decrement after each iteration, similar to the Source's while loop.\n\nBut in the Source, the loop is a while that decrements src_len each time, regardless of the condition. Wait, no: the Source's loop decrements src_len only if the condition is true. Wait, no, the loop in the Source is:\n\nwhile (src_len && (src[src_len-1] == ' ' || src[src_len-1] == '\\0')) {\n    src_len--;\n}\n\nSo, as long as src_len is non-zero and the last character is space or null, it decrements src_len. So, it's a loop that runs as long as the condition is true, and each iteration decrements src_len.\n\nIn Candidate A's for loop, the condition is param_4 !=0, and each iteration decrements param_4. So, it's similar in structure.\n\nIn Candidate B, the code is:\n\nif (param_4 != 0) {\n    do {\n        if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n        param_4 = param_4 - 1;\n    } while (param_4 != 0);\n}\n\nSo, this is a do-while loop that runs as long as param_4 is non-zero. Each iteration, it checks the condition and then decrements param_4.\n\nSo, in terms of structure, the Source uses a while loop, which is a pre-test loop. Candidate A uses a for loop, which is also a pre-test loop, similar to while. Candidate B uses a do-while, which is a post-test loop.\n\nSo, for structural isomorphism, the Source uses a while loop, so a while or for loop would be better. Since the for loop in A is structurally similar, perhaps it's better than the do-while in B.\n\nBut wait, the for loop in A is a bit more complex. Let me see: the for loop has no initializer, condition is param_4 !=0, and the update is param_4 = param_4 -1. So, it's equivalent to a while loop that runs as long as param_4 is non-zero, and each iteration decrements it.\n\nBut in the Source, the loop is a while that runs as long as param_4 is non-zero and the last character is space or null. Wait, no, the condition is src_len and the character condition. So, in the Source, the loop runs as long as src_len is non-zero and the last character is space or null.\n\nIn Candidate A's for loop, the condition is only param_4 !=0, and inside the loop, it checks if the character is not space or null, and if so, jumps. So, the for loop in A is actually a bit different in terms of the condition. Because in the Source, the loop continues as long as the last character is space or null, but in A, the loop continues as long as param_4 is non-zero, and inside, it checks if the character is not space or null, then jumps.\n\nWait, that might be a problem. Because in the Source, the loop decrements src_len only if the last character is space or null. So, the loop runs multiple times, each time checking the last character, and only decrements if it's space or null.\n\nIn Candidate A's for loop, the loop runs as long as param_4 is non-zero, and in each iteration, it checks if the last character is not space or null, and if so, jumps. Otherwise, it continues. So, the for loop in A is not exactly the same as the Source's while loop because in A, the loop will run even if the last character is not space or null, but in the Source, the loop only runs when the last character is space or null.\n\nWait, no. Let me think again. The Source's loop is:\n\nwhile (src_len && (src[src_len-1] == ' ' || src[src_len-1] == '\\0')) {\n    src_len--;\n}\n\nSo, the loop runs as long as src_len is non-zero and the last character is space or null. Each iteration, it decrements src_len.\n\nIn Candidate A's for loop:\n\nfor (; param_4 != 0; param_4 = param_4 - 1) {\n    if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n}\n\nHere, param_4 is src_len. The loop runs as long as param_4 is non-zero. Inside, it checks if the last character (param_3[param_4 -1]) is not a space or null (since 0xdf is 223, which is 0xff & 0xdf, so it's checking if the lower 7 bits are non-zero, which would mean it's a non-ASCII character? Or perhaps it's checking if the character is not a space or null. Wait, the condition is (param_3[param_4 -1] & 0xdfU) !=0. So, if the character is a space (ASCII 32) or null (0), their lower 7 bits would be 0, so the condition would be false. So, the if statement is checking if the character is not space or null. If it's not, then it jumps to the label.\n\nWait, so in the Source, the loop continues as long as the last character is space or null, and in each iteration, it decrements src_len. So, the loop stops when the last character is not space or null.\n\nIn Candidate A, the for loop runs as long as param_4 is non-zero, and in each iteration, it checks if the last character is not space or null. If it's not, it jumps to the label. So, the loop continues until it finds a character that is not space or null, then it jumps. So, in this case, the for loop in A is actually equivalent to the Source's while loop because it decrements param_4 each time, and exits when the last character is not space or null.\n\nWait, no. Because in the Source, the loop decrements src_len each time, regardless of whether the character is space or null. So, the loop runs multiple times, each time checking the last character. If it's space or null, it decrements. If not, the loop stops.\n\nIn Candidate A, the for loop runs as long as param_4 is non-zero, and in each iteration, it checks if the last character is not space or null. If it is, it jumps. Otherwise, it continues, and param_4 is decremented.\n\nWait, no. The for loop in A decrements param_4 each time, regardless of the condition. So, it will run as long as param_4 is non-zero, and in each iteration, it checks if the last character is not space or null. If it is, it jumps. Otherwise, it continues, and param_4 is decremented.\n\nSo, in this case, the for loop in A is actually incorrect because it decrements param_4 even when the last character is not space or null. Because in the Source, the loop only decrements when the last character is space or null. So, in A, the loop is decrementing param_4 every time, which is not correct. That would cause src_len to be decremented even when the last character is not space or null, which is wrong.\n\nWait, that's a problem. So, in the Source, the loop only decrements src_len when the last character is space or null. So, in the Source, the loop runs as long as the last character is space or null, and each iteration decrements src_len.\n\nIn Candidate A, the for loop runs as long as param_4 is non-zero, and each iteration decrements param_4. So, it's decrementing param_4 regardless of whether the last character is space or null. That's incorrect because it would decrement even when the last character is not space or null, which is not what the Source does.\n\nSo, in terms of structural isomorphism, Candidate A's for loop is not correct because it doesn't match the condition of the Source's while loop. It's decrementing param_4 every time, which is wrong.\n\nIn Candidate B, the code is:\n\nif (param_4 != 0) {\n    do {\n        if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n        param_4 = param_4 - 1;\n    } while (param_4 != 0);\n}\n\nSo, this is a do-while loop that runs as long as param_4 is non-zero. In each iteration, it checks if the last character is not space or null. If it is, it jumps. Otherwise, it decrements param_4.\n\nWait, no. The do-while loop runs at least once, then continues as long as param_4 is non-zero. So, in each iteration, it checks if the last character is not space or null, and if so, jumps. Otherwise, it decrements param_4.\n\nWait, but in the Source, the loop decrements src_len only when the last character is space or null. So, in Candidate B, the loop decrements param_4 only when the last character is space or null, because if the last character is not space or null, it jumps, so param_4 is not decremented.\n\nWait, no. Let me think again. The do-while loop in B runs as long as param_4 is non-zero. Each iteration, it checks if the last character is not space or null. If it is, it jumps. If not, it decrements param_4.\n\nSo, the loop will run as long as param_4 is non-zero, and in each iteration, it checks the last character. If the last character is not space or null, it jumps. If it is, it decrements param_4 and continues.\n\nWait, no. The do-while loop in B is:\n\ndo {\n    if (condition) goto label;\n    param_4--;\n} while (param_4 != 0);\n\nSo, in each iteration, it checks the condition. If true, jumps. If false, it decrements param_4 and continues.\n\nSo, this is equivalent to:\n\nwhile (param_4 != 0) {\n    if (condition) {\n        goto label;\n    }\n    param_4--;\n}\n\nWhich is the same as the Source's loop, which decrements src_len only when the last character is space or null.\n\nWait, no. Because in the Source, the loop runs as long as the last character is space or null, and in each iteration, it decrements src_len. So, the Source's loop is:\n\nwhile (src_len && (last char is space or null)) {\n    src_len--;\n}\n\nWhich is equivalent to:\n\nwhile (src_len != 0) {\n    if (last char is not space or null) {\n        break;\n    }\n    src_len--;\n}\n\nSo, the Source's loop decrements src_len only when the last character is space or null. So, in the Source, the loop may run multiple times, each time checking the last character, and only decrementing when it's space or null.\n\nIn Candidate B's do"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_printable-O2.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,long param_4,long param_5)\n\n{\n  byte bVar1;\n  ushort **ppuVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  bool bVar5;\n  \n  pbVar3 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    uVar4 = param_4 + 1;\n    while( true ) {\n      bVar1 = *(byte *)(uVar4 - 1);\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar2 = __ctype_b_loc(), (*(byte *)((long)*ppuVar2 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar3) break;\n        *pbVar3 = 0x5c;\n        pbVar3[1] = *(byte *)(uVar4 - 1) >> 6 | 0x30;\n        pbVar3[2] = *(byte *)(uVar4 - 1) >> 3 & 7 | 0x30;\n        pbVar3[3] = *(byte *)(uVar4 - 1) & 7 | 0x30;\n        pbVar3 = pbVar3 + 4;\n      }\n      else {\n        *pbVar3 = bVar1;\n        pbVar3 = pbVar3 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar3) ||\n         (bVar5 = (ulong)(param_5 + param_4) <= uVar4, uVar4 = uVar4 + 1, bVar5)) break;\n    }\n  }\n  *pbVar3 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, *id = id + id - 1;\n  type *id = call(id unsigned char id);\n  type *id = id + id;\n  for(id = id;  id < id && id < id && *id; id++){\n    if((id->id & id) != 0 || call(*id)){\n      *id++ = *id;\n      continue;\n    }\n    if(id >= id - 3)break;\n    *id++ = str;\n    *id++ = ((type)&7) + str;\n    *id++ = ((type)&7) + str;\n    *id++ = ((type)&7) + str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id + id + -1) && (0 < id)){\n    id = id;\n    while(bool){\n      id = id + 1;\n      id = *id;\n      if((type)id == 0)break;\n      if(((*(type)(id + 0x45) & 1) == 0) && (id = call()(*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0)){\n        if(id + id + -4 <= id)break;\n        *id = 0x5c;\n        id[1] = *id >> 6 | 0x30;\n        id[2] = *id >> 3 & 7 | 0x30;\n        id[3] = *id & 7 | 0x30;\n        id = id + 4;\n      }else{\n        *id = id;\n        id = id + 1;\n      }\n      if((id + id + -1 <= id) || (id = idid + id <= id))break;\n    }\n  }\n  *id = 0;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id,  id,  id){\n  type id;\n  type **id;\n  type *id;\n  type id;\n  type id;\n  id = id;\n  if((id < id + id + -1) && (0 < id)){\n    id = id + 1;\n    while(bool){\n      id = *(type)(id - 1);\n      if((type)id == 0)break;\n      if(((*(type)(id + 0x45) & 1) == 0) && (id = call()(*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0)){\n        if(id + id + -4 <= id)break;\n        *id = 0x5c;\n        id[1] = *(type)(id - 1) >> 6 | 0x30;\n        id[2] = *(type)(id - 1) >> 3 & 7 | 0x30;\n        id[3] = *(type)(id - 1) & 7 | 0x30;\n        id = id + 4;\n      }else{\n        *id = id;\n        id = id + 1;\n      }\n      if((id + id + -1 <= id) || (id = call(id + id) <= idid = id + 1id))break;\n    }\n  }\n  *id = 0;\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.484375,
          "base_ppl": 3.109375,
          "pr_ppl": 3.015625,
          "source_ast_ppl": 6.6875,
          "base_ast_ppl": 5.1875,
          "pr_ast_ppl": 5.1875,
          "delta_ppl": -0.09375
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "motivation": "Candidate B improves the code by making it more structured and human-like. It removes redundant assignments, uses more explicit variable updates, and avoids unnecessary nesting, aligning with higher-level control flow structures.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores the correct number of parameters and maintains the Source's structure without adding extra loops, matching the nesting depth.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-file_file_printable-O3.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,long param_4,long param_5)\n\n{\n  byte bVar1;\n  ushort **ppuVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  bool bVar5;\n  \n  pbVar3 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    uVar4 = param_4 + 1;\n    while( true ) {\n      bVar1 = *(byte *)(uVar4 - 1);\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar2 = __ctype_b_loc(), (*(byte *)((long)*ppuVar2 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar3) break;\n        *pbVar3 = 0x5c;\n        pbVar3[1] = *(byte *)(uVar4 - 1) >> 6 | 0x30;\n        pbVar3[2] = *(byte *)(uVar4 - 1) >> 3 & 7 | 0x30;\n        pbVar3[3] = *(byte *)(uVar4 - 1) & 7 | 0x30;\n        pbVar3 = pbVar3 + 4;\n      }\n      else {\n        *pbVar3 = bVar1;\n        pbVar3 = pbVar3 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar3) ||\n         (bVar5 = (ulong)(param_5 + param_4) <= uVar4, uVar4 = uVar4 + 1, bVar5)) break;\n    }\n  }\n  *pbVar3 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, *id = id + id - 1;\n  type *id = call(id unsigned char id);\n  type *id = id + id;\n  for(id = id;  id < id && id < id && *id; id++){\n    if((id->id & id) != 0 || call(*id)){\n      *id++ = *id;\n      continue;\n    }\n    if(id >= id - 3)break;\n    *id++ = str;\n    *id++ = ((type)&7) + str;\n    *id++ = ((type)&7) + str;\n    *id++ = ((type)&7) + str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id + id + -1) && (0 < id)){\n    id = id;\n    while(bool){\n      id = id + 1;\n      id = *id;\n      if((type)id == 0)break;\n      if(((*(type)(id + 0x45) & 1) == 0) && (id = call()(*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0)){\n        if(id + id + -4 <= id)break;\n        *id = 0x5c;\n        id[1] = *id >> 6 | 0x30;\n        id[2] = *id >> 3 & 7 | 0x30;\n        id[3] = *id & 7 | 0x30;\n        id = id + 4;\n      }else{\n        *id = id;\n        id = id + 1;\n      }\n      if((id + id + -1 <= id) || (id = idid + id <= id))break;\n    }\n  }\n  *id = 0;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id,  id,  id){\n  type id;\n  type **id;\n  type *id;\n  type id;\n  type id;\n  id = id;\n  if((id < id + id + -1) && (0 < id)){\n    id = id + 1;\n    while(bool){\n      id = *(type)(id - 1);\n      if((type)id == 0)break;\n      if(((*(type)(id + 0x45) & 1) == 0) && (id = call()(*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0)){\n        if(id + id + -4 <= id)break;\n        *id = 0x5c;\n        id[1] = *(type)(id - 1) >> 6 | 0x30;\n        id[2] = *(type)(id - 1) >> 3 & 7 | 0x30;\n        id[3] = *(type)(id - 1) & 7 | 0x30;\n        id = id + 4;\n      }else{\n        *id = id;\n        id = id + 1;\n      }\n      if((id + id + -1 <= id) || (id = call(id + id) <= idid = id + 1id))break;\n    }\n  }\n  *id = 0;\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.484375,
          "base_ppl": 3.109375,
          "pr_ppl": 3.015625,
          "source_ast_ppl": 6.6875,
          "base_ast_ppl": 5.1875,
          "pr_ast_ppl": 5.1875,
          "delta_ppl": -0.09375
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "motivation": "Candidate A maintains a cleaner control flow with less complex conditions and fewer nested blocks, making it more reflective of high-level human thinking. The changes in Candidate B introduce more complex conditions and less semantic structure, making it less idiomatic.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate B better preserves the Source's structure with more accurate node types and nesting, aligning with the Source's complexity.",
          "winner": "PR"
        }
      }
    ],
    "qwen-2.5": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type *id){\n  if(!id)return id;\n  type id = id0id0;\n  type id = id0id0;\n  type *id = null;\n  type id = 0;\n  type id = id;\n  call(str);\n  do{\n    if(id > 10){\n      call(str, (type)id->id);\n      call(str, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, 1, 4, id->id) != 4){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == null){\n        if(id)call(id, str, (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, 1, id.id, id->id) != id.id){\n        if(id)call(id, str);\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[0] + (id[1] << 8) != 0x600);\n        id->id = id[2] + (id[3] << 8);\n        if(id){\n          call(str, (id->id ? str : str));\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id->id = id[0] + (id[1] << 8);\n        if(id)call(str, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call(str);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }else{\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type *id;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            if(id)call(str, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type *id;\n          id = (type)id;\n          call(str, id->id & 0x07FF);\n          if(id->id & 0x8000){\n            call(str, id->id);\n            call(str, id->id);\n          }else{\n            type *id = call((type)&id[2], id.id - 2, 1, id);\n            call(str, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > 10){\n          type *id = id + 2;\n          type id, id;\n          id = id[0] + (id[1] << 8);\n          for(id = 0;  id < id; ++id){\n            call(str, id + 8, id[0], id[1], id[2]);\n            id = 4;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call(str);\n          for(id = 0;  id < id.id; ++id)call(str, id[id]);\n          call(str);\n        }\n        break;\n      case def:\n        if(id){\n          call(str, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = 1;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = call(id) * id;\n            *(type)((type)id + 0xd) = (id) * id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (type)(type)id[id * 2 + 1], (id) * (type)((type)id + id * 4 + 3), (type)(type)id[id * 2 + 2]);\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (type)(type)id[1]);\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = (type)call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = call(id) * id;\n            *(type)((type)id + 0xd) = (id) * id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (type)(type)id[id * 2 + 1], (id) * (type)((type)id + id * 4 + 3), (type)(type)id[id * 2 + 2]);\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (type)(type)id[1]);\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.234375,
          "base_ppl": 1.8203125,
          "pr_ppl": 1.8203125,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces a type cast to (ushort *) which is not present in the Source Code. This type cast does not align with the Source Code structure and could be considered noise.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type *id){\n  if(!id)return id;\n  type id = id0id0;\n  type id = id0id0;\n  type *id = null;\n  type id = 0;\n  type id = id;\n  call(str);\n  do{\n    if(id > 10){\n      call(str, (type)id->id);\n      call(str, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, 1, 4, id->id) != 4){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == null){\n        if(id)call(id, str, (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, 1, id.id, id->id) != id.id){\n        if(id)call(id, str);\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[0] + (id[1] << 8) != 0x600);\n        id->id = id[2] + (id[3] << 8);\n        if(id){\n          call(str, (id->id ? str : str));\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id->id = id[0] + (id[1] << 8);\n        if(id)call(str, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call(str);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }else{\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type *id;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            if(id)call(str, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type *id;\n          id = (type)id;\n          call(str, id->id & 0x07FF);\n          if(id->id & 0x8000){\n            call(str, id->id);\n            call(str, id->id);\n          }else{\n            type *id = call((type)&id[2], id.id - 2, 1, id);\n            call(str, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > 10){\n          type *id = id + 2;\n          type id, id;\n          id = id[0] + (id[1] << 8);\n          for(id = 0;  id < id; ++id){\n            call(str, id + 8, id[0], id[1], id[2]);\n            id = 4;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call(str);\n          for(id = 0;  id < id.id; ++id)call(str, id[id]);\n          call(str);\n        }\n        break;\n      case def:\n        if(id){\n          call(str, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = 1;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = call(id) * id;\n            *(type)((type)id + 0xd) = (id) * id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (type)(type)id[id * 2 + 1], (id) * (type)((type)id + id * 4 + 3), (type)(type)id[id * 2 + 2]);\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (type)(type)id[1]);\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = (type)call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = call(id) * id;\n            *(type)((type)id + 0xd) = (id) * id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (type)(type)id[id * 2 + 1], (id) * (type)((type)id + id * 4 + 3), (type)(type)id[id * 2 + 2]);\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (type)(type)id[1]);\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.234375,
          "base_ppl": 1.8203125,
          "pr_ppl": 1.8203125,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A maintains the original structure and type casting, while Candidate B introduces an incorrect type cast to 'ushort *' which is not aligned with the source code's usage of 'BYTE *'.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "type id(type *id){\n  if(!id)return id;\n  type id = id0id0;\n  type id = id0id0;\n  type *id = null;\n  type id = 0;\n  type id = id;\n  call(str);\n  do{\n    if(id > 10){\n      call(str, (type)id->id);\n      call(str, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, 1, 4, id->id) != 4){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == null){\n        if(id)call(id, str, (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, 1, id.id, id->id) != id.id){\n        if(id)call(id, str);\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[0] + (id[1] << 8) != 0x600);\n        id->id = id[2] + (id[3] << 8);\n        if(id){\n          call(str, (id->id ? str : str));\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id->id = id[0] + (id[1] << 8);\n        if(id)call(str, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call(str);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }else{\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type *id;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            if(id)call(str, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type *id;\n          id = (type)id;\n          call(str, id->id & 0x07FF);\n          if(id->id & 0x8000){\n            call(str, id->id);\n            call(str, id->id);\n          }else{\n            type *id = call((type)&id[2], id.id - 2, 1, id);\n            call(str, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > 10){\n          type *id = id + 2;\n          type id, id;\n          id = id[0] + (id[1] << 8);\n          for(id = 0;  id < id; ++id){\n            call(str, id + 8, id[0], id[1], id[2]);\n            id = 4;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call(str);\n          for(id = 0;  id < id.id; ++id)call(str, id[id]);\n          call(str);\n        }\n        break;\n      case def:\n        if(id){\n          call(str, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = 1;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = id;\n    call(&id, 0, 4);\n    call(&id, 0, 4);\n    id = (type)0x0;\n    id = bool;\n    id = 0;\n    call(str);\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        call(str, (id) * (type)(*id + 8), *(type)(*id + 0x10) & 0xffffffff, *(type)(*id + 0x20) & 0xffffffff, *(type)(*id + 0x28) & 0xffffffff);\n      }\n      id = call(&id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(&id);\n      if(*(type)id != 0){\n        call(&id);\n      }\n      if(id.id != 0){\n        id = call(id, (type)id.id);\n        if(id == (type)0x0){\n          if(*(type)id != 0){\n            call(*(type)id, str, (type)id.id);\n          }\n          id = 5;\n          break;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != 0){\n            call(*(type)id, str);\n          }\n          id = 3;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      id = id & 0xffff;\n      if(id != 10){\n        if(id == 0x18){\n          if(*(type)id != 0){\n            call(str);\n            for(id = 0;  id < (type)(id >> 0x10); id = id + 1){\n              call(str, (id) * (type)((type)id + (type)id));\n            }\n            call(str);\n          }\n        }elseif(id == 0x22){\n          *(type)((type)id + 0xd) = (id) * id;\n          if(*(type)id != 0){\n            call(str, (id) * (type)((type)id + 0xd));\n          }\n        }else{\n          if(id == 0x2f){\n            id = 6;\n            break;\n          }\n          if(id == 0x31){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n          }elseif(id == 0x3c){\n            if(id){\n              if(((type)id == 0xfc) && (id = call(id, id, id.id)id != 0))break;\n              id = id;\n            }\n          }elseif(id == 0x3d){\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, (id) * id / 0x14, (id) * id % 0x14);\n              call(str, (type)id[1] / 0x14, (type)id[1] % 0x14);\n              call(str, (type)id[2] / 0x14, (type)id[2] % 0x14);\n              call(str, (type)id[3] / 0x14, (type)id[3] % 0x14);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              call(str, (type)id[8]);\n            }\n          }elseif(id == 0x42){\n            *(type)((type)id + 0x12) = call(id) * id + (id) * (type)((type)id + 1) * 0x100;\n            if(*(type)id != 0){\n              call(str, (id) * (type)((type)id + 0x12));\n            }\n          }elseif(id == 0x85){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != 0)break;\n          }elseif(id == 0x92){\n            if(10 < *(type)id){\n              id = id + 1;\n              id = *id;\n              id = *(type)((type)id + 1);\n              for(id = 0;  id < (type)((type)(type)id + (type)id * 0x100); id = id + 1){\n                call(str, call(id + 8), call(id) * id, (id) * (type)((type)id + 1), (type)(type)id[1]);\n                id = id + 2;\n              }\n            }\n          }elseif(id == 0xe0){\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(str, (id) * id);\n                call(str, (type)id[1]);\n                call(str, (type)id[2]);\n                call(str, (type)id[3]);\n                call(str, (type)id[4]);\n                call(str, (type)id[5]);\n                call(str, (type)id[6]);\n                call(str, (type)id[7]);\n              }\n            }\n          }else{\n            if(id == 0xfc){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != 0xff){\n              if(id == 0x231)goto lbl;\n              if(id == 0x293){\n                if(*(type)id != 0){\n                  call(str, call(*id & 0x7ff));\n                  if((*id & 0x8000) == 0){\n                    id = (type)call(id + 1, (type)(type)((id >> 0x10) - 2), 1, id);\n                    call(str, id);\n                    call(id);\n                  }else{\n                    call(str, (type)(type)id[1]);\n                    call(str, (id) * (type)((type)id + 3));\n                  }\n                }\n              }else{\n                if(id == 0x41e){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == 0x809){\n                  *(type)((type)id + 0xc) = call(id) * id + (id) * (type)((type)id + 1) * 0x100 != 0x600;\n                  *(type)((type)id + 0xe) = (type)(type)id[1] + (id) * (type)((type)id + 3) * 0x100;\n                  if(*(type)id != 0){\n                    id = str;\n                    if(*(type)((type)id + 0xc) != str){\n                      id = str;\n                    }\n                    call(str, id);\n                    call(str, (id) * (type)((type)id + 0xe));\n                  }\n                }elseif(*(type)id != 0){\n                  call(str, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id + 0x3c) == str){\n        id = (type)id != 10;\n      }\n    }while(id);\n    if(id != (type)0x0){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = id;\n    call(&id, 0, 4);\n    call(&id, 0, 4);\n    id = (type)0x0;\n    id = bool;\n    id = 0;\n    call(str);\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        call(str, (id) * (type)(*id + 8), *(type)(*id + 0x10) & 0xffffffff, *(type)(*id + 0x20) & 0xffffffff, *(type)(*id + 0x28) & 0xffffffff);\n      }\n      id = call(&id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(&id);\n      if(*(type)id != 0){\n        call(&id);\n      }\n      if(id.id != 0){\n        id = (type)call(id, (type)id.id);\n        if(id == (type)0x0){\n          if(*(type)id != 0){\n            call(*(type)id, str, (type)id.id);\n          }\n          id = 5;\n          break;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != 0){\n            call(*(type)id, str);\n          }\n          id = 3;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      id = id & 0xffff;\n      if(id != 10){\n        if(id == 0x18){\n          if(*(type)id != 0){\n            call(str);\n            for(id = 0;  id < (type)(id >> 0x10); id = id + 1){\n              call(str, (id) * (type)((type)id + (type)id));\n            }\n            call(str);\n          }\n        }elseif(id == 0x22){\n          *(type)((type)id + 0xd) = (id) * id;\n          if(*(type)id != 0){\n            call(str, (id) * (type)((type)id + 0xd));\n          }\n        }else{\n          if(id == 0x2f){\n            id = 6;\n            break;\n          }\n          if(id == 0x31){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n          }elseif(id == 0x3c){\n            if(id){\n              if(((type)id == 0xfc) && (id = call(id, id, id.id)id != 0))break;\n              id = id;\n            }\n          }elseif(id == 0x3d){\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, (id) * id / 0x14, (id) * id % 0x14);\n              call(str, (type)id[1] / 0x14, (type)id[1] % 0x14);\n              call(str, (type)id[2] / 0x14, (type)id[2] % 0x14);\n              call(str, (type)id[3] / 0x14, (type)id[3] % 0x14);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              call(str, (type)id[8]);\n            }\n          }elseif(id == 0x42){\n            *(type)((type)id + 0x12) = call(id) * id + (id) * (type)((type)id + 1) * 0x100;\n            if(*(type)id != 0){\n              call(str, (id) * (type)((type)id + 0x12));\n            }\n          }elseif(id == 0x85){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != 0)break;\n          }elseif(id == 0x92){\n            if(10 < *(type)id){\n              id = id + 1;\n              id = *id;\n              id = *(type)((type)id + 1);\n              for(id = 0;  id < (type)((type)(type)id + (type)id * 0x100); id = id + 1){\n                call(str, call(id + 8), call(id) * id, (id) * (type)((type)id + 1), (type)(type)id[1]);\n                id = id + 2;\n              }\n            }\n          }elseif(id == 0xe0){\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(str, (id) * id);\n                call(str, (type)id[1]);\n                call(str, (type)id[2]);\n                call(str, (type)id[3]);\n                call(str, (type)id[4]);\n                call(str, (type)id[5]);\n                call(str, (type)id[6]);\n                call(str, (type)id[7]);\n              }\n            }\n          }else{\n            if(id == 0xfc){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != 0xff){\n              if(id == 0x231)goto lbl;\n              if(id == 0x293){\n                if(*(type)id != 0){\n                  call(str, call(*id & 0x7ff));\n                  if((*id & 0x8000) == 0){\n                    id = (type)call(id + 1, (type)(type)((id >> 0x10) - 2), 1, id);\n                    call(str, id);\n                    call(id);\n                  }else{\n                    call(str, (type)(type)id[1]);\n                    call(str, (id) * (type)((type)id + 3));\n                  }\n                }\n              }else{\n                if(id == 0x41e){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == 0x809){\n                  *(type)((type)id + 0xc) = call(id) * id + (id) * (type)((type)id + 1) * 0x100 != 0x600;\n                  *(type)((type)id + 0xe) = (type)(type)id[1] + (id) * (type)((type)id + 3) * 0x100;\n                  if(*(type)id != 0){\n                    id = str;\n                    if(*(type)((type)id + 0xc) != str){\n                      id = str;\n                    }\n                    call(str, id);\n                    call(str, (id) * (type)((type)id + 0xe));\n                  }\n                }elseif(*(type)id != 0){\n                  call(str, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id + 0x3c) == str){\n        id = (type)id != 10;\n      }\n    }while(id);\n    if(id != (type)0x0){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.234375,
          "base_ppl": 1.8125,
          "pr_ppl": 1.8125,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.1875,
          "pr_ast_ppl": 2.1875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces a type cast `(ushort *)` which is not present in the Source Code. This type cast is unnecessary and does not align with the Source Code structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 + 1];\n  type id[64 + 1];\n  type *id = null;\n  type id = 0;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id++;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 5:\n        {\n          id = id;\n        }\n        break;\n        case 6:\n        {\n          id = id - id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id++;\n              }\n            }\n          }\n          break;\n          case 4:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case 6:\n          {\n            id = id - id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id - id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = (type)call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = (type)call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.671875,
          "base_ppl": 1.6640625,
          "pr_ppl": 1.6640625,
          "source_ast_ppl": 2.078125,
          "base_ast_ppl": 2.015625,
          "pr_ast_ppl": 2.0,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 + 1];\n  type id[64 + 1];\n  type *id = null;\n  type id = 0;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id++;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 5:\n        {\n          id = id;\n        }\n        break;\n        case 6:\n        {\n          id = id - id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id++;\n              }\n            }\n          }\n          break;\n          case 4:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case 6:\n          {\n            id = id - id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id - id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = (type)call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = (type)call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.671875,
          "base_ppl": 1.6640625,
          "pr_ppl": 1.6640625,
          "source_ast_ppl": 2.078125,
          "base_ast_ppl": 2.015625,
          "pr_ast_ppl": 2.0,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces unnecessary type casting for the result of the bsearch function, which is not present in the Source Code. This casting does not affect the functionality but adds noise and moves the code further from the Source Code structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 * 4 + 1];\n  type id = 0;\n  type *id = null;\n  type id = 0;\n  type id = 1024 + id;\n  type *id = null;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id - 1;\n            while(id >= id && call(id->id, id) == 0){\n              id = id;\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              id = id;\n              id++;\n            }\n            for(id = id;  id <= id; id++){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          if((*id) != str){\n            type id = (*id) - str;\n            if(id <= (id - id) / 10){\n              id = 10 * id + id;\n            }else{\n              {\n                id++;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case 5:\n        {\n          id = 0;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id - 1;\n              while(id >= id && call(id->id, id) == 0){\n                id = id;\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                id = id;\n                id++;\n              }\n              for(id = id;  id <= id; id++){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id - id), (type)(id - id), (type)(id - id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = (type)call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = (type)call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.6796875,
          "base_ppl": 1.8046875,
          "pr_ppl": 1.796875,
          "source_ast_ppl": 2.28125,
          "base_ast_ppl": 2.265625,
          "pr_ast_ppl": 2.265625,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 * 4 + 1];\n  type id = 0;\n  type *id = null;\n  type id = 0;\n  type id = 1024 + id;\n  type *id = null;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id - 1;\n            while(id >= id && call(id->id, id) == 0){\n              id = id;\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              id = id;\n              id++;\n            }\n            for(id = id;  id <= id; id++){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          if((*id) != str){\n            type id = (*id) - str;\n            if(id <= (id - id) / 10){\n              id = 10 * id + id;\n            }else{\n              {\n                id++;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case 5:\n        {\n          id = 0;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id - 1;\n              while(id >= id && call(id->id, id) == 0){\n                id = id;\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                id = id;\n                id++;\n              }\n              for(id = id;  id <= id; id++){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id - id), (type)(id - id), (type)(id - id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = (type)call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = (type)call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.6796875,
          "base_ppl": 1.796875,
          "pr_ppl": 1.796875,
          "source_ast_ppl": 2.28125,
          "base_ast_ppl": 2.265625,
          "pr_ast_ppl": 2.265625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 + 1];\n  type id[64 + 1];\n  type *id = null;\n  type id = 0;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id++;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 5:\n        {\n          id = id;\n        }\n        break;\n        case 6:\n        {\n          id = id - id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id++;\n              }\n            }\n          }\n          break;\n          case 4:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case 6:\n          {\n            id = id - id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id - id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[8192];\n  type id;\n  type *id;\n  type id[79];\n  type id[9];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + (type)id;\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)*(type)(id + (type)id * 2);\n    id = (id) * (type)(id + (type)id * 2);\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] + 0x2c];\n      id = &id + (type)(type)id[id];\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id == (type)0x0){\n              call(id, 0x2000, str, id);\n              if(*(type)(id + 0x30) != 0){\n                call(id, *(type)(id + 0x50));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id + -0x28;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id;\n              }\n            }\n            break;\n          case 4:\n            call(id, id, id);\n            id[id] = 0;\n            break;\n          case 5:\n            id = id;\n            break;\n          case 6:\n            id = (type)id - (type)id;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] + 0x2c];\n    id = &id + (type)(type)id[id];\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, 0x28, id);\n        id = id;\n        if(id == (type)0x0){\n          call(id, 0x2000, str, id);\n          if(*(type)(id + 0x30) != 0){\n            call(id, *(type)(id + 0x50));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id + -0x28;\n          }\n          while(bool){\n            id = id + 0x28;\n            id = bool;\n            if(((type)id - (type)id) / 0x28 < (type)id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = 0;\n      }elseif(id == str){\n        id = (type)id - (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, (type)id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[8192];\n  type id;\n  type *id;\n  type id[79];\n  type id[9];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + (type)id;\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)*(type)(id + (type)id * 2);\n    id = (id) * (type)(id + (type)id * 2);\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] + 0x2c];\n      id = &id + (type)(type)id[id];\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = (type)call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id == (type)0x0){\n              call(id, 0x2000, str, id);\n              if(*(type)(id + 0x30) != 0){\n                call(id, *(type)(id + 0x50));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id + -0x28;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id;\n              }\n            }\n            break;\n          case 4:\n            call(id, id, id);\n            id[id] = 0;\n            break;\n          case 5:\n            id = id;\n            break;\n          case 6:\n            id = (type)id - (type)id;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] + 0x2c];\n    id = &id + (type)(type)id[id];\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = (type)call(id, id, (type)id, 0x28, id);\n        id = id;\n        if(id == (type)0x0){\n          call(id, 0x2000, str, id);\n          if(*(type)(id + 0x30) != 0){\n            call(id, *(type)(id + 0x50));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id + -0x28;\n          }\n          while(bool){\n            id = id + 0x28;\n            id = bool;\n            if(((type)id - (type)id) / 0x28 < (type)id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = 0;\n      }elseif(id == str){\n        id = (type)id - (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, (type)id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.671875,
          "base_ppl": 1.6015625,
          "pr_ppl": 1.6015625,
          "source_ast_ppl": 2.078125,
          "base_ast_ppl": 1.9921875,
          "pr_ast_ppl": 1.984375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 * 4 + 1];\n  type id = 0;\n  type *id = null;\n  type id = 0;\n  type id = 1024 + id;\n  type *id = null;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id - 1;\n            while(id >= id && call(id->id, id) == 0){\n              id = id;\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              id = id;\n              id++;\n            }\n            for(id = id;  id <= id; id++){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          if((*id) != str){\n            type id = (*id) - str;\n            if(id <= (id - id) / 10){\n              id = 10 * id + id;\n            }else{\n              {\n                id++;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case 5:\n        {\n          id = 0;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id - 1;\n              while(id >= id && call(id->id, id) == 0){\n                id = id;\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                id = id;\n                id++;\n              }\n              for(id = id;  id <= id; id++){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id - id), (type)(id - id), (type)(id - id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + 0x400;\n  id = id + id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id + (type)(type)(type)id[id] + 1;\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id != (type)0x0){\n              while(bool){\n                id = id + -0x28;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id + 0x28){\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n              }\n            }\n            break;\n          case 4:\n            if(*id != 0){\n              if((-call(*id - 0x30) - 1) / 10 < id){\n                id = id + 1;\n                goto lbl;\n              }\n              id = id * 10 + call(*id - 0x30);\n            }\n            break;\n          case 5:\n            id = 0;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id + (type)(type)(type)id[id] + 1;\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        while(bool){\n          id = id + -0x28;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id + 0x28;\n          id = bool;\n          if(((type)id - (type)id) / 0x28 < (type)id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id + 0x28){\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)id, str, (type)id - (type)id, (type)id - (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + 0x400;\n  id = id + id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id + (type)(type)(type)id[id] + 1;\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = (type)call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id != (type)0x0){\n              while(bool){\n                id = id + -0x28;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id + 0x28){\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n              }\n            }\n            break;\n          case 4:\n            if(*id != 0){\n              if((-call(*id - 0x30) - 1) / 10 < id){\n                id = id + 1;\n                goto lbl;\n              }\n              id = id * 10 + call(*id - 0x30);\n            }\n            break;\n          case 5:\n            id = 0;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id + (type)(type)(type)id[id] + 1;\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = (type)call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        while(bool){\n          id = id + -0x28;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id + 0x28;\n          id = bool;\n          if(((type)id - (type)id) / 0x28 < (type)id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id + 0x28){\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)id, str, (type)id - (type)id, (type)id - (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.6796875,
          "base_ppl": 1.6171875,
          "pr_ppl": 1.6171875,
          "source_ast_ppl": 2.28125,
          "base_ast_ppl": 1.9296875,
          "pr_ast_ppl": 1.9375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[0].id == id)return id;\n  type id = 0;\n  type id = bool;\n  type id = bool;\n  type id = 0;\n  do{\n    type id;\n    for(id = 0;  id[id].id != id[id].id; ++id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[++id].id != id);\n  if(id > id || !id || id > 3)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if(id != (type)0x0){\n    id = *id;\n    if(id != -1){\n      id = 0;\n      id = 0;\n      id = 8;\n      id = bool;\n      do{\n        id = id + 2;\n        id = 1;\n        id = bool;\n        switch(id){\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 0xb:\n            id = bool;\n            id = 0;\n            break;\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x18:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n            goto lbl;\n          case 0x21:\n            break;\n          case def:\n            id = 1;\n            id = bool;\n            if(1 < id + 0xbfffffffffffffffU)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id + id;\n        id = id + 1;\n        id = *id;\n        id = id;\n      }while(id != -1);\n      if((id == 1 && id < 5) && (id < 4)){\n        *id = id;\n        id = 0;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if(id != (type)0x0){\n    id = *id;\n    if(id != -1){\n      id = id + 2;\n      id = 0;\n      id = 0;\n      id = 8;\n      id = bool;\n      do{\n        id = 1;\n        id = bool;\n        switch(id){\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 0xb:\n            id = bool;\n            id = 0;\n            break;\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x18:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n            goto lbl;\n          case 0x21:\n            break;\n          case def:\n            id = 1;\n            id = bool;\n            if(1 < id + 0xbfffffffffffffffU)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id + id;\n        id = id + 1;\n        id = *id;\n        id = id + 2;\n        id = id;\n      }while(id != -1);\n      if((id == 1 && id < 5) && (id < 4)){\n        *id = id;\n        id = 0;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.609375,
          "base_ppl": 1.6953125,
          "pr_ppl": 1.6875,
          "source_ast_ppl": 4.40625,
          "base_ast_ppl": 2.375,
          "pr_ast_ppl": 2.359375,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces an additional increment of param_1 before the switch statement, which is not present in the Source Code. This change does not align with the Source Code structure and introduces noise.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[0].id == id)return id;\n  type id = 0;\n  type id = bool;\n  type id = bool;\n  type id = 0;\n  do{\n    type id;\n    for(id = 0;  id[id].id != id[id].id; ++id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[++id].id != id);\n  if(id > id || !id || id > 3)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if(id != (type)0x0){\n    id = *id;\n    if(id != -1){\n      id = 0;\n      id = 0;\n      id = 8;\n      id = bool;\n      do{\n        id = id + 2;\n        id = 1;\n        id = bool;\n        switch(id){\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 0xb:\n            id = bool;\n            id = 0;\n            break;\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x18:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n            goto lbl;\n          case 0x21:\n            break;\n          case def:\n            id = 1;\n            id = bool;\n            if(1 < id + 0xbfffffffffffffffU)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id + id;\n        id = id + 1;\n        id = *id;\n        id = id;\n      }while(id != -1);\n      if((id == 1 && id < 5) && (id < 4)){\n        *id = id;\n        id = 0;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if(id != (type)0x0){\n    id = *id;\n    if(id != -1){\n      id = id + 2;\n      id = 0;\n      id = 0;\n      id = 8;\n      id = bool;\n      do{\n        id = 1;\n        id = bool;\n        switch(id){\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 0xb:\n            id = bool;\n            id = 0;\n            break;\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x18:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n            goto lbl;\n          case 0x21:\n            break;\n          case def:\n            id = 1;\n            id = bool;\n            if(1 < id + 0xbfffffffffffffffU)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id + id;\n        id = id + 1;\n        id = *id;\n        id = id + 2;\n        id = id;\n      }while(id != -1);\n      if((id == 1 && id < 5) && (id < 4)){\n        *id = id;\n        id = 0;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.609375,
          "base_ppl": 1.6953125,
          "pr_ppl": 1.6875,
          "source_ast_ppl": 4.40625,
          "base_ast_ppl": 2.375,
          "pr_ast_ppl": 2.359375,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_zmagic-O2.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type *id = null;\n  type id, id;\n  type *id;\n  type *id;\n  type id, id, id = 0;\n  type id = id->id & id;\n  type id = id->id;\n  type *id = call(id unsigned char id->id);\n  type id = id->id;\n  type id = 0;\n  type id;\n  if((id->id & id) == 0)return 0;\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, -1, null, id, id, id);\n        if(id == -1)goto lbl;\n        id = 1;\n        if((id->id & id) != 0)goto lbl;\n        if(id != id && id != 0)goto lbl;\n        if((call(id, (id ? str : str))) == -1)goto lbl;\n        if((id = call(id)) == null)goto lbl;\n        if(call(id, -1, null, null, id, id) == -1){\n          if(call(id, id) != null)call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != null){\n          if(call(id, str, id) == -1){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, str) == -1)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = -1;\n        break;\n    }\n  }\n  lbl:\n  call(str, id);\n  if(id && id.id != id)(type)call(id, &id, null);\n  call(id);\n  id->id = id;\n  call(str, id);\n  return id;\n}",
        "base_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < 0){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "pr_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(0 < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.203125,
          "base_ppl": 2.265625,
          "pr_ppl": 2.25,
          "source_ast_ppl": 3.890625,
          "base_ast_ppl": 2.9375,
          "pr_ast_ppl": 2.96875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_zmagic-O3.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type *id = null;\n  type id, id;\n  type *id;\n  type *id;\n  type id, id, id = 0;\n  type id = id->id & id;\n  type id = id->id;\n  type *id = call(id unsigned char id->id);\n  type id = id->id;\n  type id = 0;\n  type id;\n  if((id->id & id) == 0)return 0;\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, -1, null, id, id, id);\n        if(id == -1)goto lbl;\n        id = 1;\n        if((id->id & id) != 0)goto lbl;\n        if(id != id && id != 0)goto lbl;\n        if((call(id, (id ? str : str))) == -1)goto lbl;\n        if((id = call(id)) == null)goto lbl;\n        if(call(id, -1, null, null, id, id) == -1){\n          if(call(id, id) != null)call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != null){\n          if(call(id, str, id) == -1){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, str) == -1)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = -1;\n        break;\n    }\n  }\n  lbl:\n  call(str, id);\n  if(id && id.id != id)(type)call(id, &id, null);\n  call(id);\n  id->id = id;\n  call(str, id);\n  return id;\n}",
        "base_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < 0){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "pr_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(0 < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.203125,
          "base_ppl": 2.265625,
          "pr_ppl": 2.25,
          "source_ast_ppl": 3.890625,
          "base_ast_ppl": 2.9375,
          "pr_ast_ppl": 2.96875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O0.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "function_pr": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id = 0;\n  type id = id;\n  type *id = id->id;\n  type *id = call(1, (id));\n  type *id = call(1, (id));\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id > 0)id->id = id->id;\n  if(call(id, id->id) == -1){\n    id = id;\n    goto lbl;\n  }\n  if((id->id = call(0, id, id->id)) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if(call(0, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id, id, id->id.id, id)) != id){\n    goto lbl;\n  }\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = call() ^ id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = (id->id ? 8 : 4);\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id == null){\n    id->id = id->id;\n  }\n  if((id->id = call(id->id)) == null){\n    id = id;\n    goto lbl;\n  }\n  if(id->id && id->id && call(id->id, id->id) != 0){\n    type id = call(id->id, id->id);\n    if(id == (id) - 1){\n      id = id;\n      goto lbl;\n    }\n    id->id = id;\n  }\n  if((id = call(id->id, (id->id), id->id, (id->id), id->id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, &id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, id)) != id){\n    goto lbl;\n  }\n  if(call(id->id, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, 0)) != id){\n    goto lbl;\n  }\n  if(id->id.id && id->id != id->id){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  lbl:\n  call(id->id);\n  if(id == id || id == id || id == id){\n    if(id->id.id){\n      call(id->id, (id->id), str, call(id), id, call(id), id);\n      call(id->id, id);\n    }\n  }\n  if(id)call(id);\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = *(type)((type)id + 0x40);\n  id = id;\n  id = id;\n  id = id;\n  id = call(1, 0xdd0);\n  id = call(1, 0x180);\n  call(id, id, 0x40);\n  *(type)((type)id + 0x120) = *(type)((type)id + 0x48);\n  *(type)((type)id + 0x128) = *(type)((type)id + 0x50);\n  *(type)((type)id + 0x58) = id;\n  *(type)((type)id + 0x60) = *(type)((type)id + 0x40);\n  *(type)((type)id + 0x80) = (type)*(type)((type)id + 0x58);\n  if(0 < *(type)((type)id + 0x60)){\n    *(type)((type)id + 0x84) = (type)*(type)((type)id + 0x60);\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n  }else{\n    id = call(0, 2, id[5]);\n    *(type)((type)id + 0x40) = id;\n    if(id == -1){\n      id = 0xf;\n      if(*(type)((type)id + 0x30) != 0){\n        call((type)((type)id + 0x5ce), 0x800, str);\n        call((type)id + 0x5ce, *(type)((type)id + 0x58));\n      }\n    }else{\n      id = call(0, 0, id[5]);\n      if(id == -1){\n        id = 0xf;\n        if(*(type)((type)id + 0x30) != 0){\n          call((type)((type)id + 0x5ce), 0x800, str);\n          call((type)id + 0x5ce, *(type)((type)id + 0x58));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id + 0x30), id);\n        if(id == 0){\n          *(type)((type)id + 0x4c) = id[1];\n          *(type)((type)id + 0x48) = *id;\n          *(type)((type)id + 0x50) = id[2];\n          id = call();\n          *(type)((type)id + 0x68) = id ^ *id;\n          *(type)((type)id + 0x88) = *(type)(id + 0x10);\n          *(type)((type)id + 0x90) = *(type)(id + 0xe);\n          *(type)((type)id + 0x98) = *(type)(id + 8);\n          *(type)((type)id + 0xb0) = *(type)(id + 10);\n          *(type)((type)id + 0xc0) = *(type)(id + 0xc);\n          id = 4;\n          if(*(type)((type)id + 0x4c) != 0){\n            id = 8;\n          }\n          *(type)((type)id + 0xb8) = (type)id;\n          *(type)((type)id + 0x138) = *(type)(id + 0x12);\n          *(type)((type)id + 0x140) = *(type)(id + 0x14);\n          *(type)((type)id + 0x148) = id[3];\n          if(*(type)((type)id + 0x120) == 0){\n            *(type)((type)id + 0x120) = *(type)(id + 0x5e);\n          }\n          id = call(*(type)((type)id + 0x98));\n          *(type)((type)id + 0xa0) = id;\n          if(id == 0){\n            id = 3;\n          }else{\n            if(((*(type)((type)id + 0x120) != 0) && (*(type)((type)id + 0x128) != 0)) && (id = call(*(type)((type)id + 0x120), *(type)((type)id + 0x128))id != 0)){\n              id = call(*(type)((type)id + 0x128), *(type)((type)id + 0x120));\n              if(id == (type)0xffffffffffffffff){\n                id = 7;\n                goto lbl;\n              }\n              *(type)((type)id + 0x130) = id;\n            }\n            id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, *(type)((type)id + 0x130));\n            if(((id == 0) && (id = call(id, &id)id == 0)) && (id = call(id, id)id == 0)){\n              id = call(*(type)((type)id + 0x88), 0, id[5]);\n              if(id == -1){\n                id = 0xf;\n                if(*(type)((type)id + 0x30) != 0){\n                  call((type)((type)id + 0x5ce), 0x800, str, *(type)((type)id + 0x88));\n                  call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                }\n              }else{\n                id = call(id);\n                if((id == 0) && (id = call(id, 0)id == 0)){\n                  if((*(type)((type)id + 0x20) == 0) || (*(type)((type)id + 0x78) == *(type)((type)id + 0x80))){\n                    id = call(id);\n                  }else{\n                    id = 9;\n                    if(*(type)((type)id + 0x30) != 0){\n                      call((type)((type)id + 0x5ce), 0x800, str, (id) * (type)((type)id + 0x80), (id) * (type)((type)id + 0x78));\n                      call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[5]);\n  if((((id == 1) || (id == 2)) || (id == 0xf)) && (*(type)((type)id + 0x30) != 0)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id + 0x5ce), 0x800, str, id, (type)id, id, *id);\n    call((type)id + 0x5ce, id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = *(type)((type)id + 0x40);\n  id = id;\n  id = id;\n  id = id;\n  id = call(1, 0xdd0);\n  id = (type)call(1, 0x180);\n  call(id, id, 0x40);\n  *(type)((type)id + 0x120) = *(type)((type)id + 0x48);\n  *(type)((type)id + 0x128) = *(type)((type)id + 0x50);\n  *(type)((type)id + 0x58) = id;\n  *(type)((type)id + 0x60) = *(type)((type)id + 0x40);\n  *(type)((type)id + 0x80) = (type)*(type)((type)id + 0x58);\n  if(0 < *(type)((type)id + 0x60)){\n    *(type)((type)id + 0x84) = (type)*(type)((type)id + 0x60);\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n  }else{\n    id = call(0, 2, id[5]);\n    *(type)((type)id + 0x40) = id;\n    if(id == -1){\n      id = 0xf;\n      if(*(type)((type)id + 0x30) != 0){\n        call((type)((type)id + 0x5ce), 0x800, str);\n        call((type)id + 0x5ce, *(type)((type)id + 0x58));\n      }\n    }else{\n      id = call(0, 0, id[5]);\n      if(id == -1){\n        id = 0xf;\n        if(*(type)((type)id + 0x30) != 0){\n          call((type)((type)id + 0x5ce), 0x800, str);\n          call((type)id + 0x5ce, *(type)((type)id + 0x58));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id + 0x30), id);\n        if(id == 0){\n          *(type)((type)id + 0x4c) = id[1];\n          *(type)((type)id + 0x48) = *id;\n          *(type)((type)id + 0x50) = id[2];\n          id = call();\n          *(type)((type)id + 0x68) = id ^ *id;\n          *(type)((type)id + 0x88) = *(type)(id + 0x10);\n          *(type)((type)id + 0x90) = *(type)(id + 0xe);\n          *(type)((type)id + 0x98) = *(type)(id + 8);\n          *(type)((type)id + 0xb0) = *(type)(id + 10);\n          *(type)((type)id + 0xc0) = *(type)(id + 0xc);\n          id = 4;\n          if(*(type)((type)id + 0x4c) != 0){\n            id = 8;\n          }\n          *(type)((type)id + 0xb8) = (type)id;\n          *(type)((type)id + 0x138) = *(type)(id + 0x12);\n          *(type)((type)id + 0x140) = *(type)(id + 0x14);\n          *(type)((type)id + 0x148) = id[3];\n          if(*(type)((type)id + 0x120) == 0){\n            *(type)((type)id + 0x120) = *(type)(id + 0x5e);\n          }\n          id = call(*(type)((type)id + 0x98));\n          *(type)((type)id + 0xa0) = id;\n          if(id == 0){\n            id = 3;\n          }else{\n            if(((*(type)((type)id + 0x120) != 0) && (*(type)((type)id + 0x128) != 0)) && (id = call(*(type)((type)id + 0x120), *(type)((type)id + 0x128))id != 0)){\n              id = call(*(type)((type)id + 0x128), *(type)((type)id + 0x120));\n              if(id == (type)0xffffffffffffffff){\n                id = 7;\n                goto lbl;\n              }\n              *(type)((type)id + 0x130) = id;\n            }\n            id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, *(type)((type)id + 0x130));\n            if(((id == 0) && (id = call(id, &id)id == 0)) && (id = call(id, id)id == 0)){\n              id = call(*(type)((type)id + 0x88), 0, id[5]);\n              if(id == -1){\n                id = 0xf;\n                if(*(type)((type)id + 0x30) != 0){\n                  call((type)((type)id + 0x5ce), 0x800, str, *(type)((type)id + 0x88));\n                  call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                }\n              }else{\n                id = call(id);\n                if((id == 0) && (id = call(id, 0)id == 0)){\n                  if((*(type)((type)id + 0x20) == 0) || (*(type)((type)id + 0x78) == *(type)((type)id + 0x80))){\n                    id = call(id);\n                  }else{\n                    id = 9;\n                    if(*(type)((type)id + 0x30) != 0){\n                      call((type)((type)id + 0x5ce), 0x800, str, (id) * (type)((type)id + 0x80), (id) * (type)((type)id + 0x78));\n                      call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[5]);\n  if((((id == 1) || (id == 2)) || (id == 0xf)) && (*(type)((type)id + 0x30) != 0)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id + 0x5ce), 0x800, str, id, (type)id, id, *id);\n    call((type)id + 0x5ce, id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.75,
          "pr_ppl": 1.7421875,
          "source_ast_ppl": 1.984375,
          "base_ast_ppl": 1.8828125,
          "pr_ast_ppl": 1.8828125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces explicit type casting for the pointer returned by calloc, which is not necessary and can be considered noise. This change does not align with the Source Code structure and introduces no logical correction.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O2.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "function_pr": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = (undefined8 *)calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id = 0;\n  type id = id;\n  type *id = id->id;\n  type *id = call(1, (id));\n  type *id = call(1, (id));\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id > 0)id->id = id->id;\n  if(call(id, id->id) == -1){\n    id = id;\n    goto lbl;\n  }\n  if((id->id = call(0, id, id->id)) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if(call(0, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id, id, id->id.id, id)) != id){\n    goto lbl;\n  }\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = call() ^ id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = (id->id ? 8 : 4);\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id == null){\n    id->id = id->id;\n  }\n  if((id->id = call(id->id)) == null){\n    id = id;\n    goto lbl;\n  }\n  if(id->id && id->id && call(id->id, id->id) != 0){\n    type id = call(id->id, id->id);\n    if(id == (id) - 1){\n      id = id;\n      goto lbl;\n    }\n    id->id = id;\n  }\n  if((id = call(id->id, (id->id), id->id, (id->id), id->id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, &id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, id)) != id){\n    goto lbl;\n  }\n  if(call(id->id, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, 0)) != id){\n    goto lbl;\n  }\n  if(id->id.id && id->id != id->id){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  lbl:\n  call(id->id);\n  if(id == id || id == id || id == id){\n    if(id->id.id){\n      call(id->id, (id->id), str, call(id), id, call(id), id);\n      call(id->id, id);\n    }\n  }\n  if(id)call(id);\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type id){\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = (type)id[8];\n  id = call(1, 0xdd0);\n  id = call(1, 0x180);\n  id = id[1];\n  *id = *id;\n  id[1] = id;\n  id[2] = id[2];\n  id[3] = id[3];\n  id[4] = id[4];\n  id[5] = id[5];\n  id[6] = id[6];\n  id[7] = id[7];\n  id[0x24] = id[9];\n  id[0x25] = id[10];\n  id[0xb] = id;\n  id[0xc] = id;\n  *(type)(id + 0x10) = *(type)(id + 0xb);\n  if(0 < (type)id[0xc]){\n    *(type)((type)id + 0x84) = (type)id[0xc];\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n    lbl:\n    call(id[5]);\n    id = id[6];\n    lbl:\n    if(id != 0){\n      id = call(id);\n      id = call();\n      id = id;\n      id = call(*id);\n      call((type)((type)id + 0x5ce), 0x800, str, id, id, id, *id);\n      id = id;\n      call((type)((type)id + 0x5ce), id);\n    }\n  }else{\n    id = call(0, 2, id[5]);\n    id[8] = id;\n    if(id == -1){\n      id = 0xf;\n      if((type)id[6] != (type)0x0){\n        *(type)((type)id + 0x5ee) = 0x656c696620666f;\n        *(type)((type)id + 0x5e6) = 0x20646e65206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(0, 0, id[5]);\n    id = (type)id[6];\n    if(id == -1){\n      id = 0xf;\n      if(id != (type)0x0){\n        *(type)((type)id + 0x5f4) = 0x656c696620666f;\n        *(type)((type)id + 0x5ee) = 0x666f20676e696e6e;\n        *(type)((type)id + 0x5e6) = 0x69676562206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(id, id, id, id);\n    id = (type)id;\n    if(id == 0){\n      *(type)((type)id + 0x4c) = id[1];\n      *(type)(id + 9) = *id;\n      *(type)(id + 10) = id[2];\n      id = call();\n      *(type)(id + 0xd) = id ^ *id;\n      id[0x11] = *(type)(id + 0x10);\n      id[0x12] = *(type)(id + 0xe);\n      id[0x13] = *(type)(id + 8);\n      id[0x16] = *(type)(id + 10);\n      id[0x18] = *(type)(id + 0xc);\n      id[0x17] = call(*(type)((type)id + 0x4c) != 0) * 4 + 4;\n      id[0x27] = *(type)(id + 0x12);\n      id[0x28] = *(type)(id + 0x14);\n      *(type)(id + 0x29) = id[3];\n      if(id[0x24] == 0){\n        id[0x24] = *(type)(id + 0x5e);\n      }\n      id = call();\n      id[0x14] = id;\n      if(id == 0){\n        id = 3;\n        lbl:\n        call(id[5]);\n        call(id);\n        goto lbl;\n      }\n      id = (type)id[0x24];\n      if(((id != (type)0x0) && (id = (type)id[0x25]id != (type)0x0)) && (id = call(id, id)id != 0)){\n        id = call(id, id);\n        if(id == (type)0xffffffffffffffff){\n          id = 7;\n          goto lbl;\n        }\n        id[0x26] = id;\n      }\n      id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, id[0x26]);\n      id = (type)id;\n      if(id == 0){\n        id = call(id, &id);\n        id = (type)id;\n        if(id == 0){\n          id = call(id, id);\n          id = (type)id;\n          if(id == 0){\n            id = call(id[0x11], 0, id[5]);\n            if(id == -1){\n              id = 0xf;\n              if(id[6] != 0){\n                call((type)((type)id + 0x5ce), 0x800, str, id[0x11]);\n                id = 0xf;\n                call((type)((type)id + 0x5ce), id[0xb]);\n              }\n              goto lbl;\n            }\n            id = call(id);\n            id = (type)id;\n            if(id == 0){\n              id = call(id, 0);\n              id = (type)id;\n              if(id == 0){\n                if((id[4] != 0) && (*(type)(id + 0xf) != *(type)(id + 0x10))){\n                  id = 9;\n                  if(id[6] != 0){\n                    call((type)((type)id + 0x5ce), 0x800, str);\n                    call((type)((type)id + 0x5ce), id[0xb]);\n                  }\n                  goto lbl;\n                }\n                id = call(id);\n                id = (type)id;\n              }\n            }\n          }\n        }\n      }\n    }\n    call(id[5]);\n    if(((type)id < 0x10) && ((0x8006U >> ((type)id & 0x1f) & 1) != 0)){\n      id = id[6];\n      goto lbl;\n    }\n  }\n  call(id);\n  if(id == (type)0x0){\n    return id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type id){\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = (type)id[8];\n  id = (type)call(1, 0xdd0);\n  id = (type)call(1, 0x180);\n  id = id[1];\n  *id = *id;\n  id[1] = id;\n  id[2] = id[2];\n  id[3] = id[3];\n  id[4] = id[4];\n  id[5] = id[5];\n  id[6] = id[6];\n  id[7] = id[7];\n  id[0x24] = id[9];\n  id[0x25] = id[10];\n  id[0xb] = id;\n  id[0xc] = id;\n  *(type)(id + 0x10) = *(type)(id + 0xb);\n  if(0 < (type)id[0xc]){\n    *(type)((type)id + 0x84) = (type)id[0xc];\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n    lbl:\n    call(id[5]);\n    id = id[6];\n    lbl:\n    if(id != 0){\n      id = call(id);\n      id = call();\n      id = id;\n      id = call(*id);\n      call((type)((type)id + 0x5ce), 0x800, str, id, id, id, *id);\n      id = id;\n      call((type)((type)id + 0x5ce), id);\n    }\n  }else{\n    id = call(0, 2, id[5]);\n    id[8] = id;\n    if(id == -1){\n      id = 0xf;\n      if((type)id[6] != (type)0x0){\n        *(type)((type)id + 0x5ee) = 0x656c696620666f;\n        *(type)((type)id + 0x5e6) = 0x20646e65206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(0, 0, id[5]);\n    id = (type)id[6];\n    if(id == -1){\n      id = 0xf;\n      if(id != (type)0x0){\n        *(type)((type)id + 0x5f4) = 0x656c696620666f;\n        *(type)((type)id + 0x5ee) = 0x666f20676e696e6e;\n        *(type)((type)id + 0x5e6) = 0x69676562206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(id, id, id, id);\n    id = (type)id;\n    if(id == 0){\n      *(type)((type)id + 0x4c) = id[1];\n      *(type)(id + 9) = *id;\n      *(type)(id + 10) = id[2];\n      id = call();\n      *(type)(id + 0xd) = id ^ *id;\n      id[0x11] = *(type)(id + 0x10);\n      id[0x12] = *(type)(id + 0xe);\n      id[0x13] = *(type)(id + 8);\n      id[0x16] = *(type)(id + 10);\n      id[0x18] = *(type)(id + 0xc);\n      id[0x17] = call(*(type)((type)id + 0x4c) != 0) * 4 + 4;\n      id[0x27] = *(type)(id + 0x12);\n      id[0x28] = *(type)(id + 0x14);\n      *(type)(id + 0x29) = id[3];\n      if(id[0x24] == 0){\n        id[0x24] = *(type)(id + 0x5e);\n      }\n      id = call();\n      id[0x14] = id;\n      if(id == 0){\n        id = 3;\n        lbl:\n        call(id[5]);\n        call(id);\n        goto lbl;\n      }\n      id = (type)id[0x24];\n      if(((id != (type)0x0) && (id = (type)id[0x25]id != (type)0x0)) && (id = call(id, id)id != 0)){\n        id = call(id, id);\n        if(id == (type)0xffffffffffffffff){\n          id = 7;\n          goto lbl;\n        }\n        id[0x26] = id;\n      }\n      id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, id[0x26]);\n      id = (type)id;\n      if(id == 0){\n        id = call(id, &id);\n        id = (type)id;\n        if(id == 0){\n          id = call(id, id);\n          id = (type)id;\n          if(id == 0){\n            id = call(id[0x11], 0, id[5]);\n            if(id == -1){\n              id = 0xf;\n              if(id[6] != 0){\n                call((type)((type)id + 0x5ce), 0x800, str, id[0x11]);\n                id = 0xf;\n                call((type)((type)id + 0x5ce), id[0xb]);\n              }\n              goto lbl;\n            }\n            id = call(id);\n            id = (type)id;\n            if(id == 0){\n              id = call(id, 0);\n              id = (type)id;\n              if(id == 0){\n                if((id[4] != 0) && (*(type)(id + 0xf) != *(type)(id + 0x10))){\n                  id = 9;\n                  if(id[6] != 0){\n                    call((type)((type)id + 0x5ce), 0x800, str);\n                    call((type)((type)id + 0x5ce), id[0xb]);\n                  }\n                  goto lbl;\n                }\n                id = call(id);\n                id = (type)id;\n              }\n            }\n          }\n        }\n      }\n    }\n    call(id[5]);\n    if(((type)id < 0x10) && ((0x8006U >> ((type)id & 0x1f) & 1) != 0)){\n      id = id[6];\n      goto lbl;\n    }\n  }\n  call(id);\n  if(id == (type)0x0){\n    return id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.84375,
          "pr_ppl": 1.8359375,
          "source_ast_ppl": 1.984375,
          "base_ast_ppl": 2.234375,
          "pr_ast_ppl": 2.234375,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns more closely with the Source Code structure by correctly casting the result of calloc to the appropriate pointer types.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O3.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "function_pr": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = (undefined8 *)calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id = 0;\n  type id = id;\n  type *id = id->id;\n  type *id = call(1, (id));\n  type *id = call(1, (id));\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id > 0)id->id = id->id;\n  if(call(id, id->id) == -1){\n    id = id;\n    goto lbl;\n  }\n  if((id->id = call(0, id, id->id)) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if(call(0, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id, id, id->id.id, id)) != id){\n    goto lbl;\n  }\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = call() ^ id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = (id->id ? 8 : 4);\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id == null){\n    id->id = id->id;\n  }\n  if((id->id = call(id->id)) == null){\n    id = id;\n    goto lbl;\n  }\n  if(id->id && id->id && call(id->id, id->id) != 0){\n    type id = call(id->id, id->id);\n    if(id == (id) - 1){\n      id = id;\n      goto lbl;\n    }\n    id->id = id;\n  }\n  if((id = call(id->id, (id->id), id->id, (id->id), id->id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, &id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, id)) != id){\n    goto lbl;\n  }\n  if(call(id->id, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, 0)) != id){\n    goto lbl;\n  }\n  if(id->id.id && id->id != id->id){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  lbl:\n  call(id->id);\n  if(id == id || id == id || id == id){\n    if(id->id.id){\n      call(id->id, (id->id), str, call(id), id, call(id), id);\n      call(id->id, id);\n    }\n  }\n  if(id)call(id);\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type id){\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = (type)id[8];\n  id = call(1, 0xdd0);\n  id = call(1, 0x180);\n  id = id[1];\n  *id = *id;\n  id[1] = id;\n  id[2] = id[2];\n  id[3] = id[3];\n  id[4] = id[4];\n  id[5] = id[5];\n  id[6] = id[6];\n  id[7] = id[7];\n  id[0x24] = id[9];\n  id[0x25] = id[10];\n  id[0xb] = id;\n  id[0xc] = id;\n  *(type)(id + 0x10) = *(type)(id + 0xb);\n  if(0 < (type)id[0xc]){\n    *(type)((type)id + 0x84) = (type)id[0xc];\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n    lbl:\n    call(id[5]);\n    id = id[6];\n    lbl:\n    if(id != 0){\n      id = call(id);\n      id = call();\n      id = id;\n      id = call(*id);\n      call((type)((type)id + 0x5ce), 0x800, str, id, id, id, *id);\n      id = id;\n      call((type)((type)id + 0x5ce), id);\n    }\n  }else{\n    id = call(0, 2, id[5]);\n    id[8] = id;\n    if(id == -1){\n      id = 0xf;\n      if((type)id[6] != (type)0x0){\n        *(type)((type)id + 0x5ee) = 0x656c696620666f;\n        *(type)((type)id + 0x5e6) = 0x20646e65206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(0, 0, id[5]);\n    id = (type)id[6];\n    if(id == -1){\n      id = 0xf;\n      if(id != (type)0x0){\n        *(type)((type)id + 0x5f4) = 0x656c696620666f;\n        *(type)((type)id + 0x5ee) = 0x666f20676e696e6e;\n        *(type)((type)id + 0x5e6) = 0x69676562206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(id, id, id, id);\n    id = (type)id;\n    if(id == 0){\n      *(type)((type)id + 0x4c) = id[1];\n      *(type)(id + 9) = *id;\n      *(type)(id + 10) = id[2];\n      id = call();\n      *(type)(id + 0xd) = id ^ *id;\n      id[0x11] = *(type)(id + 0x10);\n      id[0x12] = *(type)(id + 0xe);\n      id[0x13] = *(type)(id + 8);\n      id[0x16] = *(type)(id + 10);\n      id[0x18] = *(type)(id + 0xc);\n      id[0x17] = call(*(type)((type)id + 0x4c) != 0) * 4 + 4;\n      id[0x27] = *(type)(id + 0x12);\n      id[0x28] = *(type)(id + 0x14);\n      *(type)(id + 0x29) = id[3];\n      if(id[0x24] == 0){\n        id[0x24] = *(type)(id + 0x5e);\n      }\n      id = call();\n      id[0x14] = id;\n      if(id == 0){\n        id = 3;\n        lbl:\n        call(id[5]);\n        call(id);\n        goto lbl;\n      }\n      id = (type)id[0x24];\n      if(((id != (type)0x0) && (id = (type)id[0x25]id != (type)0x0)) && (id = call(id, id)id != 0)){\n        id = call(id, id);\n        if(id == (type)0xffffffffffffffff){\n          id = 7;\n          goto lbl;\n        }\n        id[0x26] = id;\n      }\n      id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, id[0x26]);\n      id = (type)id;\n      if(id == 0){\n        id = call(id, &id);\n        id = (type)id;\n        if(id == 0){\n          id = call(id, id);\n          id = (type)id;\n          if(id == 0){\n            id = call(id[0x11], 0, id[5]);\n            if(id == -1){\n              id = 0xf;\n              if(id[6] != 0){\n                call((type)((type)id + 0x5ce), 0x800, str, id[0x11]);\n                id = 0xf;\n                call((type)((type)id + 0x5ce), id[0xb]);\n              }\n              goto lbl;\n            }\n            id = call(id);\n            id = (type)id;\n            if(id == 0){\n              id = call(id, 0);\n              id = (type)id;\n              if(id == 0){\n                if((id[4] != 0) && (*(type)(id + 0xf) != *(type)(id + 0x10))){\n                  id = 9;\n                  if(id[6] != 0){\n                    call((type)((type)id + 0x5ce), 0x800, str);\n                    call((type)((type)id + 0x5ce), id[0xb]);\n                  }\n                  goto lbl;\n                }\n                id = call(id);\n                id = (type)id;\n              }\n            }\n          }\n        }\n      }\n    }\n    call(id[5]);\n    if(((type)id < 0x10) && ((0x8006U >> ((type)id & 0x1f) & 1) != 0)){\n      id = id[6];\n      goto lbl;\n    }\n  }\n  call(id);\n  if(id == (type)0x0){\n    return id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type id){\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = (type)id[8];\n  id = (type)call(1, 0xdd0);\n  id = (type)call(1, 0x180);\n  id = id[1];\n  *id = *id;\n  id[1] = id;\n  id[2] = id[2];\n  id[3] = id[3];\n  id[4] = id[4];\n  id[5] = id[5];\n  id[6] = id[6];\n  id[7] = id[7];\n  id[0x24] = id[9];\n  id[0x25] = id[10];\n  id[0xb] = id;\n  id[0xc] = id;\n  *(type)(id + 0x10) = *(type)(id + 0xb);\n  if(0 < (type)id[0xc]){\n    *(type)((type)id + 0x84) = (type)id[0xc];\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n    lbl:\n    call(id[5]);\n    id = id[6];\n    lbl:\n    if(id != 0){\n      id = call(id);\n      id = call();\n      id = id;\n      id = call(*id);\n      call((type)((type)id + 0x5ce), 0x800, str, id, id, id, *id);\n      id = id;\n      call((type)((type)id + 0x5ce), id);\n    }\n  }else{\n    id = call(0, 2, id[5]);\n    id[8] = id;\n    if(id == -1){\n      id = 0xf;\n      if((type)id[6] != (type)0x0){\n        *(type)((type)id + 0x5ee) = 0x656c696620666f;\n        *(type)((type)id + 0x5e6) = 0x20646e65206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(0, 0, id[5]);\n    id = (type)id[6];\n    if(id == -1){\n      id = 0xf;\n      if(id != (type)0x0){\n        *(type)((type)id + 0x5f4) = 0x656c696620666f;\n        *(type)((type)id + 0x5ee) = 0x666f20676e696e6e;\n        *(type)((type)id + 0x5e6) = 0x69676562206f7420;\n        *(type)((type)id + 0x5de) = 0x6b656573206f7420;\n        *(type)((type)id + 0x5d6) = 0x64656c696146203a;\n        *(type)((type)id + 0x5ce) = 0x7461745364616552;\n        call((type)id + 0x5ce, id[0xb]);\n      }\n      goto lbl;\n    }\n    id = call(id, id, id, id);\n    id = (type)id;\n    if(id == 0){\n      *(type)((type)id + 0x4c) = id[1];\n      *(type)(id + 9) = *id;\n      *(type)(id + 10) = id[2];\n      id = call();\n      *(type)(id + 0xd) = id ^ *id;\n      id[0x11] = *(type)(id + 0x10);\n      id[0x12] = *(type)(id + 0xe);\n      id[0x13] = *(type)(id + 8);\n      id[0x16] = *(type)(id + 10);\n      id[0x18] = *(type)(id + 0xc);\n      id[0x17] = call(*(type)((type)id + 0x4c) != 0) * 4 + 4;\n      id[0x27] = *(type)(id + 0x12);\n      id[0x28] = *(type)(id + 0x14);\n      *(type)(id + 0x29) = id[3];\n      if(id[0x24] == 0){\n        id[0x24] = *(type)(id + 0x5e);\n      }\n      id = call();\n      id[0x14] = id;\n      if(id == 0){\n        id = 3;\n        lbl:\n        call(id[5]);\n        call(id);\n        goto lbl;\n      }\n      id = (type)id[0x24];\n      if(((id != (type)0x0) && (id = (type)id[0x25]id != (type)0x0)) && (id = call(id, id)id != 0)){\n        id = call(id, id);\n        if(id == (type)0xffffffffffffffff){\n          id = 7;\n          goto lbl;\n        }\n        id[0x26] = id;\n      }\n      id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, id[0x26]);\n      id = (type)id;\n      if(id == 0){\n        id = call(id, &id);\n        id = (type)id;\n        if(id == 0){\n          id = call(id, id);\n          id = (type)id;\n          if(id == 0){\n            id = call(id[0x11], 0, id[5]);\n            if(id == -1){\n              id = 0xf;\n              if(id[6] != 0){\n                call((type)((type)id + 0x5ce), 0x800, str, id[0x11]);\n                id = 0xf;\n                call((type)((type)id + 0x5ce), id[0xb]);\n              }\n              goto lbl;\n            }\n            id = call(id);\n            id = (type)id;\n            if(id == 0){\n              id = call(id, 0);\n              id = (type)id;\n              if(id == 0){\n                if((id[4] != 0) && (*(type)(id + 0xf) != *(type)(id + 0x10))){\n                  id = 9;\n                  if(id[6] != 0){\n                    call((type)((type)id + 0x5ce), 0x800, str);\n                    call((type)((type)id + 0x5ce), id[0xb]);\n                  }\n                  goto lbl;\n                }\n                id = call(id);\n                id = (type)id;\n              }\n            }\n          }\n        }\n      }\n    }\n    call(id[5]);\n    if(((type)id < 0x10) && ((0x8006U >> ((type)id & 0x1f) & 1) != 0)){\n      id = id[6];\n      goto lbl;\n    }\n  }\n  call(id);\n  if(id == (type)0x0){\n    return id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.84375,
          "pr_ppl": 1.8359375,
          "source_ast_ppl": 1.984375,
          "base_ast_ppl": 2.234375,
          "pr_ast_ppl": 2.234375,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns better with the Source Code structure by correctly casting the result of calloc to the appropriate types (undefined8* and uint*). This maintains type safety and correctness.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_zmagic-O0.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined4 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  int iVar3;\n  _union_1457 local_1b8 [19];\n  uint local_11c;\n  _union_1457 local_118 [19];\n  uint local_7c;\n  ulong local_78;\n  void *local_70;\n  undefined4 local_64;\n  uint local_60;\n  undefined4 local_5c;\n  int local_58;\n  int local_54;\n  long local_50;\n  void *local_48;\n  ulong local_40;\n  ulong local_38;\n  void *local_30;\n  undefined8 local_28;\n  undefined4 *local_20;\n  long local_18;\n  undefined4 local_c;\n  \n  local_30 = (void *)0x0;\n  local_5c = 0;\n  local_60 = *(uint *)(param_1 + 0x44) & 0x410;\n  local_64 = *param_2;\n  local_70 = *(void **)(param_2 + 0x26);\n  local_78 = *(ulong *)(param_2 + 0x28);\n  local_7c = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) == 0) {\n    local_c = 0;\n  }\n  else {\n    local_28 = param_3;\n    local_20 = param_2;\n    local_18 = param_1;\n    for (local_38 = 0; local_38 < ncompr; local_38 = local_38 + 1) {\n      iVar3 = -*(int *)(compr + local_38 * 0x20 + 8);\n      iVar1 = *(int *)(compr + local_38 * 0x20 + 8);\n      if (-1 < iVar3) {\n        iVar1 = iVar3;\n      }\n      if ((ulong)(long)iVar1 <= local_78) {\n        if (*(int *)(compr + local_38 * 0x20 + 8) < 0) {\n          local_11c = (**(code **)(compr + local_38 * 0x20))(local_70);\n        }\n        else {\n          iVar1 = memcmp(local_70,*(void **)(compr + local_38 * 0x20),\n                         (long)*(int *)(compr + local_38 * 0x20 + 8));\n          local_11c = (uint)(iVar1 == 0);\n        }\n        if (local_11c != 0) {\n          if (local_7c == 0) {\n            memset(local_1b8,0,0x98);\n            local_1b8[0] = (_union_1457)0x1;\n            iVar1 = sigaction(0xd,(sigaction *)local_1b8,(sigaction *)local_118);\n            local_7c = (uint)(iVar1 != -1);\n          }\n          local_40 = local_78;\n          free(local_30);\n          local_54 = uncompressbuf(local_64,*(undefined8 *)(local_18 + 0x120),local_38,\n                                   *(uint *)(local_18 + 0x44) & 0x4000000,local_70,&local_30,\n                                   &local_40);\n          if (local_54 != 0) {\n            if (local_54 == 1) goto LAB_00102adf;\n            if (local_54 != 2) {\n                    /* WARNING: Subroutine does not return */\n              abort();\n            }\n          }\n          *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) & 0xfffffffb;\n          if (local_54 == 2) {\n            local_58 = format_decompression_error(local_18,local_38,local_30);\n          }\n          else {\n            local_58 = file_buffer(local_18,0xffffffff,0,local_28,local_30,local_40);\n          }\n          if (local_58 != -1) {\n            local_5c = 1;\n            if (((*(uint *)(local_18 + 0x44) & 0x2000000) != 0) ||\n               ((local_60 != 0x410 && (local_60 != 0)))) break;\n            iVar1 = file_printf(local_18);\n            if ((iVar1 != -1) && (local_50 = file_push_buffer(local_18), local_50 != 0)) {\n              iVar1 = file_buffer(local_18,0xffffffff,0,0,local_70,local_78);\n              if (iVar1 == -1) {\n                lVar2 = file_pop_buffer(local_18);\n                if (lVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n                  abort();\n                }\n              }\n              else {\n                local_48 = (void *)file_pop_buffer(local_18);\n                if (local_48 != (void *)0x0) {\n                  iVar1 = file_printf(local_18,\"%s\",local_48);\n                  if (iVar1 == -1) {\n                    free(local_48);\n                    goto LAB_00102ad3;\n                  }\n                  free(local_48);\n                }\n                if ((local_60 != 0) || (iVar1 = file_printf(local_18), iVar1 != -1))\n                goto LAB_00102adf;\n              }\n            }\n          }\nLAB_00102ad3:\n          local_5c = 0xffffffff;\n        }\n      }\nLAB_00102adf:\n    }\n    if ((local_7c != 0) && (local_118[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_118,(sigaction *)0x0);\n    }\n    free(local_30);\n    *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) | 4;\n    local_c = local_5c;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nundefined4 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  _union_1457 local_1b8 [19];\n  uint local_11c;\n  _union_1457 local_118 [19];\n  uint local_7c;\n  ulong local_78;\n  void *local_70;\n  undefined4 local_64;\n  uint local_60;\n  undefined4 local_5c;\n  int local_58;\n  int local_54;\n  long local_50;\n  void *local_48;\n  ulong local_40;\n  ulong local_38;\n  void *local_30;\n  undefined8 local_28;\n  undefined4 *local_20;\n  long local_18;\n  undefined4 local_c;\n  \n  local_30 = (void *)0x0;\n  local_5c = 0;\n  local_60 = *(uint *)(param_1 + 0x44) & 0x410;\n  local_64 = *param_2;\n  local_70 = *(void **)(param_2 + 0x26);\n  local_78 = *(ulong *)(param_2 + 0x28);\n  local_7c = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) == 0) {\n    local_c = 0;\n  }\n  else {\n    local_28 = param_3;\n    local_20 = param_2;\n    local_18 = param_1;\n    for (local_38 = 0; local_38 < ncompr; local_38 = local_38 + 1) {\n      iVar1 = *(int *)(compr + local_38 * 0x20 + 8);\n      if (iVar1 < 1) {\n        iVar1 = -iVar1;\n      }\n      if ((ulong)(long)iVar1 <= local_78) {\n        if (*(int *)(compr + local_38 * 0x20 + 8) < 0) {\n          local_11c = (**(code **)(compr + local_38 * 0x20))(local_70);\n        }\n        else {\n          iVar1 = memcmp(local_70,*(void **)(compr + local_38 * 0x20),\n                         (long)*(int *)(compr + local_38 * 0x20 + 8));\n          local_11c = (uint)(iVar1 == 0);\n        }\n        if (local_11c != 0) {\n          if (local_7c == 0) {\n            memset(local_1b8,0,0x98);\n            local_1b8[0] = (_union_1457)0x1;\n            iVar1 = sigaction(0xd,(sigaction *)local_1b8,(sigaction *)local_118);\n            local_7c = (uint)(iVar1 != -1);\n          }\n          local_40 = local_78;\n          free(local_30);\n          local_54 = uncompressbuf(local_64,*(undefined8 *)(local_18 + 0x120),local_38,\n                                   *(uint *)(local_18 + 0x44) & 0x4000000,local_70,&local_30,\n                                   &local_40);\n          if (local_54 != 0) {\n            if (local_54 == 1) goto LAB_00102adf;\n            if (local_54 != 2) {\n                    /* WARNING: Subroutine does not return */\n              abort();\n            }\n          }\n          *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) & 0xfffffffb;\n          if (local_54 == 2) {\n            local_58 = format_decompression_error(local_18,local_38,local_30);\n          }\n          else {\n            local_58 = file_buffer(local_18,0xffffffff,0,local_28,local_30,local_40);\n          }\n          if (local_58 != -1) {\n            local_5c = 1;\n            if (((*(uint *)(local_18 + 0x44) & 0x2000000) != 0) ||\n               ((local_60 != 0x410 && (local_60 != 0)))) break;\n            iVar1 = file_printf(local_18);\n            if ((iVar1 != -1) && (local_50 = file_push_buffer(local_18), local_50 != 0)) {\n              iVar1 = file_buffer(local_18,0xffffffff,0,0,local_70,local_78);\n              if (iVar1 == -1) {\n                lVar2 = file_pop_buffer(local_18);\n                if (lVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n                  abort();\n                }\n              }\n              else {\n                local_48 = (void *)file_pop_buffer(local_18);\n                if (local_48 != (void *)0x0) {\n                  iVar1 = file_printf(local_18,\"%s\",local_48);\n                  if (iVar1 == -1) {\n                    free(local_48);\n                    goto LAB_00102ad3;\n                  }\n                  free(local_48);\n                }\n                if ((local_60 != 0) || (iVar1 = file_printf(local_18), iVar1 != -1))\n                goto LAB_00102adf;\n              }\n            }\n          }\nLAB_00102ad3:\n          local_5c = 0xffffffff;\n        }\n      }\nLAB_00102adf:\n    }\n    if ((local_7c != 0) && (local_118[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_118,(sigaction *)0x0);\n    }\n    free(local_30);\n    *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) | 4;\n    local_c = local_5c;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type *id = null;\n  type id, id;\n  type *id;\n  type *id;\n  type id, id, id = 0;\n  type id = id->id & id;\n  type id = id->id;\n  type *id = call(id unsigned char id->id);\n  type id = id->id;\n  type id = 0;\n  type id;\n  if((id->id & id) == 0)return 0;\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, -1, null, id, id, id);\n        if(id == -1)goto lbl;\n        id = 1;\n        if((id->id & id) != 0)goto lbl;\n        if(id != id && id != 0)goto lbl;\n        if((call(id, (id ? str : str))) == -1)goto lbl;\n        if((id = call(id)) == null)goto lbl;\n        if(call(id, -1, null, null, id, id) == -1){\n          if(call(id, id) != null)call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != null){\n          if(call(id, str, id) == -1){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, str) == -1)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = -1;\n        break;\n    }\n  }\n  lbl:\n  call(str, id);\n  if(id && id.id != id)(type)call(id, &id, null);\n  call(id);\n  id->id = id;\n  call(str, id);\n  return id;\n}",
        "base_ast": "type id( id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type id[19];\n  type id;\n  type id[19];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  id = (type)0x0;\n  id = 0;\n  id = *(type)(id + 0x44) & 0x410;\n  id = *id;\n  id = *(type)(id + 0x26);\n  id = *(type)(id + 0x28);\n  id = 0;\n  if((*(type)(id + 0x44) & 4) == 0){\n    id = 0;\n  }else{\n    id = id;\n    id = id;\n    id = id;\n    for(id = 0;  id < id; id = id + 1){\n      id = -*(type)(id + id * 0x20 + 8);\n      id = *(type)(id + id * 0x20 + 8);\n      if(-1 < id){\n        id = id;\n      }\n      if((type)(type)id <= id){\n        if(*(type)(id + id * 0x20 + 8) < 0){\n          id = call(id);\n        }else{\n          id = call(id, *(type)(id + id * 0x20), (type)*(type)(id + id * 0x20 + 8));\n          id = call(id == 0);\n        }\n        if(id != 0){\n          if(id == 0){\n            call(id, 0, 0x98);\n            id[0] = (type)0x1;\n            id = call(0xd, (type)id, (type)id);\n            id = call(id != -1);\n          }\n          id = id;\n          call(id);\n          id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n          if(id != 0){\n            if(id == 1)goto lbl;\n            if(id != 2){\n              call();\n            }\n          }\n          *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfffffffb;\n          if(id == 2){\n            id = call(id, id, id);\n          }else{\n            id = call(id, 0xffffffff, 0, id, id, id);\n          }\n          if(id != -1){\n            id = 1;\n            if(((*(type)(id + 0x44) & 0x2000000) != 0) || ((id != 0x410 && (id != 0))))break;\n            id = call(id);\n            if((id != -1) && (id = call(id)id != 0)){\n              id = call(id, 0xffffffff, 0, 0, id, id);\n              if(id == -1){\n                id = call(id);\n                if(id != 0){\n                  call();\n                }\n              }else{\n                id = (type)call(id);\n                if(id != (type)0x0){\n                  id = call(id, str, id);\n                  if(id == -1){\n                    call(id);\n                    goto lbl;\n                  }\n                  call(id);\n                }\n                if((id != 0) || (id = call(id)id != -1))goto lbl;\n              }\n            }\n          }\n          lbl:\n          id = 0xffffffff;\n        }\n      }\n      lbl:\n      ;\n    }\n    if((id != 0) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n    id = id;\n  }\n  return id;\n}",
        "pr_ast": "type id( id, type *id, type id){\n  type id;\n  type id;\n  type id[19];\n  type id;\n  type id[19];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  id = (type)0x0;\n  id = 0;\n  id = *(type)(id + 0x44) & 0x410;\n  id = *id;\n  id = *(type)(id + 0x26);\n  id = *(type)(id + 0x28);\n  id = 0;\n  if((*(type)(id + 0x44) & 4) == 0){\n    id = 0;\n  }else{\n    id = id;\n    id = id;\n    id = id;\n    for(id = 0;  id < id; id = id + 1){\n      id = *(type)(id + id * 0x20 + 8);\n      if(id < 1){\n        id = -id;\n      }\n      if((type)(type)id <= id){\n        if(*(type)(id + id * 0x20 + 8) < 0){\n          id = call(id);\n        }else{\n          id = call(id, *(type)(id + id * 0x20), (type)*(type)(id + id * 0x20 + 8));\n          id = call(id == 0);\n        }\n        if(id != 0){\n          if(id == 0){\n            call(id, 0, 0x98);\n            id[0] = (type)0x1;\n            id = call(0xd, (type)id, (type)id);\n            id = call(id != -1);\n          }\n          id = id;\n          call(id);\n          id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n          if(id != 0){\n            if(id == 1)goto lbl;\n            if(id != 2){\n              call();\n            }\n          }\n          *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfffffffb;\n          if(id == 2){\n            id = call(id, id, id);\n          }else{\n            id = call(id, 0xffffffff, 0, id, id, id);\n          }\n          if(id != -1){\n            id = 1;\n            if(((*(type)(id + 0x44) & 0x2000000) != 0) || ((id != 0x410 && (id != 0))))break;\n            id = call(id);\n            if((id != -1) && (id = call(id)id != 0)){\n              id = call(id, 0xffffffff, 0, 0, id, id);\n              if(id == -1){\n                id = call(id);\n                if(id != 0){\n                  call();\n                }\n              }else{\n                id = (type)call(id);\n                if(id != (type)0x0){\n                  id = call(id, str, id);\n                  if(id == -1){\n                    call(id);\n                    goto lbl;\n                  }\n                  call(id);\n                }\n                if((id != 0) || (id = call(id)id != -1))goto lbl;\n              }\n            }\n          }\n          lbl:\n          id = 0xffffffff;\n        }\n      }\n      lbl:\n      ;\n    }\n    if((id != 0) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n    id = id;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.203125,
          "base_ppl": 1.96875,
          "pr_ppl": 1.953125,
          "source_ast_ppl": 3.890625,
          "base_ast_ppl": 2.609375,
          "pr_ast_ppl": 2.609375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_checkfmt-O2.so",
        "function": "file_checkfmt",
        "source_code": "file_protected int\nfile_checkfmt(char *msg, size_t mlen, const char *fmt)\n{\n\tconst char *p;\n\tfor (p = fmt; *p; p++) {\n\t\tif (*p != '%')\n\t\t\tcontinue;\n\t\tif (*++p == '%')\n\t\t\tcontinue;\n\t\tif (*p == '\\0') {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"incomplete %% format\");\n\t\t\treturn -1;\n\t\t}\n\t\t// Skip uninteresting.\n\t\twhile (*p != '\\0' && strchr(\"#0.'+- \", *p) != NULL)\n\t\t\tp++;\n\t\tif (*p == '*') {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"* not allowed in format\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!file_checkfield(msg, mlen, \"width\", &p))\n\t\t\treturn -1;\n\n\t\tif (*p == '.') {\n\t\t\tp++;\n\t\t\tif (!file_checkfield(msg, mlen, \"precision\", &p))\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (!isalpha((unsigned char)*p)) {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"bad format char: %c\", *p);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "function_base": "\nundefined8 file_checkfmt(char *param_1,size_t param_2,byte *param_3)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  char *__format;\n  byte bVar3;\n  byte *local_38;\n  \n  do {\n    for (; *param_3 != 0x25; param_3 = param_3 + 1) {\n      if (*param_3 == 0) {\n        return 0;\n      }\nLAB_0010122d:\n    }\n    local_38 = param_3 + 1;\n    bVar3 = param_3[1];\n    if (bVar3 != 0x25) {\n      if (bVar3 == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        __format = \"incomplete %% format\";\nLAB_00101278:\n        snprintf(param_1,param_2,__format);\n        return 0xffffffff;\n      }\n      do {\n        if ((0x3f < bVar3) || ((1L << (bVar3 & 0x3f) & 0x1688900000001U) == 0)) {\n          if (bVar3 == 0x2a) {\n            if (param_1 == (char *)0x0) {\n              return 0xffffffff;\n            }\n            __format = \"* not allowed in format\";\n            goto LAB_00101278;\n          }\n          break;\n        }\n        bVar3 = local_38[1];\n        local_38 = local_38 + 1;\n      } while (bVar3 != 0);\n      iVar1 = file_checkfield(param_1,param_2,\"width\",&local_38);\n      if (iVar1 == 0) {\n        return 0xffffffff;\n      }\n      bVar3 = *local_38;\n      if (bVar3 == 0x2e) {\n        local_38 = local_38 + 1;\n        iVar1 = file_checkfield(param_1,param_2,\"precision\",&local_38);\n        if (iVar1 == 0) {\n          return 0xffffffff;\n        }\n        bVar3 = *local_38;\n      }\n      param_3 = local_38;\n      ppuVar2 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar2 + (ulong)bVar3 * 2 + 1) & 4) == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        snprintf(param_1,param_2,\"bad format char: %c\",(ulong)(uint)(int)(char)bVar3);\n        return 0xffffffff;\n      }\n      goto LAB_0010122d;\n    }\n    param_3 = param_3 + 2;\n  } while( true );\n}\n\n",
        "function_pr": "\nulong file_checkfmt(char *param_1,size_t param_2,byte *param_3)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  char *__format;\n  byte bVar3;\n  byte *local_38;\n  \n  do {\n    while( true ) {\n      bVar3 = *param_3;\n      if (bVar3 == 0x25) break;\n      if (bVar3 == 0) {\n        return (ulong)bVar3;\n      }\nLAB_0010122d:\n      param_3 = param_3 + 1;\n    }\n    local_38 = param_3 + 1;\n    bVar3 = param_3[1];\n    if (bVar3 != 0x25) {\n      if (bVar3 == 0) {\n        if (param_1 != (char *)0x0) {\n          __format = \"incomplete %% format\";\nLAB_00101278:\n          snprintf(param_1,param_2,__format);\n        }\n        return 0xffffffff;\n      }\n      do {\n        if ((0x3f < bVar3) || ((1L << (bVar3 & 0x3f) & 0x1688900000001U) == 0)) {\n          if (bVar3 == 0x2a) {\n            if (param_1 == (char *)0x0) {\n              return 0xffffffff;\n            }\n            __format = \"* not allowed in format\";\n            goto LAB_00101278;\n          }\n          break;\n        }\n        bVar3 = local_38[1];\n        local_38 = local_38 + 1;\n      } while (bVar3 != 0);\n      iVar1 = file_checkfield(param_1,param_2,\"width\",&local_38);\n      if (iVar1 == 0) {\n        return 0xffffffff;\n      }\n      bVar3 = *local_38;\n      if (bVar3 == 0x2e) {\n        local_38 = local_38 + 1;\n        iVar1 = file_checkfield(param_1,param_2,\"precision\",&local_38);\n        if (iVar1 == 0) {\n          return 0xffffffff;\n        }\n        bVar3 = *local_38;\n      }\n      param_3 = local_38;\n      ppuVar2 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar2 + (ulong)bVar3 * 2 + 1) & 4) == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        snprintf(param_1,param_2,\"bad format char: %c\",(ulong)(uint)(int)(char)bVar3);\n        return 0xffffffff;\n      }\n      goto LAB_0010122d;\n    }\n    param_3 = param_3 + 2;\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id;\n  for(id = id;  *id; id++){\n    if(*id != str)continue;\n    if(*++id == str)continue;\n    if(*id == str){\n      if(id)call(id, id, str);\n      return -1;\n    }\n    while(*id != str && call(str, *id) != null)id++;\n    if(*id == str){\n      if(id)call(id, id, str);\n      return -1;\n    }\n    if(!call(id, id, str, &id))return -1;\n    if(*id == str){\n      id++;\n      if(!call(id, id, str, &id))return -1;\n    }\n    if(!call((type)*id)){\n      if(id)call(id, id, str, *id);\n      return -1;\n    }\n  }\n  return 0;\n}",
        "base_ast": "typeid(type *id, type id, type *id)type id;type **id;type *id;type id;type *id;{\n  for(; *id != 0x25; id = id + 1){\n    if(*id == 0){\n      return 0;\n    }\n    lbl:\n    id = id + 1;\n    id = id[1];\n    if(id != 0x25){\n      if(id == 0){\n        if(id == (type)0x0){\n          return 0xffffffff;\n        }\n        id = str;\n        lbl:\n        call(id, id, id);\n        return 0xffffffff;\n      }\n      do{\n        if((0x3f < id) || ((1L << (id & 0x3f) & 0x1688900000001U) == 0)){\n          if(id == 0x2a){\n            if(id == (type)0x0){\n              return 0xffffffff;\n            }\n            id = str;\n            goto lbl;\n          }\n          break;\n        }\n        id = id[1];\n        id = id + 1;\n      }while(id != 0);\n      id = call(id, id, str, &id);\n      if(id == 0){\n        return 0xffffffff;\n      }\n      id = *id;\n      if(id == 0x2e){\n        id = id + 1;\n        id = call(id, id, str, &id);\n        if(id == 0){\n          return 0xffffffff;\n        }\n        id = *id;\n      }\n      id = id;\n      id = call();\n      if((*(type)((type)*id + (type)id * 2 + 1) & 4) == 0){\n        if(id == (type)0x0){\n          return 0xffffffff;\n        }\n        call(id, id, str, (type)(type)(type)(type)id);\n        return 0xffffffff;\n      }\n      goto lbl;\n    }\n    id = id + 2;\n  }\n  while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id){\n  type id;\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  do{\n    while(bool){\n      id = *id;\n      if(id == 0x25)break;\n      if(id == 0){\n        return (type)id;\n      }\n      lbl:\n      id = id + 1;\n    }\n    id = id + 1;\n    id = id[1];\n    if(id != 0x25){\n      if(id == 0){\n        if(id != (type)0x0){\n          id = str;\n          lbl:\n          call(id, id, id);\n        }\n        return 0xffffffff;\n      }\n      do{\n        if((0x3f < id) || ((1L << (id & 0x3f) & 0x1688900000001U) == 0)){\n          if(id == 0x2a){\n            if(id == (type)0x0){\n              return 0xffffffff;\n            }\n            id = str;\n            goto lbl;\n          }\n          break;\n        }\n        id = id[1];\n        id = id + 1;\n      }while(id != 0);\n      id = call(id, id, str, &id);\n      if(id == 0){\n        return 0xffffffff;\n      }\n      id = *id;\n      if(id == 0x2e){\n        id = id + 1;\n        id = call(id, id, str, &id);\n        if(id == 0){\n          return 0xffffffff;\n        }\n        id = *id;\n      }\n      id = id;\n      id = call();\n      if((*(type)((type)*id + (type)id * 2 + 1) & 4) == 0){\n        if(id == (type)0x0){\n          return 0xffffffff;\n        }\n        call(id, id, str, (type)(type)(type)(type)id);\n        return 0xffffffff;\n      }\n      goto lbl;\n    }\n    id = id + 2;\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.59375,
          "base_ppl": 1.9765625,
          "pr_ppl": 1.9765625,
          "source_ast_ppl": 3.59375,
          "base_ast_ppl": 3.25,
          "pr_ast_ppl": 3.125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_getbuffer-O2.so",
        "function": "file_getbuffer",
        "source_code": "file_protected const char *\nfile_getbuffer(struct magic_set *ms)\n{\n\tchar *pbuf, *op, *np;\n\tsize_t psize, len;\n\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn NULL;\n\n\tif (ms->flags & MAGIC_RAW)\n\t\treturn ms->o.buf;\n\n\tif (ms->o.buf == NULL)\n\t\treturn NULL;\n\n\t/* * 4 is for octal representation, + 1 is for NUL */\n\tlen = strlen(ms->o.buf);\n\tif (len > (SIZE_MAX - 1) / 4) {\n\t\tfile_oomem(ms, len);\n\t\treturn NULL;\n\t}\n\tpsize = len * 4 + 1;\n\tif ((pbuf = CAST(char *, realloc(ms->o.pbuf, psize))) == NULL) {\n\t\tfile_oomem(ms, psize);\n\t\treturn NULL;\n\t}\n\tms->o.pbuf = pbuf;\n\n#if defined(HAVE_WCHAR_H) && defined(HAVE_MBRTOWC) && defined(HAVE_WCWIDTH)\n\t{\n\t\tmbstate_t state;\n\t\twchar_t nextchar;\n\t\tint mb_conv = 1;\n\t\tsize_t bytesconsumed;\n\t\tchar *eop;\n\t\t(void)memset(&state, 0, sizeof(mbstate_t));\n\n\t\tnp = ms->o.pbuf;\n\t\top = ms->o.buf;\n\t\teop = op + len;\n\n\t\twhile (op < eop) {\n\t\t\tbytesconsumed = mbrtowc(&nextchar, op,\n\t\t\t    CAST(size_t, eop - op), &state);\n\t\t\tif (bytesconsumed == CAST(size_t, -1) ||\n\t\t\t    bytesconsumed == CAST(size_t, -2)) {\n\t\t\t\tmb_conv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iswprint(nextchar)) {\n\t\t\t\t(void)memcpy(np, op, bytesconsumed);\n\t\t\t\top += bytesconsumed;\n\t\t\t\tnp += bytesconsumed;\n\t\t\t} else {\n\t\t\t\twhile (bytesconsumed-- > 0)\n\t\t\t\t\tOCTALIFY(np, op);\n\t\t\t}\n\t\t}\n\t\t*np = '\\0';\n\n\t\t/* Parsing succeeded as a multi-byte sequence */\n\t\tif (mb_conv != 0)\n\t\t\treturn ms->o.pbuf;\n\t}\n#endif\n\n\tfor (np = ms->o.pbuf, op = ms->o.buf; *op;) {\n\t\tif (isprint(CAST(unsigned char, *op))) {\n\t\t\t*np++ = *op++;\n\t\t} else {\n\t\t\tOCTALIFY(np, op);\n\t\t}\n\t}\n\t*np = '\\0';\n\treturn ms->o.pbuf;\n}\n",
        "function_base": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                    }\n                    bVar5 = pbVar6[1];\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "function_pr": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = (undefined1 *)realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                    }\n                    bVar5 = pbVar6[1];\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "source_ast": "type *id(type *id){\n  type *id, *id, *id;\n  type id, id;\n  if(id->id & id)return null;\n  if(id->id & id)return id->id.id;\n  if(id->id.id == null)return null;\n  id = call(id->id.id);\n  if(id > (id - 1) / 4){\n    call(id, id);\n    return null;\n  }\n  id = id * 4 + 1;\n  if((id = call(id * call(id->id.id, id))) == null){\n    call(id, id);\n    return null;\n  }\n  id->id.id = id;\n  id && id && id{\n    type id;\n    type id;\n    type id = 1;\n    type id;\n    type *id;\n    (type)call(&id, 0, (id));\n    id = id->id.id;\n    id = id->id.id;\n    id = id + id;\n    while(id < id){\n      id = call(&id, id, call(id, id - id), &id);\n      if(id == call(id, -1) || id == call(id, -2)){\n        id = 0;\n        break;\n      }\n      if(call(id)){\n        (type)call(id, id, id);\n        id = id;\n        id = id;\n      }else{\n        while(id-- > 0)call(id, id);\n      }\n    }\n    *id = str;\n    if(id != 0)return id->id.id;\n  }\n  for(id = id->id.idid = id->id.id;  *id; ){\n    if(call(call(id, id, *id))){\n      *id++ = *id++;\n    }else{\n      call(id, id);\n    }\n  }\n  *id = str;\n  return id->id.id;\n}",
        "base_ast": "type *id( id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type **id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  if((*(type)(id + 0x48) & 1) == 0){\n    id = *(type)(id + 0x20);\n    if((*(type)(id + 0x45) & 1) != 0){\n      return id;\n    }\n    if(id != (type)0x0){\n      id = call(id);\n      id = id;\n      if(id >> 0x3e == 0){\n        id = id * 4 + 1;\n        id = call(*(type)(id + 0x30), id);\n        if(id != (type)0x0){\n          *(type)(id + 0x30) = id;\n          id.id = 0;\n          id.id = (type)0x0;\n          if(id != 0){\n            id = *(type)(id + 0x20);\n            id = id + id;\n            do{\n              id = call(&id, (type)id, (type)id - (type)id, &id);\n              if(0xfffffffffffffffd < id){\n                *id = 0;\n                id = *(type)(id + 0x20);\n                id = *(type)(id + 0x30);\n                id = *id;\n                if(id != 0){\n                  id = call();\n                  do{\n                    if((*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0){\n                      *id = 0x5c;\n                      id[1] = *id >> 6 | 0x30;\n                      id[2] = *id >> 3 & 7 | 0x30;\n                      id[3] = *id & 7 | 0x30;\n                      id = id + 4;\n                    }else{\n                      *id = id;\n                      id = id + 1;\n                    }\n                    id = id[1];\n                    id = id + 1;\n                  }while(id != 0);\n                }\n                *id = 0;\n                return *(type)(id + 0x30);\n              }\n              id = call(id);\n              if(id == 0){\n                for(; id != 0; id = id - 1){\n                  *id = 0x5c;\n                  id[1] = *id >> 6 | 0x30;\n                  id[2] = *id >> 3 & 7 | 0x30;\n                  id = *id;\n                  id = id + 1;\n                  id[3] = id & 7 | 0x30;\n                  id = id + 4;\n                }\n              }else{\n                call(id, id, id);\n                id = id + id;\n                id = id + id;\n              }\n            }while(id < id);\n          }\n          *id = 0;\n          return *(type)(id + 0x30);\n        }\n      }\n      call(id, id);\n      return (type)0x0;\n    }\n  }\n  return (type)0x0;\n}",
        "pr_ast": "type *id( id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type **id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  if((*(type)(id + 0x48) & 1) == 0){\n    id = *(type)(id + 0x20);\n    if((*(type)(id + 0x45) & 1) != 0){\n      return id;\n    }\n    if(id != (type)0x0){\n      id = call(id);\n      id = id;\n      if(id >> 0x3e == 0){\n        id = id * 4 + 1;\n        id = (type)call(*(type)(id + 0x30), id);\n        if(id != (type)0x0){\n          *(type)(id + 0x30) = id;\n          id.id = 0;\n          id.id = (type)0x0;\n          if(id != 0){\n            id = *(type)(id + 0x20);\n            id = id + id;\n            do{\n              id = call(&id, (type)id, (type)id - (type)id, &id);\n              if(0xfffffffffffffffd < id){\n                *id = 0;\n                id = *(type)(id + 0x20);\n                id = *(type)(id + 0x30);\n                id = *id;\n                if(id != 0){\n                  id = call();\n                  do{\n                    if((*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0){\n                      *id = 0x5c;\n                      id[1] = *id >> 6 | 0x30;\n                      id[2] = *id >> 3 & 7 | 0x30;\n                      id[3] = *id & 7 | 0x30;\n                      id = id + 4;\n                    }else{\n                      *id = id;\n                      id = id + 1;\n                    }\n                    id = id[1];\n                    id = id + 1;\n                  }while(id != 0);\n                }\n                *id = 0;\n                return *(type)(id + 0x30);\n              }\n              id = call(id);\n              if(id == 0){\n                for(; id != 0; id = id - 1){\n                  *id = 0x5c;\n                  id[1] = *id >> 6 | 0x30;\n                  id[2] = *id >> 3 & 7 | 0x30;\n                  id = *id;\n                  id = id + 1;\n                  id[3] = id & 7 | 0x30;\n                  id = id + 4;\n                }\n              }else{\n                call(id, id, id);\n                id = id + id;\n                id = id + id;\n              }\n            }while(id < id);\n          }\n          *id = 0;\n          return *(type)(id + 0x30);\n        }\n      }\n      call(id, id);\n      return (type)0x0;\n    }\n  }\n  return (type)0x0;\n}",
        "metrics": {
          "source_ppl": 2.046875,
          "base_ppl": 1.765625,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 4.21875,
          "base_ast_ppl": 2.40625,
          "pr_ast_ppl": 2.40625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces type casting that was not present in the Source Code, which could be considered noise and does not improve structural alignment.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_getbuffer-O3.so",
        "function": "file_getbuffer",
        "source_code": "file_protected const char *\nfile_getbuffer(struct magic_set *ms)\n{\n\tchar *pbuf, *op, *np;\n\tsize_t psize, len;\n\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn NULL;\n\n\tif (ms->flags & MAGIC_RAW)\n\t\treturn ms->o.buf;\n\n\tif (ms->o.buf == NULL)\n\t\treturn NULL;\n\n\t/* * 4 is for octal representation, + 1 is for NUL */\n\tlen = strlen(ms->o.buf);\n\tif (len > (SIZE_MAX - 1) / 4) {\n\t\tfile_oomem(ms, len);\n\t\treturn NULL;\n\t}\n\tpsize = len * 4 + 1;\n\tif ((pbuf = CAST(char *, realloc(ms->o.pbuf, psize))) == NULL) {\n\t\tfile_oomem(ms, psize);\n\t\treturn NULL;\n\t}\n\tms->o.pbuf = pbuf;\n\n#if defined(HAVE_WCHAR_H) && defined(HAVE_MBRTOWC) && defined(HAVE_WCWIDTH)\n\t{\n\t\tmbstate_t state;\n\t\twchar_t nextchar;\n\t\tint mb_conv = 1;\n\t\tsize_t bytesconsumed;\n\t\tchar *eop;\n\t\t(void)memset(&state, 0, sizeof(mbstate_t));\n\n\t\tnp = ms->o.pbuf;\n\t\top = ms->o.buf;\n\t\teop = op + len;\n\n\t\twhile (op < eop) {\n\t\t\tbytesconsumed = mbrtowc(&nextchar, op,\n\t\t\t    CAST(size_t, eop - op), &state);\n\t\t\tif (bytesconsumed == CAST(size_t, -1) ||\n\t\t\t    bytesconsumed == CAST(size_t, -2)) {\n\t\t\t\tmb_conv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iswprint(nextchar)) {\n\t\t\t\t(void)memcpy(np, op, bytesconsumed);\n\t\t\t\top += bytesconsumed;\n\t\t\t\tnp += bytesconsumed;\n\t\t\t} else {\n\t\t\t\twhile (bytesconsumed-- > 0)\n\t\t\t\t\tOCTALIFY(np, op);\n\t\t\t}\n\t\t}\n\t\t*np = '\\0';\n\n\t\t/* Parsing succeeded as a multi-byte sequence */\n\t\tif (mb_conv != 0)\n\t\t\treturn ms->o.pbuf;\n\t}\n#endif\n\n\tfor (np = ms->o.pbuf, op = ms->o.buf; *op;) {\n\t\tif (isprint(CAST(unsigned char, *op))) {\n\t\t\t*np++ = *op++;\n\t\t} else {\n\t\t\tOCTALIFY(np, op);\n\t\t}\n\t}\n\t*np = '\\0';\n\treturn ms->o.pbuf;\n}\n",
        "function_base": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                      bVar5 = pbVar6[1];\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                      bVar5 = pbVar6[1];\n                    }\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "function_pr": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = (undefined1 *)realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                      bVar5 = pbVar6[1];\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                      bVar5 = pbVar6[1];\n                    }\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "source_ast": "type *id(type *id){\n  type *id, *id, *id;\n  type id, id;\n  if(id->id & id)return null;\n  if(id->id & id)return id->id.id;\n  if(id->id.id == null)return null;\n  id = call(id->id.id);\n  if(id > (id - 1) / 4){\n    call(id, id);\n    return null;\n  }\n  id = id * 4 + 1;\n  if((id = call(id * call(id->id.id, id))) == null){\n    call(id, id);\n    return null;\n  }\n  id->id.id = id;\n  id && id && id{\n    type id;\n    type id;\n    type id = 1;\n    type id;\n    type *id;\n    (type)call(&id, 0, (id));\n    id = id->id.id;\n    id = id->id.id;\n    id = id + id;\n    while(id < id){\n      id = call(&id, id, call(id, id - id), &id);\n      if(id == call(id, -1) || id == call(id, -2)){\n        id = 0;\n        break;\n      }\n      if(call(id)){\n        (type)call(id, id, id);\n        id = id;\n        id = id;\n      }else{\n        while(id-- > 0)call(id, id);\n      }\n    }\n    *id = str;\n    if(id != 0)return id->id.id;\n  }\n  for(id = id->id.idid = id->id.id;  *id; ){\n    if(call(call(id, id, *id))){\n      *id++ = *id++;\n    }else{\n      call(id, id);\n    }\n  }\n  *id = str;\n  return id->id.id;\n}",
        "base_ast": "type *id( id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type **id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  if((*(type)(id + 0x48) & 1) == 0){\n    id = *(type)(id + 0x20);\n    if((*(type)(id + 0x45) & 1) != 0){\n      return id;\n    }\n    if(id != (type)0x0){\n      id = call(id);\n      id = id;\n      if(id >> 0x3e == 0){\n        id = id * 4 + 1;\n        id = call(*(type)(id + 0x30), id);\n        if(id != (type)0x0){\n          *(type)(id + 0x30) = id;\n          id.id = 0;\n          id.id = (type)0x0;\n          if(id != 0){\n            id = *(type)(id + 0x20);\n            id = id + id;\n            do{\n              id = call(&id, (type)id, (type)id - (type)id, &id);\n              if(0xfffffffffffffffd < id){\n                *id = 0;\n                id = *(type)(id + 0x20);\n                id = *(type)(id + 0x30);\n                id = *id;\n                if(id != 0){\n                  id = call();\n                  do{\n                    if((*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0){\n                      *id = 0x5c;\n                      id[1] = *id >> 6 | 0x30;\n                      id[2] = *id >> 3 & 7 | 0x30;\n                      id[3] = *id & 7 | 0x30;\n                      id = id + 4;\n                      id = id[1];\n                    }else{\n                      *id = id;\n                      id = id + 1;\n                      id = id[1];\n                    }\n                    id = id + 1;\n                  }while(id != 0);\n                }\n                *id = 0;\n                return *(type)(id + 0x30);\n              }\n              id = call(id);\n              if(id == 0){\n                for(; id != 0; id = id - 1){\n                  *id = 0x5c;\n                  id[1] = *id >> 6 | 0x30;\n                  id[2] = *id >> 3 & 7 | 0x30;\n                  id = *id;\n                  id = id + 1;\n                  id[3] = id & 7 | 0x30;\n                  id = id + 4;\n                }\n              }else{\n                call(id, id, id);\n                id = id + id;\n                id = id + id;\n              }\n            }while(id < id);\n          }\n          *id = 0;\n          return *(type)(id + 0x30);\n        }\n      }\n      call(id, id);\n      return (type)0x0;\n    }\n  }\n  return (type)0x0;\n}",
        "pr_ast": "type *id( id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type **id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  if((*(type)(id + 0x48) & 1) == 0){\n    id = *(type)(id + 0x20);\n    if((*(type)(id + 0x45) & 1) != 0){\n      return id;\n    }\n    if(id != (type)0x0){\n      id = call(id);\n      id = id;\n      if(id >> 0x3e == 0){\n        id = id * 4 + 1;\n        id = (type)call(*(type)(id + 0x30), id);\n        if(id != (type)0x0){\n          *(type)(id + 0x30) = id;\n          id.id = 0;\n          id.id = (type)0x0;\n          if(id != 0){\n            id = *(type)(id + 0x20);\n            id = id + id;\n            do{\n              id = call(&id, (type)id, (type)id - (type)id, &id);\n              if(0xfffffffffffffffd < id){\n                *id = 0;\n                id = *(type)(id + 0x20);\n                id = *(type)(id + 0x30);\n                id = *id;\n                if(id != 0){\n                  id = call();\n                  do{\n                    if((*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0){\n                      *id = 0x5c;\n                      id[1] = *id >> 6 | 0x30;\n                      id[2] = *id >> 3 & 7 | 0x30;\n                      id[3] = *id & 7 | 0x30;\n                      id = id + 4;\n                      id = id[1];\n                    }else{\n                      *id = id;\n                      id = id + 1;\n                      id = id[1];\n                    }\n                    id = id + 1;\n                  }while(id != 0);\n                }\n                *id = 0;\n                return *(type)(id + 0x30);\n              }\n              id = call(id);\n              if(id == 0){\n                for(; id != 0; id = id - 1){\n                  *id = 0x5c;\n                  id[1] = *id >> 6 | 0x30;\n                  id[2] = *id >> 3 & 7 | 0x30;\n                  id = *id;\n                  id = id + 1;\n                  id[3] = id & 7 | 0x30;\n                  id = id + 4;\n                }\n              }else{\n                call(id, id, id);\n                id = id + id;\n                id = id + id;\n              }\n            }while(id < id);\n          }\n          *id = 0;\n          return *(type)(id + 0x30);\n        }\n      }\n      call(id, id);\n      return (type)0x0;\n    }\n  }\n  return (type)0x0;\n}",
        "metrics": {
          "source_ppl": 2.046875,
          "base_ppl": 1.765625,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 4.21875,
          "base_ast_ppl": 2.390625,
          "pr_ast_ppl": 2.390625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces a type cast that was not present in the Source Code, which could be considered noise and does not align with the Source structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_cnxptiee-O3.so",
        "function": "cnxptiee",
        "source_code": "int cnxptiee(const void *from_bytes, int fromtype, void *to_bytes, int totype)\n{\n    unsigned char *from = (unsigned char *)from_bytes;\n    unsigned char *to = (unsigned char *)to_bytes;\n    unsigned char temp[8];\n    int i;\n\n    if (fromtype == CN_TYPE_NATIVE) {\n        fromtype = FLOATREP;\n    }\n    switch(fromtype) {\n        case CN_TYPE_IEEEL :\n            if (totype == CN_TYPE_IEEEL)\n                break;\n            for (i=7;i>=0;i--) {\n                temp[7-i] = from[i];\n            }\n            from = temp;\n            fromtype = CN_TYPE_IEEEB;\n            /* Break intentionally omitted. */\n        case CN_TYPE_IEEEB :\n            /* Break intentionally omitted. */\n        case CN_TYPE_XPORT :\n            break;\n        default:\n            return(-1);\n    }\n    if (totype == CN_TYPE_NATIVE) {\n        totype = FLOATREP;\n    }\n    switch(totype) {\n        case CN_TYPE_XPORT :\n        case CN_TYPE_IEEEB :\n        case CN_TYPE_IEEEL :\n            break;\n        default:\n            return(-2);\n    }\n    if (fromtype == totype) {\n        memcpy(to,from,8);\n        return(0);\n    }\n    switch(fromtype) {\n        case CN_TYPE_IEEEB :\n            if (totype == CN_TYPE_XPORT)\n                ieee2xpt(from,to);\n            else memcpy(to,from,8);\n            break;\n        case CN_TYPE_XPORT :\n            xpt2ieee(from,to);\n            break;\n    }\n    if (totype == CN_TYPE_IEEEL) {\n        memcpy(temp,to,8);\n        for (i=7;i>=0;i--) {\n            to[7-i] = temp[i];\n        }\n    }\n    return(0);\n}\n",
        "function_base": "\nundefined8 cnxptiee(ulong *param_1,int param_2,ulong *param_3,int param_4)\n\n{\n  ulong uVar1;\n  ulong in_RAX;\n  undefined8 local_28;\n  \n  local_28 = in_RAX;\n  if (param_2 == 0) {\n    param_2 = get_native();\n  }\n  if (1 < param_2 - 1U) {\n    if (param_2 != 3) {\n      return 0xffffffff;\n    }\n    if (param_4 == 3) goto LAB_001012ac;\n    local_28 = CONCAT17((char)*param_1,\n                        CONCAT16(*(undefined1 *)((long)param_1 + 1),\n                                 CONCAT15(*(undefined1 *)((long)param_1 + 2),\n                                          CONCAT14(*(undefined1 *)((long)param_1 + 3),\n                                                   CONCAT13(*(undefined1 *)((long)param_1 + 4),\n                                                            CONCAT12(*(undefined1 *)\n                                                                      ((long)param_1 + 5),\n                                                                     CONCAT11(*(undefined1 *)\n                                                                               ((long)param_1 + 6),\n                                                                              *(undefined1 *)\n                                                                               ((long)param_1 + 7)))\n                                                           )))));\n    param_2 = 2;\n    param_1 = &local_28;\n  }\n  if (param_4 == 0) {\n    param_4 = get_native();\n  }\n  if (2 < param_4 - 1U) {\n    return 0xfffffffe;\n  }\n  if (param_2 != param_4) {\n    if (param_2 == 1) {\n      xpt2ieee(*param_1,param_3);\n    }\n    else if (param_2 == 2) {\n      if (param_4 == 1) {\n        ieee2xpt(param_1,param_3);\n        return 0;\n      }\n      *param_3 = *param_1;\n    }\n    if (param_4 != 3) {\n      return 0;\n    }\n    uVar1 = *param_3;\n    *param_3 = uVar1 >> 0x38 | (uVar1 & 0xff000000000000) >> 0x28 | (uVar1 & 0xff0000000000) >> 0x18\n               | (uVar1 & 0xff00000000) >> 8 | (uVar1 & 0xff000000) << 8 |\n               (uVar1 & 0xff0000) << 0x18 | (uVar1 & 0xff00) << 0x28 | uVar1 << 0x38;\n    return 0;\n  }\nLAB_001012ac:\n  *param_3 = *param_1;\n  return 0;\n}\n\n",
        "function_pr": "\nundefined8 cnxptiee(ulong *param_1,int param_2,ulong *param_3,int param_4)\n\n{\n  ulong uVar1;\n  uint uVar2;\n  ulong in_RAX;\n  undefined8 local_28;\n  \n  local_28 = in_RAX;\n  if (param_2 == 0) {\n    param_2 = get_native();\n    uVar2 = param_2 - 1;\n  }\n  else {\n    uVar2 = param_2 - 1;\n  }\n  if (1 < uVar2) {\n    if (param_2 != 3) {\n      return 0xffffffff;\n    }\n    if (param_4 == 3) goto LAB_001012ac;\n    local_28 = CONCAT17((char)*param_1,\n                        CONCAT16(*(undefined1 *)((long)param_1 + 1),\n                                 CONCAT15(*(undefined1 *)((long)param_1 + 2),\n                                          CONCAT14(*(undefined1 *)((long)param_1 + 3),\n                                                   CONCAT13(*(undefined1 *)((long)param_1 + 4),\n                                                            CONCAT12(*(undefined1 *)\n                                                                      ((long)param_1 + 5),\n                                                                     CONCAT11(*(undefined1 *)\n                                                                               ((long)param_1 + 6),\n                                                                              *(undefined1 *)\n                                                                               ((long)param_1 + 7)))\n                                                           )))));\n    param_2 = 2;\n    param_1 = &local_28;\n  }\n  if (param_4 == 0) {\n    param_4 = get_native();\n    uVar2 = param_4 - 1;\n  }\n  else {\n    uVar2 = param_4 - 1;\n  }\n  if (2 < uVar2) {\n    return 0xfffffffe;\n  }\n  if (param_2 != param_4) {\n    if (param_2 == 1) {\n      xpt2ieee(*param_1,param_3);\n    }\n    else if (param_2 == 2) {\n      if (param_4 == 1) {\n        ieee2xpt(param_1,param_3);\n        return 0;\n      }\n      *param_3 = *param_1;\n    }\n    if (param_4 == 3) {\n      uVar1 = *param_3;\n      *param_3 = uVar1 >> 0x38 | (uVar1 & 0xff000000000000) >> 0x28 |\n                 (uVar1 & 0xff0000000000) >> 0x18 | (uVar1 & 0xff00000000) >> 8 |\n                 (uVar1 & 0xff000000) << 8 | (uVar1 & 0xff0000) << 0x18 | (uVar1 & 0xff00) << 0x28 |\n                 uVar1 << 0x38;\n      return 0;\n    }\n    return 0;\n  }\nLAB_001012ac:\n  *param_3 = *param_1;\n  return 0;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id){\n  type *id = (type)id;\n  type *id = (type)id;\n  type id[8];\n  type id;\n  if(id == id){\n    id = id;\n  }\n  switch(id){\n    case id:\n      if(id == id)break;\n      for(id = 7;  id >= 0; id--){\n        id[7 - id] = id[id];\n      }\n      id = id;\n      id = id;\n    case id:\n    case id:\n      break;\n    case def:\n      return (-1);\n  }\n  if(id == id){\n    id = id;\n  }\n  switch(id){\n    case id:\n    case id:\n    case id:\n      break;\n    case def:\n      return (-2);\n  }\n  if(id == id){\n    call(id, id, 8);\n    return (0);\n  }\n  switch(id){\n    case id:\n      if(id == id)call(id, id);elsecall(id, id, 8);\n      break;\n    case id:\n      call(id, id);\n      break;\n  }\n  if(id == id){\n    call(id, id, 8);\n    for(id = 7;  id >= 0; id--){\n      id[7 - id] = id[id];\n    }\n  }\n  return (0);\n}",
        "base_ast": "type id(type *id, type id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  id = id;\n  if(id == 0){\n    id = call();\n  }\n  if(1 < id - 1U){\n    if(id != 3){\n      return 0xffffffff;\n    }\n    if(id == 3)goto lbl;\n    id = call((type)*id, call(*(type)((type)id + 1), call(*(type)((type)id + 2), call(*(type)((type)id + 3), call(*(type)((type)id + 4), call(*(type)((type)id + 5), call(*(type)((type)id + 6), *(type)((type)id + 7))))))));\n    id = 2;\n    id = &id;\n  }\n  if(id == 0){\n    id = call();\n  }\n  if(2 < id - 1U){\n    return 0xfffffffe;\n  }\n  if(id != id){\n    if(id == 1){\n      call(*id, id);\n    }elseif(id == 2){\n      if(id == 1){\n        call(id, id);\n        return 0;\n      }\n      *id = *id;\n    }\n    if(id != 3){\n      return 0;\n    }\n    id = *id;\n    *id = id >> 0x38 | (id & 0xff000000000000) >> 0x28 | (id & 0xff0000000000) >> 0x18 | (id & 0xff00000000) >> 8 | (id & 0xff000000) << 8 | (id & 0xff0000) << 0x18 | (id & 0xff00) << 0x28 | id << 0x38;\n    return 0;\n  }\n  lbl:\n  *id = *id;\n  return 0;\n}",
        "pr_ast": "type id(type *id, type id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type id;\n  id = id;\n  if(id == 0){\n    id = call();\n    id = id - 1;\n  }else{\n    id = id - 1;\n  }\n  if(1 < id){\n    if(id != 3){\n      return 0xffffffff;\n    }\n    if(id == 3)goto lbl;\n    id = call((type)*id, call(*(type)((type)id + 1), call(*(type)((type)id + 2), call(*(type)((type)id + 3), call(*(type)((type)id + 4), call(*(type)((type)id + 5), call(*(type)((type)id + 6), *(type)((type)id + 7))))))));\n    id = 2;\n    id = &id;\n  }\n  if(id == 0){\n    id = call();\n    id = id - 1;\n  }else{\n    id = id - 1;\n  }\n  if(2 < id){\n    return 0xfffffffe;\n  }\n  if(id != id){\n    if(id == 1){\n      call(*id, id);\n    }elseif(id == 2){\n      if(id == 1){\n        call(id, id);\n        return 0;\n      }\n      *id = *id;\n    }\n    if(id == 3){\n      id = *id;\n      *id = id >> 0x38 | (id & 0xff000000000000) >> 0x28 | (id & 0xff0000000000) >> 0x18 | (id & 0xff00000000) >> 8 | (id & 0xff000000) << 8 | (id & 0xff0000) << 0x18 | (id & 0xff00) << 0x28 | id << 0x38;\n      return 0;\n    }\n    return 0;\n  }\n  lbl:\n  *id = *id;\n  return 0;\n}",
        "metrics": {
          "source_ppl": 2.234375,
          "base_ppl": 1.9453125,
          "pr_ppl": 1.8671875,
          "source_ast_ppl": 2.71875,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.265625,
          "delta_ppl": -0.078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces unnecessary variables and logic that do not align with the Source Code structure. It also changes the order of operations and introduces redundant checks, moving away from the original control flow and logic.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate B introduces additional variables and logic that do not match the Source AST topology. It also changes the conditions and operations within the if statements, which alters the overall structure and complexity compared to the Source.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_readstat_convert-O2.so",
        "function": "readstat_convert",
        "source_code": "readstat_error_t readstat_convert(char *dst, size_t dst_len, const char *src, size_t src_len, iconv_t converter) {\n    /* strip off spaces from the input because the programs use ASCII space\n     * padding even with non-ASCII encoding. */\n    while (src_len && (src[src_len-1] == ' ' || src[src_len-1] == '\\0')) {\n        src_len--;\n    }\n    if (dst_len == 0) {\n        return READSTAT_ERROR_CONVERT_LONG_STRING;\n    } else if (converter) {\n        size_t dst_left = dst_len - 1;\n        char *dst_end = dst;\n        size_t status = iconv(converter, (readstat_iconv_inbuf_t)&src, &src_len, &dst_end, &dst_left);\n        if (status == (size_t)-1) {\n            if (errno == E2BIG) {\n                return READSTAT_ERROR_CONVERT_LONG_STRING;\n            } else if (errno == EILSEQ) {\n                return READSTAT_ERROR_CONVERT_BAD_STRING;\n            } else if (errno != EINVAL) { /* EINVAL indicates improper truncation; accept it */\n                return READSTAT_ERROR_CONVERT;\n            }\n        }\n        dst[dst_len - dst_left - 1] = '\\0';\n    } else if (src_len + 1 > dst_len) {\n        return READSTAT_ERROR_CONVERT_LONG_STRING;\n    } else {\n        memcpy(dst, src, src_len);\n        dst[src_len] = '\\0';\n    }\n    return READSTAT_OK;\n}\n",
        "function_base": "\nundefined8\nreadstat_convert(char *param_1,ulong param_2,char *param_3,size_t param_4,iconv_t param_5)\n\n{\n  int iVar1;\n  size_t sVar2;\n  int *piVar3;\n  ulong local_30;\n  char *local_28;\n  size_t local_20;\n  char *local_18;\n  \n  for (; param_4 != 0; param_4 = param_4 - 1) {\n    if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n  }\n  param_4 = 0;\nLAB_00101160:\n  if (param_2 == 0) {\n    return 0x13;\n  }\n  local_20 = param_4;\n  local_18 = param_3;\n  if (param_5 == (iconv_t)0x0) {\n    if (param_2 < param_4 + 1) {\n      return 0x13;\n    }\n    memcpy(param_1,param_3,param_4);\n    param_1[param_4] = '\\0';\n  }\n  else {\n    local_30 = param_2 - 1;\n    local_28 = param_1;\n    sVar2 = iconv(param_5,&local_18,&local_20,&local_28,&local_30);\n    if (sVar2 == 0xffffffffffffffff) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      if (iVar1 == 7) {\n        return 0x13;\n      }\n      if (iVar1 != 0x16) {\n        if (iVar1 == 0x54) {\n          return 0x11;\n        }\n        return 0x10;\n      }\n    }\n    param_1[param_2 + ~local_30] = '\\0';\n  }\n  return 0;\n}\n\n",
        "function_pr": "\nundefined8\nreadstat_convert(char *param_1,ulong param_2,char *param_3,size_t param_4,iconv_t param_5)\n\n{\n  int iVar1;\n  size_t sVar2;\n  int *piVar3;\n  ulong local_30;\n  char *local_28;\n  size_t local_20;\n  char *local_18;\n  \n  if (param_4 != 0) {\n    do {\n      if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n      param_4 = param_4 - 1;\n    } while (param_4 != 0);\n  }\n  param_4 = 0;\nLAB_00101160:\n  if (param_2 == 0) {\n    return 0x13;\n  }\n  local_20 = param_4;\n  local_18 = param_3;\n  if (param_5 == (iconv_t)0x0) {\n    if (param_2 < param_4 + 1) {\n      return 0x13;\n    }\n    memcpy(param_1,param_3,param_4);\n    param_1[param_4] = '\\0';\n  }\n  else {\n    local_30 = param_2 - 1;\n    local_28 = param_1;\n    sVar2 = iconv(param_5,&local_18,&local_20,&local_28,&local_30);\n    if (sVar2 == 0xffffffffffffffff) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      if (iVar1 == 7) {\n        return 0x13;\n      }\n      if (iVar1 != 0x16) {\n        if (iVar1 == 0x54) {\n          return 0x11;\n        }\n        return 0x10;\n      }\n    }\n    param_1[param_2 + ~local_30] = '\\0';\n  }\n  return 0;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type id){\n  while(id && (id[id - 1] == str || id[id - 1] == str)){\n    id--;\n  }\n  if(id == 0){\n    return id;\n  }elseif(id){\n    type id = id - 1;\n    type *id = id;\n    type id = call(id, (id) & id, &id, &id, &id);\n    if(id == (type)-1){\n      if(id == id){\n        return id;\n      }elseif(id == id){\n        return id;\n      }elseif(id != id){\n        return id;\n      }\n    }\n    id[id - id - 1] = str;\n  }elseif(id + 1 > id){\n    return id;\n  }else{\n    call(id, id, id);\n    id[id] = str;\n  }\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type id, type id){\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  for(; id != 0; id = id - 1){\n    if((id[id - 1] & 0xdfU) != 0)goto lbl;\n  }\n  id = 0;\n  lbl:\n  if(id == 0){\n    return 0x13;\n  }\n  id = id;\n  id = id;\n  if(id == (type)0x0){\n    if(id < id + 1){\n      return 0x13;\n    }\n    call(id, id, id);\n    id[id] = str;\n  }else{\n    id = id - 1;\n    id = id;\n    id = call(id, &id, &id, &id, &id);\n    if(id == 0xffffffffffffffff){\n      id = call();\n      id = *id;\n      if(id == 7){\n        return 0x13;\n      }\n      if(id != 0x16){\n        if(id == 0x54){\n          return 0x11;\n        }\n        return 0x10;\n      }\n    }\n    id[id + ~id] = str;\n  }\n  return 0;\n}",
        "pr_ast": "type id(type *id, type id, type *id, type id, type id){\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  if(id != 0){\n    do{\n      if((id[id - 1] & 0xdfU) != 0)goto lbl;\n      id = id - 1;\n    }while(id != 0);\n  }\n  id = 0;\n  lbl:\n  if(id == 0){\n    return 0x13;\n  }\n  id = id;\n  id = id;\n  if(id == (type)0x0){\n    if(id < id + 1){\n      return 0x13;\n    }\n    call(id, id, id);\n    id[id] = str;\n  }else{\n    id = id - 1;\n    id = id;\n    id = call(id, &id, &id, &id, &id);\n    if(id == 0xffffffffffffffff){\n      id = call();\n      id = *id;\n      if(id == 7){\n        return 0x13;\n      }\n      if(id != 0x16){\n        if(id == 0x54){\n          return 0x11;\n        }\n        return 0x10;\n      }\n    }\n    id[id + ~id] = str;\n  }\n  return 0;\n}",
        "metrics": {
          "source_ppl": 2.546875,
          "base_ppl": 1.890625,
          "pr_ppl": 1.859375,
          "source_ast_ppl": 3.65625,
          "base_ast_ppl": 3.65625,
          "pr_ast_ppl": 3.46875,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_readstat_convert-O3.so",
        "function": "readstat_convert",
        "source_code": "readstat_error_t readstat_convert(char *dst, size_t dst_len, const char *src, size_t src_len, iconv_t converter) {\n    /* strip off spaces from the input because the programs use ASCII space\n     * padding even with non-ASCII encoding. */\n    while (src_len && (src[src_len-1] == ' ' || src[src_len-1] == '\\0')) {\n        src_len--;\n    }\n    if (dst_len == 0) {\n        return READSTAT_ERROR_CONVERT_LONG_STRING;\n    } else if (converter) {\n        size_t dst_left = dst_len - 1;\n        char *dst_end = dst;\n        size_t status = iconv(converter, (readstat_iconv_inbuf_t)&src, &src_len, &dst_end, &dst_left);\n        if (status == (size_t)-1) {\n            if (errno == E2BIG) {\n                return READSTAT_ERROR_CONVERT_LONG_STRING;\n            } else if (errno == EILSEQ) {\n                return READSTAT_ERROR_CONVERT_BAD_STRING;\n            } else if (errno != EINVAL) { /* EINVAL indicates improper truncation; accept it */\n                return READSTAT_ERROR_CONVERT;\n            }\n        }\n        dst[dst_len - dst_left - 1] = '\\0';\n    } else if (src_len + 1 > dst_len) {\n        return READSTAT_ERROR_CONVERT_LONG_STRING;\n    } else {\n        memcpy(dst, src, src_len);\n        dst[src_len] = '\\0';\n    }\n    return READSTAT_OK;\n}\n",
        "function_base": "\nundefined8\nreadstat_convert(char *param_1,ulong param_2,char *param_3,size_t param_4,iconv_t param_5)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  size_t sVar3;\n  int *piVar4;\n  ulong local_30;\n  char *local_28;\n  size_t local_20;\n  char *local_18;\n  \n  for (; param_4 != 0; param_4 = param_4 - 1) {\n    if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n  }\n  param_4 = 0;\nLAB_00101160:\n  uVar2 = 0x13;\n  if (param_2 != 0) {\n    local_20 = param_4;\n    local_18 = param_3;\n    if (param_5 == (iconv_t)0x0) {\n      if (param_2 < param_4 + 1) {\n        return 0x13;\n      }\n      memcpy(param_1,param_3,param_4);\n      param_1[param_4] = '\\0';\n    }\n    else {\n      local_30 = param_2 - 1;\n      local_28 = param_1;\n      sVar3 = iconv(param_5,&local_18,&local_20,&local_28,&local_30);\n      if (sVar3 == 0xffffffffffffffff) {\n        piVar4 = __errno_location();\n        iVar1 = *piVar4;\n        if (iVar1 == 7) {\n          return 0x13;\n        }\n        if (iVar1 != 0x16) {\n          if (iVar1 != 0x54) {\n            return 0x10;\n          }\n          return 0x11;\n        }\n      }\n      param_1[param_2 + ~local_30] = '\\0';\n    }\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nundefined8\nreadstat_convert(char *param_1,ulong param_2,char *param_3,size_t param_4,iconv_t param_5)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  size_t sVar3;\n  int *piVar4;\n  ulong local_30;\n  char *local_28;\n  size_t local_20;\n  char *local_18;\n  \n  if (param_4 != 0) {\n    do {\n      if ((param_3[param_4 - 1] & 0xdfU) != 0) goto LAB_00101160;\n      param_4 = param_4 - 1;\n    } while (param_4 != 0);\n  }\n  param_4 = 0;\nLAB_00101160:\n  uVar2 = 0x13;\n  if (param_2 != 0) {\n    local_20 = param_4;\n    local_18 = param_3;\n    if (param_5 == (iconv_t)0x0) {\n      if (param_2 < param_4 + 1) {\n        return 0x13;\n      }\n      memcpy(param_1,param_3,param_4);\n      param_1[param_4] = '\\0';\n    }\n    else {\n      local_30 = param_2 - 1;\n      local_28 = param_1;\n      sVar3 = iconv(param_5,&local_18,&local_20,&local_28,&local_30);\n      if (sVar3 == 0xffffffffffffffff) {\n        piVar4 = __errno_location();\n        iVar1 = *piVar4;\n        if (iVar1 == 7) {\n          return 0x13;\n        }\n        if (iVar1 != 0x16) {\n          if (iVar1 == 0x54) {\n            return 0x11;\n          }\n          return 0x10;\n        }\n      }\n      param_1[param_2 + ~local_30] = '\\0';\n    }\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type id){\n  while(id && (id[id - 1] == str || id[id - 1] == str)){\n    id--;\n  }\n  if(id == 0){\n    return id;\n  }elseif(id){\n    type id = id - 1;\n    type *id = id;\n    type id = call(id, (id) & id, &id, &id, &id);\n    if(id == (type)-1){\n      if(id == id){\n        return id;\n      }elseif(id == id){\n        return id;\n      }elseif(id != id){\n        return id;\n      }\n    }\n    id[id - id - 1] = str;\n  }elseif(id + 1 > id){\n    return id;\n  }else{\n    call(id, id, id);\n    id[id] = str;\n  }\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  for(; id != 0; id = id - 1){\n    if((id[id - 1] & 0xdfU) != 0)goto lbl;\n  }\n  id = 0;\n  lbl:\n  id = 0x13;\n  if(id != 0){\n    id = id;\n    id = id;\n    if(id == (type)0x0){\n      if(id < id + 1){\n        return 0x13;\n      }\n      call(id, id, id);\n      id[id] = str;\n    }else{\n      id = id - 1;\n      id = id;\n      id = call(id, &id, &id, &id, &id);\n      if(id == 0xffffffffffffffff){\n        id = call();\n        id = *id;\n        if(id == 7){\n          return 0x13;\n        }\n        if(id != 0x16){\n          if(id != 0x54){\n            return 0x10;\n          }\n          return 0x11;\n        }\n      }\n      id[id + ~id] = str;\n    }\n    id = 0;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type *id, type id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  if(id != 0){\n    do{\n      if((id[id - 1] & 0xdfU) != 0)goto lbl;\n      id = id - 1;\n    }while(id != 0);\n  }\n  id = 0;\n  lbl:\n  id = 0x13;\n  if(id != 0){\n    id = id;\n    id = id;\n    if(id == (type)0x0){\n      if(id < id + 1){\n        return 0x13;\n      }\n      call(id, id, id);\n      id[id] = str;\n    }else{\n      id = id - 1;\n      id = id;\n      id = call(id, &id, &id, &id, &id);\n      if(id == 0xffffffffffffffff){\n        id = call();\n        id = *id;\n        if(id == 7){\n          return 0x13;\n        }\n        if(id != 0x16){\n          if(id == 0x54){\n            return 0x11;\n          }\n          return 0x10;\n        }\n      }\n      id[id + ~id] = str;\n    }\n    id = 0;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.546875,
          "base_ppl": 1.890625,
          "pr_ppl": 1.8515625,
          "source_ast_ppl": 3.65625,
          "base_ast_ppl": 3.71875,
          "pr_ast_ppl": 3.546875,
          "delta_ppl": -0.0390625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_printable-O2.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,long param_4,long param_5)\n\n{\n  byte bVar1;\n  ushort **ppuVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  bool bVar5;\n  \n  pbVar3 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    uVar4 = param_4 + 1;\n    while( true ) {\n      bVar1 = *(byte *)(uVar4 - 1);\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar2 = __ctype_b_loc(), (*(byte *)((long)*ppuVar2 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar3) break;\n        *pbVar3 = 0x5c;\n        pbVar3[1] = *(byte *)(uVar4 - 1) >> 6 | 0x30;\n        pbVar3[2] = *(byte *)(uVar4 - 1) >> 3 & 7 | 0x30;\n        pbVar3[3] = *(byte *)(uVar4 - 1) & 7 | 0x30;\n        pbVar3 = pbVar3 + 4;\n      }\n      else {\n        *pbVar3 = bVar1;\n        pbVar3 = pbVar3 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar3) ||\n         (bVar5 = (ulong)(param_5 + param_4) <= uVar4, uVar4 = uVar4 + 1, bVar5)) break;\n    }\n  }\n  *pbVar3 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, *id = id + id - 1;\n  type *id = call(id unsigned char id);\n  type *id = id + id;\n  for(id = id;  id < id && id < id && *id; id++){\n    if((id->id & id) != 0 || call(*id)){\n      *id++ = *id;\n      continue;\n    }\n    if(id >= id - 3)break;\n    *id++ = str;\n    *id++ = ((type)&7) + str;\n    *id++ = ((type)&7) + str;\n    *id++ = ((type)&7) + str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id + id + -1) && (0 < id)){\n    id = id;\n    while(bool){\n      id = id + 1;\n      id = *id;\n      if((type)id == 0)break;\n      if(((*(type)(id + 0x45) & 1) == 0) && (id = call()(*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0)){\n        if(id + id + -4 <= id)break;\n        *id = 0x5c;\n        id[1] = *id >> 6 | 0x30;\n        id[2] = *id >> 3 & 7 | 0x30;\n        id[3] = *id & 7 | 0x30;\n        id = id + 4;\n      }else{\n        *id = id;\n        id = id + 1;\n      }\n      if((id + id + -1 <= id) || (id = idid + id <= id))break;\n    }\n  }\n  *id = 0;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id,  id,  id){\n  type id;\n  type **id;\n  type *id;\n  type id;\n  type id;\n  id = id;\n  if((id < id + id + -1) && (0 < id)){\n    id = id + 1;\n    while(bool){\n      id = *(type)(id - 1);\n      if((type)id == 0)break;\n      if(((*(type)(id + 0x45) & 1) == 0) && (id = call()(*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0)){\n        if(id + id + -4 <= id)break;\n        *id = 0x5c;\n        id[1] = *(type)(id - 1) >> 6 | 0x30;\n        id[2] = *(type)(id - 1) >> 3 & 7 | 0x30;\n        id[3] = *(type)(id - 1) & 7 | 0x30;\n        id = id + 4;\n      }else{\n        *id = id;\n        id = id + 1;\n      }\n      if((id + id + -1 <= id) || (id = call(id + id) <= idid = id + 1id))break;\n    }\n  }\n  *id = 0;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.15625,
          "base_ppl": 2.15625,
          "pr_ppl": 2.09375,
          "source_ast_ppl": 4.96875,
          "base_ast_ppl": 3.984375,
          "pr_ast_ppl": 4.03125,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces unnecessary variables and logic that do not align with the source code's structure. It also uses different variable types and names, making it less readable and more complex compared to the original.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_printable-O3.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,long param_4,long param_5)\n\n{\n  byte bVar1;\n  ushort **ppuVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  bool bVar5;\n  \n  pbVar3 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    uVar4 = param_4 + 1;\n    while( true ) {\n      bVar1 = *(byte *)(uVar4 - 1);\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar2 = __ctype_b_loc(), (*(byte *)((long)*ppuVar2 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar3) break;\n        *pbVar3 = 0x5c;\n        pbVar3[1] = *(byte *)(uVar4 - 1) >> 6 | 0x30;\n        pbVar3[2] = *(byte *)(uVar4 - 1) >> 3 & 7 | 0x30;\n        pbVar3[3] = *(byte *)(uVar4 - 1) & 7 | 0x30;\n        pbVar3 = pbVar3 + 4;\n      }\n      else {\n        *pbVar3 = bVar1;\n        pbVar3 = pbVar3 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar3) ||\n         (bVar5 = (ulong)(param_5 + param_4) <= uVar4, uVar4 = uVar4 + 1, bVar5)) break;\n    }\n  }\n  *pbVar3 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, *id = id + id - 1;\n  type *id = call(id unsigned char id);\n  type *id = id + id;\n  for(id = id;  id < id && id < id && *id; id++){\n    if((id->id & id) != 0 || call(*id)){\n      *id++ = *id;\n      continue;\n    }\n    if(id >= id - 3)break;\n    *id++ = str;\n    *id++ = ((type)&7) + str;\n    *id++ = ((type)&7) + str;\n    *id++ = ((type)&7) + str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id + id + -1) && (0 < id)){\n    id = id;\n    while(bool){\n      id = id + 1;\n      id = *id;\n      if((type)id == 0)break;\n      if(((*(type)(id + 0x45) & 1) == 0) && (id = call()(*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0)){\n        if(id + id + -4 <= id)break;\n        *id = 0x5c;\n        id[1] = *id >> 6 | 0x30;\n        id[2] = *id >> 3 & 7 | 0x30;\n        id[3] = *id & 7 | 0x30;\n        id = id + 4;\n      }else{\n        *id = id;\n        id = id + 1;\n      }\n      if((id + id + -1 <= id) || (id = idid + id <= id))break;\n    }\n  }\n  *id = 0;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id,  id,  id){\n  type id;\n  type **id;\n  type *id;\n  type id;\n  type id;\n  id = id;\n  if((id < id + id + -1) && (0 < id)){\n    id = id + 1;\n    while(bool){\n      id = *(type)(id - 1);\n      if((type)id == 0)break;\n      if(((*(type)(id + 0x45) & 1) == 0) && (id = call()(*(type)((type)*id + (type)id * 2 + 1) & 0x40) == 0)){\n        if(id + id + -4 <= id)break;\n        *id = 0x5c;\n        id[1] = *(type)(id - 1) >> 6 | 0x30;\n        id[2] = *(type)(id - 1) >> 3 & 7 | 0x30;\n        id[3] = *(type)(id - 1) & 7 | 0x30;\n        id = id + 4;\n      }else{\n        *id = id;\n        id = id + 1;\n      }\n      if((id + id + -1 <= id) || (id = call(id + id) <= idid = id + 1id))break;\n    }\n  }\n  *id = 0;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.15625,
          "base_ppl": 2.15625,
          "pr_ppl": 2.09375,
          "source_ast_ppl": 4.96875,
          "base_ast_ppl": 3.984375,
          "pr_ast_ppl": 4.03125,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces unnecessary variables and changes the loop condition, moving away from the Source Code structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      }
    ]
  }
}