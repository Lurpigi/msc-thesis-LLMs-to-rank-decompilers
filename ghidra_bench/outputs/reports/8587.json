{
  "pr": "8587",
  "mean_delta_perplexity": -0.029017857142857144,
  "mean_perplexity_base": 2.185267857142857,
  "mean_perplexity_pr": 2.15625,
  "mean_perplexity_source": 1.9464285714285714,
  "mean_perplexity_base_ast": 2.7098214285714284,
  "mean_perplexity_pr_ast": 2.71875,
  "mean_perplexity_source_ast": 2.9776785714285716,
  "results": {
    "qwen-coder": [
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(_dta_timestamp_parse_actions[lVar8 + lVar15 + 1]) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(id[id op id op num]){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.6640625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.4375,
          "pr_ast_ppl": 2.453125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "PR",
          "motivation": "Both candidates accurately capture the control flow and logical structure of the original source code, making them equally faithful to the human intent. However, Candidate B follows a more structured format typical of modern C code, which might make it slightly easier to read and maintain for developers familiar with this style."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(_dta_timestamp_parse_actions[lVar8 + lVar15 + 1]) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(id[id op id op num]){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.6640625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.4375,
          "pr_ast_ppl": 2.453125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "```json\n{\n  \"diff_analysis\": \"Both Candidate A and Candidate B exhibit significant structural differences from the Source AST. However, upon closer inspection, both candidates fail to accurately mirror the architectural intent of the Source in terms of control flow structures and logical operations.\",\n  \"motivation\": \"Neither Candidate A nor Candidate B preserves the architectural intent of the Source effectively. They both transform the original source code into complex and convoluted structures that deviate from the intended logic and control flow. Both candidates introduce unnecessary loops, conditionals, and repetitive patterns that do not align with the original Source's design principles.\",\n  \"winner\": null\n}\n```"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(_sav_date_parse_actions[lVar8 + lVar11 + 1]) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(id[id op id op num]){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.734375,
          "base_ppl": 2.234375,
          "pr_ppl": 2.1875,
          "source_ast_ppl": 2.328125,
          "base_ast_ppl": 2.5625,
          "pr_ast_ppl": 2.578125,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "BASE",
          "motivation": "Both candidates preserve the overall control flow and logic of the Source code. They both contain loops, conditionals, and function calls, maintaining the same architectural intent. While there might be minor syntactic differences, the fundamental structure remains intact. Therefore, both candidates can be considered equally effective in preserving the architectural intent of the Source."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(_sav_date_parse_actions[lVar8 + lVar11 + 1]) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(id[id op id op num]){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.734375,
          "base_ppl": 2.234375,
          "pr_ppl": 2.1875,
          "source_ast_ppl": 2.328125,
          "base_ast_ppl": 2.5625,
          "pr_ast_ppl": 2.578125,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "```json\n{\n  \"diff_analysis\": \"Both candidates have identical control flow skeletons, with no differences in their structure or logic.\",\n  \"motivation\": \"Since both candidates are identical, they equally represent a machine-like concrete design without any idiomatic or human-like structural elements. There is no way to differentiate between them based on the given criteria.\",\n  \"winner\": null\n}\n```"
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "```json\n{\n  \"diff_analysis\": \"Both Candidate A and Candidate B exhibit significant structural degradation compared to the Source AST. They both lack the complex control flow structures such as loops, conditionals, and switch statements found in the Source. Instead, they contain repetitive patterns of conditional checks and arithmetic operations without proper nesting or control flow mechanisms.\",\n  \"motivation\": \"Neither Candidate A nor Candidate B accurately preserves the architectural intent of the Source AST. Both fail to maintain the topological shape of the original code, leading to a loss of critical control flow structures. The Source AST contains multiple nested loops, conditionals, and switch statements, which are essential for understanding the logic and behavior of the program. In contrast, both Candidates A and B reduce these structures to simple loops and conditional checks, resulting in a flattened and less readable representation of the original code. Therefore, neither candidate can be considered a faithful representation of the Source AST.\",\n  \"winner\": null\n}\n```"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(_sav_time_parse_actions[lVar17 + (long)cVar3 + 1]) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(id[id op (type)id op num]){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.21875,
          "base_ppl": 2.234375,
          "pr_ppl": 2.171875,
          "source_ast_ppl": 2.921875,
          "base_ast_ppl": 2.921875,
          "pr_ast_ppl": 2.921875,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(_sav_time_parse_actions[lVar17 + (long)cVar3 + 1]) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(id[id op (type)id op num]){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.21875,
          "base_ppl": 2.234375,
          "pr_ppl": 2.171875,
          "source_ast_ppl": 2.921875,
          "base_ast_ppl": 2.921875,
          "pr_ast_ppl": 2.921875,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-file_file_replace-O0.so",
        "function": "file_replace",
        "source_code": "file_protected int\nfile_replace(struct magic_set *ms, const char *pat, const char *rep)\n{\n\tfile_regex_t rx;\n\tint rc, rv = -1;\n\n\trc = file_regcomp(ms, &rx, pat, REG_EXTENDED);\n\tif (rc == 0) {\n\t\tregmatch_t rm;\n\t\tint nm = 0;\n\t\twhile (file_regexec(ms, &rx, ms->o.buf, 1, &rm, 0) == 0) {\n\t\t\tms->o.buf[rm.rm_so] = '\\0';\n\t\t\tif (file_printf(ms, \"%s%s\", rep,\n\t\t\t    rm.rm_eo != 0 ? ms->o.buf + rm.rm_eo : \"\") == -1)\n\t\t\t\tgoto out;\n\t\t\tnm++;\n\t\t}\n\t\trv = nm;\n\t}\nout:\n\tfile_regfree(&rx);\n\treturn rv;\n}\n",
        "function_base": "\nint file_replace(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  undefined *local_90;\n  int local_74;\n  int local_70;\n  int local_6c;\n  int local_68;\n  int local_64;\n  undefined1 local_60 [64];\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_68 = -1;\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_64 = file_regcomp(param_1,local_60,param_2,1);\n  if (local_64 == 0) {\n    local_74 = 0;\n    while (iVar1 = file_regexec(local_10,local_60,*(undefined8 *)(local_10 + 0x20),1,&local_70,0),\n          iVar1 == 0) {\n      *(undefined1 *)(*(long *)(local_10 + 0x20) + (long)local_70) = 0;\n      if (local_6c == 0) {\n        local_90 = &DAT_0010201c;\n      }\n      else {\n        local_90 = (undefined *)(*(long *)(local_10 + 0x20) + (long)local_6c);\n      }\n      iVar1 = file_printf(local_10,&DAT_00102098,local_20,local_90);\n      if (iVar1 == -1) goto LAB_0010189e;\n      local_74 = local_74 + 1;\n    }\n    local_68 = local_74;\n  }\nLAB_0010189e:\n  file_regfree(local_60);\n  return local_68;\n}\n\n",
        "function_pr": "\nint file_replace(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  char *local_90;\n  int local_74;\n  int local_70;\n  int local_6c;\n  int local_68;\n  int local_64;\n  undefined1 local_60 [64];\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_68 = -1;\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_64 = file_regcomp(param_1,local_60,param_2,1);\n  if (local_64 == 0) {\n    local_74 = 0;\n    while (iVar1 = file_regexec(local_10,local_60,*(undefined8 *)(local_10 + 0x20),1,&local_70,0),\n          iVar1 == 0) {\n      *(undefined1 *)(*(long *)(local_10 + 0x20) + (long)local_70) = 0;\n      if (local_6c == 0) {\n        local_90 = \"\";\n      }\n      else {\n        local_90 = (char *)(*(long *)(local_10 + 0x20) + (long)local_6c);\n      }\n      iVar1 = file_printf(local_10,&DAT_00102098,local_20,local_90);\n      if (iVar1 == -1) goto LAB_0010189e;\n      local_74 = local_74 + 1;\n    }\n    local_68 = local_74;\n  }\nLAB_0010189e:\n  file_regfree(local_60);\n  return local_68;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id;\n  type id, , id = num;\n  id = call(id, &id, id, id);\n  if(id == num){\n    type id;\n    type id = num;\n    while(call(id, &id, id->id.id, num, &id, num) == num){\n      id->id.id[id.id] = str;\n      if(call(id, str, id, (id.id != num ? id->id.id op id.id : str)) == num)goto lbl;\n      id upd;\n    }\n    id = id;\n  }\n  lbl:\n  call(&id);\n  return id;\n}",
        "base_ast": "type id( id, type id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type id;\n  id = num;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id, id, id, num);\n  if(id == num){\n    id = num;\n    while(id = call(id, id, *(type)(id op num), num, &id, num)id == num){\n      *(type)(*(type)(id op num) op (type)id) = num;\n      if(id == num){\n        id = &id;\n      }else{\n        id = (type)(*(type)(id op num) op (type)id);\n      }\n      id = call(id, &id, id, id);\n      if(id == num)goto lbl;\n      id = id op num;\n    }\n    id = id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "pr_ast": "type id( id, type id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type id;\n  id = num;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id, id, id, num);\n  if(id == num){\n    id = num;\n    while(id = call(id, id, *(type)(id op num), num, &id, num)id == num){\n      *(type)(*(type)(id op num) op (type)id) = num;\n      if(id == num){\n        id = str;\n      }else{\n        id = (type)(*(type)(id op num) op (type)id);\n      }\n      id = call(id, &id, id, id);\n      if(id == num)goto lbl;\n      id = id op num;\n    }\n    id = id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 2.171875,
          "pr_ppl": 2.109375,
          "source_ast_ppl": 8.5,
          "base_ast_ppl": 4.25,
          "pr_ast_ppl": 4.375,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "PR",
          "motivation": "Candidate B accurately preserves the control flow, loop abstraction, and data access structures of the original source code, whereas Candidate A introduces a critical logical error."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "PR",
          "motivation": "Candidate B is closer to the Source intent because it retains a more straightforward structure, avoiding unnecessary variable declarations and maintaining the logical flow of the original code. While both candidates fail to perfectly match the Source, Candidate B demonstrates a better adherence to the architectural intent by preserving the essential control structures and logic without introducing extraneous complexity."
        }
      }
    ],
    "deepseek-r1": [
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(_dta_timestamp_parse_actions[lVar8 + lVar15 + 1]) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(id[id op id op num]){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 4.625,
          "pr_ppl": 4.5625,
          "source_ast_ppl": 3.015625,
          "base_ast_ppl": 3.15625,
          "pr_ast_ppl": 3.125,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "BASE",
          "motivation": "Preserving `goto` ensures that the decompiled code retains the Source's lower-level control flow, making A structurally closer to the Source's intent."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(_dta_timestamp_parse_actions[lVar8 + lVar15 + 1]) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(id[id op id op num]){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 4.625,
          "pr_ppl": 4.5625,
          "source_ast_ppl": 3.015625,
          "base_ast_ppl": 3.15625,
          "pr_ast_ppl": 3.125,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "BASE",
          "motivation": "Switch statements in Candidate A create a more natural, logical flow that mirrors human decision-making processes, unlike the if-else structure in Candidate B which is more rigid and less intuitive."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(_sav_date_parse_actions[lVar8 + lVar11 + 1]) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(id[id op id op num]){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 3.25,
          "base_ppl": 4.40625,
          "pr_ppl": 4.34375,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 3.4375,
          "pr_ast_ppl": 3.4375,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(_sav_date_parse_actions[lVar8 + lVar11 + 1]) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(id[id op id op num]){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 3.25,
          "base_ppl": 4.40625,
          "pr_ppl": 4.34375,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 3.4375,
          "pr_ast_ppl": 3.4375,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "BASE",
          "motivation": "A's use of do-while and switch statements aligns better with human cognitive patterns for control flow and decision-making."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(_sav_time_parse_actions[lVar17 + (long)cVar3 + 1]) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(id[id op (type)id op num]){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 5.375,
          "base_ppl": 5.0,
          "pr_ppl": 4.875,
          "source_ast_ppl": 4.15625,
          "base_ast_ppl": 4.09375,
          "pr_ast_ppl": 4.0625,
          "delta_ppl": -0.125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(_sav_time_parse_actions[lVar17 + (long)cVar3 + 1]) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(id[id op (type)id op num]){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 5.375,
          "base_ppl": 5.0,
          "pr_ppl": 4.875,
          "source_ast_ppl": 4.15625,
          "base_ast_ppl": 4.09375,
          "pr_ast_ppl": 4.0625,
          "delta_ppl": -0.125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "B's structure is more readable and follows semantic control flow patterns, making it more idiomatic and easier to understand for humans."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "Alright, I'm trying to figure out which of the two candidate ASTs, A or B, better preserves the architectural intent of the Source AST. The task is to compare them based on the given criteria: structural isomorphism, rejection of degradation, complexity matching, and differential analysis strategy.\n\nFirst, I'll start by understanding the Source AST. It looks quite complex with a lot of nested structures and conditionals. There are loops, condition checks, and function calls. The key point is that it uses 'goto' which is considered less preferable due to its jump nature.\n\nNow, looking at Candidates A and B. Both have similar structures but with some differences. I notice that both A and B have a similar main loop structure, but the way they handle the inner loops and conditionals might differ.\n\nIn the differential analysis, I need to find where A and B differ from the Source. Let me go step by step.\n\n1. **Main Loop Structure**: Both A and B have a do-while loop that seems to handle similar operations. They both have a similar setup with 'id = id' and a call to a function. So, the main loop structure is preserved.\n\n2. **Inner Loops and Conditionals**: Here, I see that both A and B have a do-while loop inside the main loop. The way they handle the conditionals inside might differ. For example, in Candidate A, there's a switch statement that checks for various cases, while in Candidate B, the switch seems to have similar cases but the handling might be different.\n\n3. **Function Calls and Returns**: Both A and B have function calls and returns, but the way they handle the parameters might differ. In A, the function call is 'call(id, (id), str, (type)id, (type)id, id)', whereas in B, it's similar but I need to check the exact parameters.\n\n4. **Handling of 'goto'**: Since the Source uses 'goto', which is considered bad practice, the winner should keep 'goto' if it's used correctly. Looking at both candidates, they both have 'goto' in their code, albeit in different places. However, in the differential analysis, if one candidate converts 'goto' to a more structured flow, that would be a failure.\n\n5. **Complexity Matching**: The Source is nested, so the winner should also be nested. Both A and B seem to maintain a similar level of nesting, so this criterion isn't the deciding factor.\n\n6. **Reject Degradation**: Both A and B should not be transforming high-level structures into lower-level ones like if-else chains or while loops with break. From the code, it seems both are maintaining the original control flow, so this criterion isn't violated.\n\n7. **Abstraction Matching**: Both A and B should preserve the switch and for structures from the Source. The Source has 'switch' and 'for' structures, and both candidates maintain these, so this criterion is met.\n\n8. **Penalty for Hallucinatory Wrappers**: If either candidate adds unnecessary wrappers, that's a penalty. Looking at both, they don't seem to have excessive wrappers, so this isn't an issue.\n\nNow, focusing on differential analysis, I need to pinpoint where A and B differ from the Source. Let me look for specific code snippets.\n\nIn the inner loop of the main loop, both A and B have similar do-while structures. However, in Candidate A, there's a switch statement that checks for 'num', 'id[id]', and other cases. In Candidate B, the switch seems to have the same cases but the handling might be slightly different. For example, in A, after the switch, there's a call to 'call(id, num, str, id op num, id op num, id)', whereas in B, it's similar but the parameters might be handled differently.\n\nAnother point is in the handling of 'id[id]'. In A, there's a condition 'if(id[id] != num)' which leads to a function call, whereas in B, the condition is similar but the function call might have different parameters.\n\nAlso, in the return statement, both have 'return id;' but the way they reach 'id' might differ slightly due to the different handling of the inner loops.\n\nConsidering all these points, both A and B are preserving the Source's structure quite well. However, since the Source uses 'goto', and both A and B have 'goto' in their code, they are both correctly handling that aspect.\n\nBut looking deeper, in the differential analysis, if one candidate has a structure that doesn't mirror the Source, that would be a failure. Both A and B seem to mirror the Source in terms of control flow and structure.\n\nHowever, considering the complexity matching, both are nested, so that's fine. The reject degradation criterion is also met as both maintain high-level structures.\n\nIn terms of differential analysis, the specific divergence might be in the way the inner loops handle the 'switch' statements or the function calls. But without more detailed code analysis, it's hard to pinpoint exactly where they differ.\n\nGiven that both A and B are structurally similar and preserve the Source's architecture, but since the task is to determine which one better preserves the architectural intent, and both are maintaining the necessary structures, I might need to look for other subtle differences.\n\nPerhaps the way they handle 'goto' is similar, but if one uses it correctly and the other doesn't, that would matter. However, both seem to use 'goto' appropriately.\n\nIn conclusion, both A and B seem to preserve the Source's architecture well. But since the task is to choose the winner, and both are equally good in structural isomorphism, maybe there's another criterion I'm missing.\n\nWait, the problem statement mentions that the winner should mirror the topological shape of the Source AST. Both A and B do that. The reject degradation is met. Complexity matching is met. So, perhaps the winner is determined by which one is closer in structure to the Source.\n\nBut since both A and B are similar, maybe the answer is that both are equally good, but the problem expects one. Alternatively, perhaps one has a more accurate preservation of the Source's structure in terms of control flow.\n\nLooking back, in the differential analysis, if one candidate has a structure that doesn't match the Source, that's a failure. Both A and B seem to match.\n\nAlternatively, maybe the way they handle the 'call' statements is different. In A, the call is 'call(id, num, str, id op num, id op num, id)', whereas in B, it's similar but perhaps the parameters are handled differently.\n\nBut without more detailed code analysis, it's hard to say. However, considering the problem statement, the winner is the one that mirrors the Source's topological shape, which both A and B do.\n\nBut since the problem expects one winner, perhaps the answer is that both are equally good, but the problem expects to choose one. Alternatively, maybe one is better in preserving the 'goto' structure.\n\nWait, in the differential analysis, if one candidate uses 'goto' correctly and the other doesn't, that's a failure. Both A and B use 'goto' in their code, so that's not the deciding factor.\n\nPerhaps the answer is that both are equally good, but the problem expects to choose one. Alternatively, maybe the winner is determined by which one has fewer unnecessary wrappers or is more efficient.\n\nBut the problem statement says to choose the one that better preserves the architectural intent. Since both are structurally isomorphic and meet all the criteria, perhaps the answer is that both are equally good, but the problem expects to choose one.\n\nBut the problem says to output only one JSON with 'winner', so I need to decide between A and B.\n\nGiven that both are equally good, but perhaps the answer is that both are equally good, but the problem expects one. Alternatively, maybe the winner is determined by which one has a more accurate preservation of the Source's structure in terms of control flow.\n\nAlternatively, perhaps the winner is determined by which one has a more accurate handling of the 'switch' statements or the 'call' functions.\n\nBut without more detailed code analysis, it's hard to say. However, considering that both are structurally isomorphic and meet all the criteria, perhaps the answer is that both are equally good, but the problem expects to choose one.\n\nBut the problem expects to choose one, so perhaps the answer is that both are equally good, but the winner is A.\n\nAlternatively, perhaps the winner is determined by which one has a more accurate preservation of the Source's structure in terms of control flow.\n\nBut given the problem statement, the winner is the one that mirrors the Source's topological shape, which both do. Therefore, both are equally good, but the problem expects to choose one.\n\nAlternatively, perhaps the winner is determined by which one has a more accurate preservation of the Source's structure in terms of control flow.\n\nBut given the problem statement, the winner is the one that mirrors the Source's topological shape, which both do. Therefore, both are equally good, but the problem expects to choose one.\n\nBut the problem expects to choose one, so perhaps the answer is that both are equally good, but the winner is A.\n\nAlternatively, perhaps the winner is determined by which one has a more accurate preservation of the Source's structure in terms of control flow.\n\nBut given the problem statement, the winner is the one that mirrors the Source's topological shape, which both do. Therefore, both are equally good, but the problem expects to choose one.\n\nBut the problem expects to choose one, so perhaps the answer is that both are equally good, but the winner is A.\n\nAlternatively, perhaps the winner is determined by which one has a more accurate preservation of the Source's structure in terms of control flow.\n\nBut given the problem statement, the winner is the one that mirrors the Source's topological"
        }
      },
      {
        "binary": "task-file_file_replace-O0.so",
        "function": "file_replace",
        "source_code": "file_protected int\nfile_replace(struct magic_set *ms, const char *pat, const char *rep)\n{\n\tfile_regex_t rx;\n\tint rc, rv = -1;\n\n\trc = file_regcomp(ms, &rx, pat, REG_EXTENDED);\n\tif (rc == 0) {\n\t\tregmatch_t rm;\n\t\tint nm = 0;\n\t\twhile (file_regexec(ms, &rx, ms->o.buf, 1, &rm, 0) == 0) {\n\t\t\tms->o.buf[rm.rm_so] = '\\0';\n\t\t\tif (file_printf(ms, \"%s%s\", rep,\n\t\t\t    rm.rm_eo != 0 ? ms->o.buf + rm.rm_eo : \"\") == -1)\n\t\t\t\tgoto out;\n\t\t\tnm++;\n\t\t}\n\t\trv = nm;\n\t}\nout:\n\tfile_regfree(&rx);\n\treturn rv;\n}\n",
        "function_base": "\nint file_replace(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  undefined *local_90;\n  int local_74;\n  int local_70;\n  int local_6c;\n  int local_68;\n  int local_64;\n  undefined1 local_60 [64];\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_68 = -1;\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_64 = file_regcomp(param_1,local_60,param_2,1);\n  if (local_64 == 0) {\n    local_74 = 0;\n    while (iVar1 = file_regexec(local_10,local_60,*(undefined8 *)(local_10 + 0x20),1,&local_70,0),\n          iVar1 == 0) {\n      *(undefined1 *)(*(long *)(local_10 + 0x20) + (long)local_70) = 0;\n      if (local_6c == 0) {\n        local_90 = &DAT_0010201c;\n      }\n      else {\n        local_90 = (undefined *)(*(long *)(local_10 + 0x20) + (long)local_6c);\n      }\n      iVar1 = file_printf(local_10,&DAT_00102098,local_20,local_90);\n      if (iVar1 == -1) goto LAB_0010189e;\n      local_74 = local_74 + 1;\n    }\n    local_68 = local_74;\n  }\nLAB_0010189e:\n  file_regfree(local_60);\n  return local_68;\n}\n\n",
        "function_pr": "\nint file_replace(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  char *local_90;\n  int local_74;\n  int local_70;\n  int local_6c;\n  int local_68;\n  int local_64;\n  undefined1 local_60 [64];\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_68 = -1;\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_64 = file_regcomp(param_1,local_60,param_2,1);\n  if (local_64 == 0) {\n    local_74 = 0;\n    while (iVar1 = file_regexec(local_10,local_60,*(undefined8 *)(local_10 + 0x20),1,&local_70,0),\n          iVar1 == 0) {\n      *(undefined1 *)(*(long *)(local_10 + 0x20) + (long)local_70) = 0;\n      if (local_6c == 0) {\n        local_90 = \"\";\n      }\n      else {\n        local_90 = (char *)(*(long *)(local_10 + 0x20) + (long)local_6c);\n      }\n      iVar1 = file_printf(local_10,&DAT_00102098,local_20,local_90);\n      if (iVar1 == -1) goto LAB_0010189e;\n      local_74 = local_74 + 1;\n    }\n    local_68 = local_74;\n  }\nLAB_0010189e:\n  file_regfree(local_60);\n  return local_68;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id;\n  type id, , id = num;\n  id = call(id, &id, id, id);\n  if(id == num){\n    type id;\n    type id = num;\n    while(call(id, &id, id->id.id, num, &id, num) == num){\n      id->id.id[id.id] = str;\n      if(call(id, str, id, (id.id != num ? id->id.id op id.id : str)) == num)goto lbl;\n      id upd;\n    }\n    id = id;\n  }\n  lbl:\n  call(&id);\n  return id;\n}",
        "base_ast": "type id( id, type id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type id;\n  id = num;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id, id, id, num);\n  if(id == num){\n    id = num;\n    while(id = call(id, id, *(type)(id op num), num, &id, num)id == num){\n      *(type)(*(type)(id op num) op (type)id) = num;\n      if(id == num){\n        id = &id;\n      }else{\n        id = (type)(*(type)(id op num) op (type)id);\n      }\n      id = call(id, &id, id, id);\n      if(id == num)goto lbl;\n      id = id op num;\n    }\n    id = id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "pr_ast": "type id( id, type id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type id;\n  id = num;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id, id, id, num);\n  if(id == num){\n    id = num;\n    while(id = call(id, id, *(type)(id op num), num, &id, num)id == num){\n      *(type)(*(type)(id op num) op (type)id) = num;\n      if(id == num){\n        id = str;\n      }else{\n        id = (type)(*(type)(id op num) op (type)id);\n      }\n      id = call(id, &id, id, id);\n      if(id == num)goto lbl;\n      id = id op num;\n    }\n    id = id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "metrics": {
          "source_ppl": 18.625,
          "base_ppl": 6.9375,
          "pr_ppl": 6.53125,
          "source_ast_ppl": 18.875,
          "base_ast_ppl": 6.9375,
          "pr_ast_ppl": 7.0625,
          "delta_ppl": -0.40625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      }
    ],
    "llama3.1": [
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(_dta_timestamp_parse_actions[lVar8 + lVar15 + 1]) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(id[id op id op num]){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 2.734375,
          "pr_ppl": 2.671875,
          "source_ast_ppl": 2.25,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.453125,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(_dta_timestamp_parse_actions[lVar8 + lVar15 + 1]) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(id[id op id op num]){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 2.734375,
          "pr_ppl": 2.671875,
          "source_ast_ppl": 2.25,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.453125,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(_sav_date_parse_actions[lVar8 + lVar11 + 1]) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(id[id op id op num]){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8671875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.59375,
          "source_ast_ppl": 2.3125,
          "base_ast_ppl": 2.609375,
          "pr_ast_ppl": 2.578125,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(_sav_date_parse_actions[lVar8 + lVar11 + 1]) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(id[id op id op num]){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8671875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.59375,
          "source_ast_ppl": 2.3125,
          "base_ast_ppl": 2.609375,
          "pr_ast_ppl": 2.578125,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "winner": "BASE",
          "motivation": "Candidate A's use of a `do-while` loop makes the code more human-like by avoiding unnecessary checks and providing a clear exit condition."
        },
        "llm_qualitative_source": {
          "winner": "BASE",
          "motivation": "Candidate A's direct and straightforward approach is more faithful to the original source code's logic patterns, making it easier to understand and maintain."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "PR",
          "motivation": "B preserves the switch statement and while loop, making it structurally closer to the Source intent."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(_sav_time_parse_actions[lVar17 + (long)cVar3 + 1]) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(id[id op (type)id op num]){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.421875,
          "base_ppl": 2.703125,
          "pr_ppl": 2.671875,
          "source_ast_ppl": 2.9375,
          "base_ast_ppl": 2.890625,
          "pr_ast_ppl": 2.875,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "BASE",
          "motivation": "Candidate A is closer to the Source intent because it preserves the original complexity of the if statement, which may be an attempt to maintain the original logic."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(_sav_time_parse_actions[lVar17 + (long)cVar3 + 1]) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(id[id op (type)id op num]){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.421875,
          "base_ppl": 2.703125,
          "pr_ppl": 2.671875,
          "source_ast_ppl": 2.9375,
          "base_ast_ppl": 2.890625,
          "pr_ast_ppl": 2.875,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "PR",
          "motivation": "Candidate B's use of a traditional `switch` statement with a loop is more human-like because it is easier to understand and maintain, as the logic is more linear and less prone to errors."
        },
        "llm_qualitative_source": {
          "winner": "PR",
          "motivation": "Candidate B successfully recovers the logic patterns written by the original human developer by maintaining a consistent use of switch statements and loops, while minimizing the use of goto statements."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "The grouped if statements in Candidate B reduce the nesting depth and improve the overall readability of the code."
        },
        "llm_ast_source": {
          "error": "Extra data: line 5 column 1 (char 168)"
        }
      },
      {
        "binary": "task-file_file_replace-O0.so",
        "function": "file_replace",
        "source_code": "file_protected int\nfile_replace(struct magic_set *ms, const char *pat, const char *rep)\n{\n\tfile_regex_t rx;\n\tint rc, rv = -1;\n\n\trc = file_regcomp(ms, &rx, pat, REG_EXTENDED);\n\tif (rc == 0) {\n\t\tregmatch_t rm;\n\t\tint nm = 0;\n\t\twhile (file_regexec(ms, &rx, ms->o.buf, 1, &rm, 0) == 0) {\n\t\t\tms->o.buf[rm.rm_so] = '\\0';\n\t\t\tif (file_printf(ms, \"%s%s\", rep,\n\t\t\t    rm.rm_eo != 0 ? ms->o.buf + rm.rm_eo : \"\") == -1)\n\t\t\t\tgoto out;\n\t\t\tnm++;\n\t\t}\n\t\trv = nm;\n\t}\nout:\n\tfile_regfree(&rx);\n\treturn rv;\n}\n",
        "function_base": "\nint file_replace(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  undefined *local_90;\n  int local_74;\n  int local_70;\n  int local_6c;\n  int local_68;\n  int local_64;\n  undefined1 local_60 [64];\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_68 = -1;\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_64 = file_regcomp(param_1,local_60,param_2,1);\n  if (local_64 == 0) {\n    local_74 = 0;\n    while (iVar1 = file_regexec(local_10,local_60,*(undefined8 *)(local_10 + 0x20),1,&local_70,0),\n          iVar1 == 0) {\n      *(undefined1 *)(*(long *)(local_10 + 0x20) + (long)local_70) = 0;\n      if (local_6c == 0) {\n        local_90 = &DAT_0010201c;\n      }\n      else {\n        local_90 = (undefined *)(*(long *)(local_10 + 0x20) + (long)local_6c);\n      }\n      iVar1 = file_printf(local_10,&DAT_00102098,local_20,local_90);\n      if (iVar1 == -1) goto LAB_0010189e;\n      local_74 = local_74 + 1;\n    }\n    local_68 = local_74;\n  }\nLAB_0010189e:\n  file_regfree(local_60);\n  return local_68;\n}\n\n",
        "function_pr": "\nint file_replace(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  char *local_90;\n  int local_74;\n  int local_70;\n  int local_6c;\n  int local_68;\n  int local_64;\n  undefined1 local_60 [64];\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_68 = -1;\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_64 = file_regcomp(param_1,local_60,param_2,1);\n  if (local_64 == 0) {\n    local_74 = 0;\n    while (iVar1 = file_regexec(local_10,local_60,*(undefined8 *)(local_10 + 0x20),1,&local_70,0),\n          iVar1 == 0) {\n      *(undefined1 *)(*(long *)(local_10 + 0x20) + (long)local_70) = 0;\n      if (local_6c == 0) {\n        local_90 = \"\";\n      }\n      else {\n        local_90 = (char *)(*(long *)(local_10 + 0x20) + (long)local_6c);\n      }\n      iVar1 = file_printf(local_10,&DAT_00102098,local_20,local_90);\n      if (iVar1 == -1) goto LAB_0010189e;\n      local_74 = local_74 + 1;\n    }\n    local_68 = local_74;\n  }\nLAB_0010189e:\n  file_regfree(local_60);\n  return local_68;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id;\n  type id, , id = num;\n  id = call(id, &id, id, id);\n  if(id == num){\n    type id;\n    type id = num;\n    while(call(id, &id, id->id.id, num, &id, num) == num){\n      id->id.id[id.id] = str;\n      if(call(id, str, id, (id.id != num ? id->id.id op id.id : str)) == num)goto lbl;\n      id upd;\n    }\n    id = id;\n  }\n  lbl:\n  call(&id);\n  return id;\n}",
        "base_ast": "type id( id, type id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type id;\n  id = num;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id, id, id, num);\n  if(id == num){\n    id = num;\n    while(id = call(id, id, *(type)(id op num), num, &id, num)id == num){\n      *(type)(*(type)(id op num) op (type)id) = num;\n      if(id == num){\n        id = &id;\n      }else{\n        id = (type)(*(type)(id op num) op (type)id);\n      }\n      id = call(id, &id, id, id);\n      if(id == num)goto lbl;\n      id = id op num;\n    }\n    id = id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "pr_ast": "type id( id, type id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type id;\n  id = num;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id, id, id, num);\n  if(id == num){\n    id = num;\n    while(id = call(id, id, *(type)(id op num), num, &id, num)id == num){\n      *(type)(*(type)(id op num) op (type)id) = num;\n      if(id == num){\n        id = str;\n      }else{\n        id = (type)(*(type)(id op num) op (type)id);\n      }\n      id = call(id, &id, id, id);\n      if(id == num)goto lbl;\n      id = id op num;\n    }\n    id = id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.984375,
          "base_ppl": 2.640625,
          "pr_ppl": 2.546875,
          "source_ast_ppl": 10.4375,
          "base_ast_ppl": 4.65625,
          "pr_ast_ppl": 4.8125,
          "delta_ppl": -0.09375
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "BASE",
          "motivation": "Candidate A maintains the original logic patterns, including the use of `while` loops and `if` statements, making it easier to understand and maintain."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "BASE",
          "motivation": "Candidate A's goto statements are used in the same context as the Source, making it a better representation of the architectural intent."
        }
      }
    ],
    "gemma2": [
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(_dta_timestamp_parse_actions[lVar8 + lVar15 + 1]) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(id[id op id op num]){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.4921875,
          "base_ppl": 2.25,
          "pr_ppl": 2.21875,
          "source_ast_ppl": 2.046875,
          "base_ast_ppl": 2.3125,
          "pr_ast_ppl": 2.3125,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(_dta_timestamp_parse_actions[lVar8 + lVar15 + 1]) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(id[id op id op num]){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.4921875,
          "base_ppl": 2.25,
          "pr_ppl": 2.21875,
          "source_ast_ppl": 2.046875,
          "base_ast_ppl": 2.3125,
          "pr_ast_ppl": 2.3125,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "PR",
          "motivation": "Candidate B's use of `for` loops and clear member access makes it significantly easier to read and understand."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(_sav_date_parse_actions[lVar8 + lVar11 + 1]) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(id[id op id op num]){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.5703125,
          "base_ppl": 2.171875,
          "pr_ppl": 2.140625,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 2.421875,
          "pr_ast_ppl": 2.421875,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(_sav_date_parse_actions[lVar8 + lVar11 + 1]) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(id[id op id op num]){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.5703125,
          "base_ppl": 2.171875,
          "pr_ppl": 2.140625,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 2.421875,
          "pr_ast_ppl": 2.421875,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(_sav_time_parse_actions[lVar17 + (long)cVar3 + 1]) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(id[id op (type)id op num]){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 2.171875,
          "pr_ppl": 2.140625,
          "source_ast_ppl": 2.59375,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.65625,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(_sav_time_parse_actions[lVar17 + (long)cVar3 + 1]) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(id[id op (type)id op num]){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 2.171875,
          "pr_ppl": 2.140625,
          "source_ast_ppl": 2.59375,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.65625,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-file_file_replace-O0.so",
        "function": "file_replace",
        "source_code": "file_protected int\nfile_replace(struct magic_set *ms, const char *pat, const char *rep)\n{\n\tfile_regex_t rx;\n\tint rc, rv = -1;\n\n\trc = file_regcomp(ms, &rx, pat, REG_EXTENDED);\n\tif (rc == 0) {\n\t\tregmatch_t rm;\n\t\tint nm = 0;\n\t\twhile (file_regexec(ms, &rx, ms->o.buf, 1, &rm, 0) == 0) {\n\t\t\tms->o.buf[rm.rm_so] = '\\0';\n\t\t\tif (file_printf(ms, \"%s%s\", rep,\n\t\t\t    rm.rm_eo != 0 ? ms->o.buf + rm.rm_eo : \"\") == -1)\n\t\t\t\tgoto out;\n\t\t\tnm++;\n\t\t}\n\t\trv = nm;\n\t}\nout:\n\tfile_regfree(&rx);\n\treturn rv;\n}\n",
        "function_base": "\nint file_replace(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  undefined *local_90;\n  int local_74;\n  int local_70;\n  int local_6c;\n  int local_68;\n  int local_64;\n  undefined1 local_60 [64];\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_68 = -1;\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_64 = file_regcomp(param_1,local_60,param_2,1);\n  if (local_64 == 0) {\n    local_74 = 0;\n    while (iVar1 = file_regexec(local_10,local_60,*(undefined8 *)(local_10 + 0x20),1,&local_70,0),\n          iVar1 == 0) {\n      *(undefined1 *)(*(long *)(local_10 + 0x20) + (long)local_70) = 0;\n      if (local_6c == 0) {\n        local_90 = &DAT_0010201c;\n      }\n      else {\n        local_90 = (undefined *)(*(long *)(local_10 + 0x20) + (long)local_6c);\n      }\n      iVar1 = file_printf(local_10,&DAT_00102098,local_20,local_90);\n      if (iVar1 == -1) goto LAB_0010189e;\n      local_74 = local_74 + 1;\n    }\n    local_68 = local_74;\n  }\nLAB_0010189e:\n  file_regfree(local_60);\n  return local_68;\n}\n\n",
        "function_pr": "\nint file_replace(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  char *local_90;\n  int local_74;\n  int local_70;\n  int local_6c;\n  int local_68;\n  int local_64;\n  undefined1 local_60 [64];\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_68 = -1;\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_64 = file_regcomp(param_1,local_60,param_2,1);\n  if (local_64 == 0) {\n    local_74 = 0;\n    while (iVar1 = file_regexec(local_10,local_60,*(undefined8 *)(local_10 + 0x20),1,&local_70,0),\n          iVar1 == 0) {\n      *(undefined1 *)(*(long *)(local_10 + 0x20) + (long)local_70) = 0;\n      if (local_6c == 0) {\n        local_90 = \"\";\n      }\n      else {\n        local_90 = (char *)(*(long *)(local_10 + 0x20) + (long)local_6c);\n      }\n      iVar1 = file_printf(local_10,&DAT_00102098,local_20,local_90);\n      if (iVar1 == -1) goto LAB_0010189e;\n      local_74 = local_74 + 1;\n    }\n    local_68 = local_74;\n  }\nLAB_0010189e:\n  file_regfree(local_60);\n  return local_68;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id;\n  type id, , id = num;\n  id = call(id, &id, id, id);\n  if(id == num){\n    type id;\n    type id = num;\n    while(call(id, &id, id->id.id, num, &id, num) == num){\n      id->id.id[id.id] = str;\n      if(call(id, str, id, (id.id != num ? id->id.id op id.id : str)) == num)goto lbl;\n      id upd;\n    }\n    id = id;\n  }\n  lbl:\n  call(&id);\n  return id;\n}",
        "base_ast": "type id( id, type id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type id;\n  id = num;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id, id, id, num);\n  if(id == num){\n    id = num;\n    while(id = call(id, id, *(type)(id op num), num, &id, num)id == num){\n      *(type)(*(type)(id op num) op (type)id) = num;\n      if(id == num){\n        id = &id;\n      }else{\n        id = (type)(*(type)(id op num) op (type)id);\n      }\n      id = call(id, &id, id, id);\n      if(id == num)goto lbl;\n      id = id op num;\n    }\n    id = id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "pr_ast": "type id( id, type id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type id;\n  id = num;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id, id, id, num);\n  if(id == num){\n    id = num;\n    while(id = call(id, id, *(type)(id op num), num, &id, num)id == num){\n      *(type)(*(type)(id op num) op (type)id) = num;\n      if(id == num){\n        id = str;\n      }else{\n        id = (type)(*(type)(id op num) op (type)id);\n      }\n      id = call(id, &id, id, id);\n      if(id == num)goto lbl;\n      id = id op num;\n    }\n    id = id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.65625,
          "base_ppl": 2.109375,
          "pr_ppl": 2.09375,
          "source_ast_ppl": 7.375,
          "base_ast_ppl": 4.15625,
          "pr_ast_ppl": 4.25,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      }
    ]
  }
}