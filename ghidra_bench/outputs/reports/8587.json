{
  "pr": "8587",
  "mean_delta_perplexity": -0.026785714285714284,
  "mean_perplexity_base": 2.0145089285714284,
  "mean_perplexity_pr": 1.9877232142857142,
  "mean_perplexity_source": 1.75,
  "mean_perplexity_base_ast": 2.7745535714285716,
  "mean_perplexity_pr_ast": 2.767857142857143,
  "mean_perplexity_source_ast": 2.7098214285714284,
  "results": {
    "qwen-3": [
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(_dta_timestamp_parse_actions[lVar8 + lVar15 + 1]) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = id - 1900;\n              }\n              break;\n            }\n          case 16:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 17:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 44)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  44;\n  id != id\n  {\n    type id[1024];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(*(type)(id + 0x102361 + id)){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(id[id + id + 1]){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 2.3125,
          "pr_ppl": 2.28125,
          "source_ast_ppl": 2.140625,
          "base_ast_ppl": 2.578125,
          "pr_ast_ppl": 2.5625,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses array indexing (_dta_timestamp_parse_actions[...]) which is a higher-level abstraction and more idiomatic in C than raw pointer arithmetic. The original code's pointer dereference (*(undefined1 *)...) is more machine-like and harder to read, while the array access better reflects logical data structure usage.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "Error",
          "motivation": "<think>\nOkay, let's tackle this problem. So, the task is to determine whether the changes in the Diff move the code closer to the Source Code structure or further away. The user is a Senior Compiler Engineer evaluating decompilation fidelity. \n\nFirst, I need to understand the DIFF provided. The lines starting with `-` are Candidate A, and `+` are Candidate B. The specific diff shows a change in a switch statement's condition. \n\nLooking at the Source Code, there's a big switch statement with multiple cases. Each case corresponds to different actions, like setting timestamp fields (tm_mday, tm_mon, etc.) based on the temp_val. The original code in the Source uses a switch on the action from _dta_timestamp_parse_actions, which is an array of actions. \n\nIn the DIFF, the line in Candidate A is: switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)). The Candidate B changes this to switch(_dta_timestamp_parse_actions[lVar8 + lVar15 + 1]). \n\nNow, the Source Code's switch is part of a loop where _acts is pointing to the actions array. The original code in the Source uses switch ( (*( _acts)) ), which is dereferencing the _acts pointer. In the decompiled code (Candidate A), the switch is using a memory address calculation, which might be a decompiler's way of representing a pointer dereference. \n\nBut Candidate B's change replaces that with a direct reference to _dta_timestamp_parse_actions array. However, in the Source Code, the actions are accessed via _acts, which is calculated as _dta_timestamp_parse_actions + ... So, the original code's switch is on the value at _acts, which is an index into the actions array. \n\nIn Candidate B, the switch is using _dta_timestamp_parse_actions[lVar8 + lVar15 + 1]. But in the Source, the code uses _dta_timestamp_parse_actions[_trans] and then _acts is set to that. The loop then iterates over _nacts, and each action is at _acts. So the switch is on the value of *(_acts), which is the action code. \n\nThe original decompiled code (Candidate A) uses a memory address calculation, which might be equivalent to dereferencing a pointer. However, Candidate B's change seems to directly index into the _dta_timestamp_parse_actions array. But in the Source Code, the actions are accessed through _acts, which is a pointer into that array. So the correct switch condition should be based on the value at _acts, not directly indexing into the array. \n\nWait, but in the Source Code, the _acts is calculated as _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]). Then, _nacts is the first element of _acts, and _acts is incremented. So each action is *(++_acts). Therefore, the switch is on the value of *(_acts), which is the action code. \n\nIn Candidate A, the switch is using a memory address: *(undefined1 *)(lVar15 + 0x102361 + lVar8). This might be a way the decompiler represents a pointer dereference. The lVar15 could be the base address, and adding an offset (0x102361 + lVar8) to get the address, then dereferencing it. \n\nIn Candidate B, the switch is _dta_timestamp_parse_actions[lVar8 + lVar15 + 1]. This is directly indexing into the array, which would be incorrect because the original code uses a pointer into the array. So, if the array is accessed via an index, that would be different from dereferencing a pointer. \n\nBut wait, the original code uses _dta_timestamp_parse_actions[_trans], which is an index into the array. However, in the loop, _acts is set to _dta_timestamp_parse_actions + ... and then the actions are read from _acts. So the switch is on the value of *(_acts), which is the same as _dta_timestamp_parse_actions[...], but the decompiler might have represented that as a direct array index. \n\nAlternatively, the decompiler might have miscalculated the pointer arithmetic. The original code's switch is on the value of *(_acts), which is the same as the array element at the current _acts position. So, if the decompiler's Candidate A is using a memory address that's equivalent to the _acts pointer, then that's correct. But Candidate B's change is using a direct array index, which might not match the original code's pointer-based access. \n\nWait, but in the Source Code, the _acts is a pointer to the actions array. So the switch is on the value at that pointer. So the correct way to represent that in decompiled code would be to dereference the pointer. However, in Candidate A, the code is using a memory address calculation, which might be equivalent to dereferencing a pointer. \n\nBut Candidate B's change is using an array index, which would be different. For example, if _acts is a pointer to the array, then *(_acts) is the same as _dta_timestamp_parse_actions[...], but the index would depend on how _acts is calculated. \n\nAlternatively, maybe the decompiler in Candidate A is using a fixed offset (0x102361) which might be a constant that represents the base of the actions array. Then, adding lVar8 (which could be the index) to that base gives the correct array index. \n\nBut the original code's _acts is calculated as _dta_timestamp_parse_actions + ... So the index into the array is _dta_timestamp_parse_cond_actions[_trans], and then _acts is that pointer. Then, the loop increments _acts, so each step is moving through the array. \n\nIn that case, the correct switch condition would be the value of the array element at the current _acts position. So, if the decompiler's Candidate A is using a fixed base plus an offset (lVar8), that might be equivalent to the array index. However, the original code's _acts is a pointer into the array, so dereferencing that pointer would be the same as the array element. \n\nBut the problem is that the decompiler's output in Candidate A uses a memory address calculation, which might be a way to represent the array index. However, Candidate B's change is using a direct array index, which could be more accurate. \n\nWait, but in the Source Code, the switch is on the value of *(_acts), which is the same as the array element at the current _acts index. So, if the decompiler's Candidate B is using _dta_timestamp_parse_actions[lVar8 + lVar15 + 1], that would be equivalent to accessing the array at that index. However, the original code's _acts is a pointer into the array, so the index would be lVar15 + lVar8 + 1. \n\nBut I'm not sure. The key is to compare the structure. The Source Code uses a switch statement, and the decompiled code should preserve that. \n\nIn the original code (Candidate A), the switch is on a dereferenced pointer. In Candidate B, the switch is on an array index. Which one is closer to the Source Code's structure?\n\nIn the Source Code, the switch is on the value of *(_acts), which is the same as the array element. So, the correct way to represent that in decompiled code would be to use the array index. However, if the decompiler's Candidate A is using a pointer dereference (which is equivalent to array access), then that's correct. \n\nBut the way the decompiler represents it might differ. For example, if the array is accessed via a pointer, the decompiler might show it as a dereference, or as an array index. \n\nIn this case, the original code's switch is on the value of *(_acts), which is the same as the array element. So, the correct decompiled code would have a switch on that value. \n\nIn Candidate A, the switch is using a memory address calculation, which might be equivalent to the array index. For example, if lVar15 is the base of the array, and 0x102361 is an offset, then adding lVar8 (the index) would give the correct array element. \n\nBut in Candidate B, the switch is using _dta_timestamp_parse_actions[lVar8 + lVar15 + 1], which is a direct array index. However, the original code's _acts is calculated as _dta_timestamp_parse_actions + ... So, the index into the array would be lVar15 + lVar8 + 1. \n\nWait, but in the original code, the _acts is set to _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]). Then, _nacts is the first element of _acts, and _acts is incremented. So, the loop is processing each action in the array. \n\nIn that case, the switch is on the value of *(_acts), which is the same as _dta_timestamp_parse_actions[...], where ... is the current index. \n\nSo, if the decompiler's Candidate B is using a direct array index, that would be correct. However, Candidate A's code uses a pointer dereference, which is also correct. \n\nBut the problem is that the decompiler might have different ways of representing the same thing. For example, if the array is accessed via a pointer, the decompiler might show it as a dereference or as an array index. \n\nIn"
        },
        "llm_ast": {
          "motivation": "Candidate B avoids the use of a hexadecimal magic number (0x102361) in the switch condition, which is a concrete, machine-specific detail. Instead, it uses a relative expression based on the variable 'id', which is more abstract and aligns with human-readable logic. While both use a switch statement (a semantic structure), Candidate B's expression is less tied to low-level memory addressing, improving readability and idiomatic design.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "Candidate A preserves the original switch expression present in the Source AST, which includes the specific pointer dereference with a hexadecimal offset. Candidate B modifies this expression to a different calculation, diverging from the Source's structure.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(_dta_timestamp_parse_actions[lVar8 + lVar15 + 1]) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = id - 1900;\n              }\n              break;\n            }\n          case 16:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 17:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 44)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  44;\n  id != id\n  {\n    type id[1024];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(*(type)(id + 0x102361 + id)){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(id[id + id + 1]){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 2.3125,
          "pr_ppl": 2.28125,
          "source_ast_ppl": 2.140625,
          "base_ast_ppl": 2.578125,
          "pr_ast_ppl": 2.5625,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses an array reference with a descriptive name (_dta_timestamp_parse_actions) and a calculated index, which abstracts the memory access into a higher-level data structure. This aligns with human engineering by avoiding raw pointer arithmetic (0x102361) and magic numbers, making the code's intent clearer while maintaining the same switch-based control flow structure.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns with the Source Code structure by using the array name '_dta_timestamp_parse_actions' with an explicit index calculation, matching the original source's use of action tables. Candidate A's memory address arithmetic (0x102361) obscures the array reference, diverging from the source's explicit array access pattern.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate B avoids a hexadecimal offset (0x102361), which is a concrete, machine-specific value, and instead uses a variable-based calculation (id + id + 1). This aligns better with human-like abstraction by reducing reliance on magic numbers, even though both expressions are complex. The switch statement itself remains a semantic structure, and Candidate B's condition is less tied to low-level memory addressing.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(_sav_date_parse_actions[lVar8 + lVar11 + 1]) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                type id = ((((*(id)))) - str);\n                if(id >= 0 && id <= 9){\n                  id = 10 * id + id;\n                }\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                if(id < 70){\n                  id->id = 100 + id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 47)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  47;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(*(type)(id + 0x102311 + id)){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(id[id + id + 1]){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.9140625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.640625,
          "pr_ast_ppl": 2.59375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a named array (_sav_date_parse_actions) with a simplified index expression, which is more readable and idiomatic in C. The original pointer arithmetic with a magic offset (0x102311) is harder to interpret, while the array access abstracts the memory layout into a structured data reference, aligning better with human-readable abstractions.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns with the Source Code structure by maintaining the use of the _sav_date_parse_actions array, which matches the original code's switch expression based on action codes stored in this array. Candidate A's memory address calculation diverges from the source's explicit array reference.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "<think>\nOkay, let's tackle this problem. The user wants me to evaluate which candidate, A or B, has a better idiomatic design based on the control flow structure. \n\nFirst, I need to look at the diff provided. The key part is the switch statement. In Candidate A, the switch is using a pointer dereference with a complex expression: *(type)(id + 0x102311 + id). That seems a bit messy. The cast to (type) might be necessary, but the expression inside is adding id twice and an offset. It's a bit hard to read and understand the intent here.\n\nIn Candidate B, the switch is written as id[id + id + 1]. Wait, that's an array access. But id is probably a pointer here, so this is dereferencing a pointer at an offset. The expression inside is id + id + 1, which simplifies to 2*id +1. But the original in A was id + 0x102311 + id, which is 2*id + 0x102311. So Candidate B's expression is id[id + id + 1], which is equivalent to *(id + 2*id +1) if id is a pointer. But the original in A had 0x102311 added. Wait, the original in A was *(type)(id + 0x102311 + id). So that's adding id and 0x102311. So the expression is id + 0x102311 + id = 2*id + 0x102311. But Candidate B's expression is id + id + 1, which is 2*id +1. So the offset is different. But maybe the actual value is different, but the question is about the structure, not the logic.\n\nWait, the problem says that if the logic is identical, then choose the one with less nesting. But here, the logic might not be identical. However, the user's instruction says that the judge should decide if the structural changes improve idiomatic design. \n\nLooking at the switch statement's condition. In Candidate A, the expression is a cast to (type) and then dereferencing. The expression inside is a bit complex with adding id and an offset. In Candidate B, it's written as an array access, which might be more readable if id is a pointer. But the expression inside the array is id + id + 1, which is 2*id +1. But in the original, it's 2*id + 0x102311. So the actual value is different. However, the problem says that the user is evaluating structural changes in the AST, not the actual logic. Wait, but the user says that if the logic is identical, then choose the one with less nesting. But here, the logic is different. So maybe the question is about the structure of the code, not the actual computation.\n\nBut the main point is about idiomatic control flow. The switch statement itself is a semantic structure, which is good. But the expression inside the switch: in Candidate A, the expression is a bit more complex with a cast and adding an offset. In Candidate B, it's written as an array access. However, array access syntax might be more readable if id is a pointer. For example, if id is a pointer to an array, then id[id + id + 1] is equivalent to *(id + id + id + 1) = *(id * 2 + 1 + id?), wait no. Wait, id is a pointer. So id + id would be adding the pointer to itself, but that's not standard. Wait, in C, if id is a pointer, then id + 1 would be adding the size of the type. But in the code, the expression is written as id + id + 1. Wait, but in C, adding pointers is not allowed. So maybe this is a typo or a mistake. Wait, but the original code in Candidate A is *(type)(id + 0x102311 + id). So adding id (a pointer) and 0x102311 (an integer), which is allowed. So in Candidate B, the expression is id[id + id + 1]. But if id is a pointer, then id + id would be adding two pointers, which is invalid. Wait, that can't be right. So perhaps there's a mistake here. Alternatively, maybe id is an integer, and the code is using it as an array index. But that's a bit unclear.\n\nAlternatively, maybe the code in Candidate B is using array subscript notation, which is equivalent to pointer dereferencing. So, for example, id[id + id + 1] is equivalent to *(id + id + id + 1) if id is a pointer. Wait, no. The array subscript operator in C is defined as *(base + index). So id[id + id + 1] is equivalent to *(id + (id + id + 1)) = *(id + 2*id + 1). But in Candidate A, the expression is id + 0x102311 + id = 2*id + 0x102311. So the difference is that Candidate B uses 2*id + 1 instead of 2*id + 0x102311. So the actual logic is different. However, the problem says that the user is to evaluate the structural changes in the AST. But the user's instruction says that the judge should decide if the difference makes the code more like a human (abstract) or more like a machine (concrete). \n\nSo, the switch statement is a semantic structure (good), but the expression inside. In Candidate A, the expression is a bit more complex with a cast and an offset. In Candidate B, the expression is written as an array access, which might be more readable if the intention is to access an array element. However, the actual expression inside the switch is different. But the problem says that the user is to evaluate the structural changes in the AST. However, the user's instruction says that the only hierarchy is idiomatic control flow. So the structure of the code, like using for loops, switch, etc., is more important than the actual expressions. \n\nWait, but the expressions themselves are part of the control flow. However, the user's priority is semantic structures (like switch, for loops) over graph artifacts. So the presence of a switch is good. But the expressions inside the switch are part of the condition. However, the user's tie-breaker is if the logic is identical, choose the one with less nesting. But here, the logic is different. So perhaps the main point is that Candidate B's switch condition is written in a way that's more idiomatic. For example, using array subscript notation might be more readable than a cast and pointer arithmetic. However, the actual expression is different. But the user's instruction says that the judge should decide if the difference makes the code more like a human or machine. \n\nIf Candidate B uses array subscript notation, which is a more common way to express pointer dereferencing in C, then it might be more human-like. Whereas Candidate A uses a cast and pointer arithmetic, which might be more low-level. However, the actual expression in Candidate B is different. But the problem says that the user is to evaluate the structural changes. So perhaps the main point is that Candidate B uses a more idiomatic expression (array subscript) instead of a cast and pointer arithmetic. \n\nAlternatively, the original code in Candidate A might be using a cast to (type) to dereference a pointer, which is a bit of a hack. Whereas Candidate B uses array subscript notation, which is a more standard way to access a pointer's value. So even though the actual value is different, the structure is more idiomatic. \n\nBut the problem says that the user is to evaluate the structural changes in the AST. The AST would represent the structure of the code. So the switch statement is a semantic structure. The expressions inside the switch are part of the condition. However, the user's priority is semantic structures over graph artifacts. \n\nIn this case, both candidates have a switch statement, which is good. The difference is in the condition. But the user's tie-breaker is if the logic is identical, choose the one with less nesting. However, here the logic is different. Therefore, the user's instruction says that the judge should decide if the difference makes the code more human-like. \n\nIf Candidate B's expression is more readable (array subscript) than Candidate A's (cast and pointer arithmetic), then Candidate B is more human-like. However, the actual value is different. But the problem says that the user is to evaluate the structural changes. So perhaps the main point is that Candidate B uses a more idiomatic expression. \n\nAlternatively, the original code in Candidate A might have a typo or mistake. For example, the expression in Candidate A is id + 0x102311 + id, which is 2*id + 0x102311. But in Candidate B, it's id + id + 1, which is 2*id +1. So the offset is different. However, the user's instruction says that the judge should not consider the actual logic but the structural changes. \n\nBut the user's instruction says that the judge should decide if the difference makes the code more like a human (abstract) or more like a machine (concrete). So if Candidate B's expression is more readable (array subscript) than Candidate A's (cast and"
        },
        "llm_ast_source": {
          "motivation": "Candidate B's switch expression (id[id + id + 1]) aligns more closely with the original Source's switch structure (dereferencing a pointer) compared to Candidate A's complex pointer arithmetic. The nesting depth and use of pointer dereferencing in B better reflect the Source's topology.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(_sav_date_parse_actions[lVar8 + lVar11 + 1]) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                type id = ((((*(id)))) - str);\n                if(id >= 0 && id <= 9){\n                  id = 10 * id + id;\n                }\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                if(id < 70){\n                  id->id = 100 + id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 47)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  47;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(*(type)(id + 0x102311 + id)){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(id[id + id + 1]){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.9140625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.640625,
          "pr_ast_ppl": 2.59375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a named array (_sav_date_parse_actions) with an index calculation, which is more semantically meaningful and abstracts away the raw memory address arithmetic. This aligns with human engineering practices by replacing a low-level pointer dereference (with a magic offset 0x102311) with a structured array access, improving readability and maintainability.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B uses the _sav_date_parse_actions array directly, which aligns with the source code's generated parser structure where actions are stored in a table. The original Candidate A's memory address calculation (lVar11 + 0x102311 + lVar8) is obfuscated and does not match the source's explicit use of _sav_date_parse_actions. The switch in B preserves the array-based action lookup pattern present in the source code.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate B simplifies the switch condition by removing the hexadecimal offset (0x102311) and replacing it with a more straightforward array access expression (id[id + id + 1]). This reduces the use of machine-like constants and pointer arithmetic, aligning closer to idiomatic, human-readable code structures.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(_sav_time_parse_actions[lVar17 + (long)cVar3 + 1]) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = (((*(id)))) - str;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 12)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  12;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(*(type)((type)id + 0x1020c9 + id)){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(id[id + (type)id + 1]){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.5625,
          "base_ppl": 2.328125,
          "pr_ppl": 2.28125,
          "source_ast_ppl": 2.703125,
          "base_ast_ppl": 3.25,
          "pr_ast_ppl": 3.171875,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses an array lookup (_sav_time_parse_actions) with a calculated index, which aligns with idiomatic data structure access patterns. This abstracts the memory access into a named array, improving readability compared to Candidate A's raw memory address arithmetic (0x1020c9 + lVar17). Both use switch statements, but B's approach better reflects high-level data abstraction.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "<think>\nOkay, let's dive into this AST diff analysis. The goal is to determine which candidate, A or B, has a more idiomatic control flow structure based on the given hierarchy. \n\nFirst, looking at the code snippets provided. The original code in Candidate A has a switch statement inside a do-while loop. The switch is using a somewhat complex expression: *(type)((type)id + 0x1020c9 + id). This seems a bit convoluted. The address calculation here is adding id to 0x1020c9 and then casting to a type, then dereferencing. That's a bit of a mouthful and might be hard to follow.\n\nIn Candidate B, the switch expression is changed to id[id + (type)id + 1]. Let me parse that. The expression inside the brackets is id plus (type)id plus 1. Wait, but id is being used as an array index here. So, it's accessing an element at index (id + (type)id + 1) of the id array. Hmm. But the original code was using a pointer arithmetic approach. \n\nNow, considering the idiomatic structures. The switch statement itself is a semantic structure, so both candidates use that. The question is about the expressions inside the switch. \n\nCandidate A's expression is a pointer dereference with a complex offset. The 0x1020c9 is a hexadecimal constant, which might be a memory address or an offset. The calculation (type)id + 0x1020c9 + id could be trying to access a specific memory location, but the syntax is a bit unclear. The cast to (type) might be necessary for pointer arithmetic, but it's a bit messy.\n\nCandidate B's expression is id[id + (type)id + 1]. Here, id is treated as an array, and the index is calculated as id (the variable) plus (type)id (which is the same as id, but cast to a type) plus 1. Wait, that seems redundant. If id is of a type that can be cast to a type, then (type)id is the same as id. So the index becomes id + id + 1, which is 2*id +1. But that's a bit strange. However, the original code's expression was (type)id + 0x1020c9 + id. If id is a pointer, then adding 0x1020c9 would be a specific offset. But in Candidate B, the expression is using array indexing, which might be more readable if the intention is to access an array element. However, the original code might have been accessing a memory location via pointer arithmetic, which is common in C for things like structs or unions.\n\nBut the key here is to determine which is more idiomatic. The original code uses pointer arithmetic with a hexadecimal offset, which is common in low-level code, perhaps accessing a struct's field or a specific memory location. However, the expression in Candidate B is using array indexing, which might be more readable if the data structure is an array. However, the expression inside the brackets in Candidate B is id + (type)id + 1. If id is a pointer, then adding (type)id (which is a cast) might not make sense. Wait, maybe the original code was trying to access a struct's member via a pointer, and Candidate B is trying to do it via array indexing, but the calculation is different. \n\nAlternatively, maybe the original code's expression is a bit more complex and less readable. The hexadecimal offset 0x1020c9 is a magic number, which is not self-explanatory. In contrast, Candidate B's expression uses id + (type)id + 1. But if id is a pointer, then adding id to itself would be a large offset, which might not be intended. However, the original code's expression might be trying to compute a specific offset, but the way it's written is a bit confusing. \n\nThe problem here is that both expressions are using complex calculations, but the question is about which is more idiomatic. The user's hierarchy says that semantic structures (like for loops, switch statements) are better than graph artifacts (like goto, if-else cascades). However, the expressions inside the switch are not control structures but expressions. \n\nWait, the main difference here is the expression inside the switch. The original code uses a pointer dereference with a complex offset, while Candidate B uses array indexing. Which is more human-like? Well, array indexing is a common idiom in C for accessing elements, but the expression inside the brackets in Candidate B is id + (type)id + 1. If id is a pointer, then adding (type)id (which is the same as id) would be id + id, which is 2*id, then plus 1. That seems odd. Maybe the original code's expression is trying to access a specific field in a struct, using a known offset. \n\nAlternatively, perhaps Candidate B's expression is a simplification or a refactor that makes the code more readable. But the original code's expression is (type)id + 0x1020c9 + id. Let's parse that: (type)id is casting id to a type (maybe a pointer type), then adding 0x1020c9 (a constant) and id. So the total is (type)id + id + 0x1020c9. If id is a pointer, then adding id (as a pointer) to (type)id (which is the same as id) would be adding two pointers, which is not allowed in C. Wait, that can't be right. Oh, wait, in C, you can't add two pointers. So maybe the original code has a mistake here. Because (type)id is a pointer, and adding another pointer (id) to it would be invalid. That's a problem. \n\nWait, the original code in Candidate A is: *(type)((type)id + 0x1020c9 + id). Let's break it down. The inner part is (type)id + 0x1020c9 + id. If (type)id is a pointer (say, void*), then adding 0x1020c9 (an integer) to it is valid, but adding another pointer (id) would be invalid. So that expression is actually invalid C code. Because you can't add two pointers. So that's a compiler error. Therefore, Candidate A's code is invalid, while Candidate B's code might be valid. \n\nWait, but the user provided the diff as part of the AST, so maybe the code is valid in some context. But assuming that the code is correct, perhaps there's a misunderstanding here. Alternatively, maybe the code uses a type that allows such operations. But in standard C, adding two pointers is not allowed. So Candidate A's code would have a compiler error, making it invalid. \n\nIf that's the case, then Candidate B's code is more correct. But the question is about idiomatic design, not correctness. However, if Candidate A's code is invalid, then it's not a good example of idiomatic code. \n\nAlternatively, perhaps the code uses a type where adding pointers is allowed, but that's not standard. So, assuming that the code is valid, perhaps the original code's expression is a mistake, and Candidate B's code is a correction. \n\nBut the user's instruction is to evaluate the structural changes in the AST for idiomatic design. The key point here is the expression inside the switch. Candidate A uses a complex pointer arithmetic with a hexadecimal offset, which is common in low-level code but might be less readable. Candidate B uses array indexing with a calculation that might be more readable if the data structure is an array. However, the expression in Candidate B is id + (type)id + 1. If id is an array, then id is a pointer to the first element. Adding (type)id (which is the same as id) would be adding the pointer to itself, which would be a large offset. That seems odd. \n\nAlternatively, perhaps the original code's expression is a mistake, and Candidate B's code is a refactor that simplifies it. However, without knowing the exact context, it's hard to say. \n\nBut according to the forced decision rules, if the logic is identical, choose the one with less artificial nesting. However, the logic here might not be identical. If Candidate A's code is invalid, then Candidate B is better. But the problem is that the user hasn't indicated any errors, so we have to assume both are valid. \n\nAlternatively, the difference is in the expression's structure. Candidate A's expression is a pointer dereference with a complex offset, which is a machine-like approach. Candidate B's expression uses array indexing, which is more human-like, as arrays are a common data structure. However, the calculation inside the array index is still complex. \n\nWait, the original code's expression is (type)id + 0x1020c9 + id. If id is a pointer, then (type)id is the same as id. So the expression becomes id + 0x1020c9 + id = 2*id + 0x1020c9. But that's adding two pointers (id and id) which is invalid. So that's a mistake. Therefore, Candidate A's code is invalid. Candidate B's code is id[id + (type)id + 1]. If (type)id is the same as id, then the index is id + id + 1"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(_sav_time_parse_actions[lVar17 + (long)cVar3 + 1]) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = (((*(id)))) - str;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 12)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  12;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(*(type)((type)id + 0x1020c9 + id)){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(id[id + (type)id + 1]){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.5625,
          "base_ppl": 2.328125,
          "pr_ppl": 2.28125,
          "source_ast_ppl": 2.703125,
          "base_ast_ppl": 3.25,
          "pr_ast_ppl": 3.171875,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a named array (_sav_time_parse_actions) with a computed index, which is more maintainable and semantically clear than the original's magic number (0x1020c9) offset. Both use switch statements (semantic structure), but B's approach aligns better with human-readable abstractions.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns with the Source Code's use of the _sav_time_parse_actions array, which is explicitly referenced in the original switch statement's action handling logic. The Source Code uses this array to drive state transitions, and Candidate B's switch expression directly reflects this array access, whereas Candidate A uses a hardcoded memory address that diverges from the source's variable-based structure.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate B simplifies the switch condition by using array-style indexing (id[id + ...]) instead of complex pointer arithmetic with casts and offsets. While both use a switch (a semantic structure), B's expression is more idiomatic in C-like syntax, avoiding obscure pointer manipulation. This aligns better with human-readable code patterns.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-file_file_replace-O0.so",
        "function": "file_replace",
        "source_code": "file_protected int\nfile_replace(struct magic_set *ms, const char *pat, const char *rep)\n{\n\tfile_regex_t rx;\n\tint rc, rv = -1;\n\n\trc = file_regcomp(ms, &rx, pat, REG_EXTENDED);\n\tif (rc == 0) {\n\t\tregmatch_t rm;\n\t\tint nm = 0;\n\t\twhile (file_regexec(ms, &rx, ms->o.buf, 1, &rm, 0) == 0) {\n\t\t\tms->o.buf[rm.rm_so] = '\\0';\n\t\t\tif (file_printf(ms, \"%s%s\", rep,\n\t\t\t    rm.rm_eo != 0 ? ms->o.buf + rm.rm_eo : \"\") == -1)\n\t\t\t\tgoto out;\n\t\t\tnm++;\n\t\t}\n\t\trv = nm;\n\t}\nout:\n\tfile_regfree(&rx);\n\treturn rv;\n}\n",
        "function_base": "\nint file_replace(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  undefined *local_90;\n  int local_74;\n  int local_70;\n  int local_6c;\n  int local_68;\n  int local_64;\n  undefined1 local_60 [64];\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_68 = -1;\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_64 = file_regcomp(param_1,local_60,param_2,1);\n  if (local_64 == 0) {\n    local_74 = 0;\n    while (iVar1 = file_regexec(local_10,local_60,*(undefined8 *)(local_10 + 0x20),1,&local_70,0),\n          iVar1 == 0) {\n      *(undefined1 *)(*(long *)(local_10 + 0x20) + (long)local_70) = 0;\n      if (local_6c == 0) {\n        local_90 = &DAT_0010201c;\n      }\n      else {\n        local_90 = (undefined *)(*(long *)(local_10 + 0x20) + (long)local_6c);\n      }\n      iVar1 = file_printf(local_10,&DAT_00102098,local_20,local_90);\n      if (iVar1 == -1) goto LAB_0010189e;\n      local_74 = local_74 + 1;\n    }\n    local_68 = local_74;\n  }\nLAB_0010189e:\n  file_regfree(local_60);\n  return local_68;\n}\n\n",
        "function_pr": "\nint file_replace(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  char *local_90;\n  int local_74;\n  int local_70;\n  int local_6c;\n  int local_68;\n  int local_64;\n  undefined1 local_60 [64];\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_68 = -1;\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_64 = file_regcomp(param_1,local_60,param_2,1);\n  if (local_64 == 0) {\n    local_74 = 0;\n    while (iVar1 = file_regexec(local_10,local_60,*(undefined8 *)(local_10 + 0x20),1,&local_70,0),\n          iVar1 == 0) {\n      *(undefined1 *)(*(long *)(local_10 + 0x20) + (long)local_70) = 0;\n      if (local_6c == 0) {\n        local_90 = \"\";\n      }\n      else {\n        local_90 = (char *)(*(long *)(local_10 + 0x20) + (long)local_6c);\n      }\n      iVar1 = file_printf(local_10,&DAT_00102098,local_20,local_90);\n      if (iVar1 == -1) goto LAB_0010189e;\n      local_74 = local_74 + 1;\n    }\n    local_68 = local_74;\n  }\nLAB_0010189e:\n  file_regfree(local_60);\n  return local_68;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id;\n  type id, id = -1;\n  id = call(id, &id, id, id);\n  if(id == 0){\n    type id;\n    type id = 0;\n    while(call(id, &id, id->id.id, 1, &id, 0) == 0){\n      id->id.id[id.id] = str;\n      if(call(id, str, id, (id.id != 0 ? id->id.id + id.id : str)) == -1)goto lbl;\n      id++;\n    }\n    id = id;\n  }\n  lbl:\n  call(&id);\n  return id;\n}",
        "base_ast": "type id( id, type id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id[64];\n  type id;\n  type id;\n  type id;\n  id = -1;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id, id, id, 1);\n  if(id == 0){\n    id = 0;\n    while(id = call(id, id, *(type)(id + 0x20), 1, &id, 0)id == 0){\n      *(type)(*(type)(id + 0x20) + (type)id) = 0;\n      if(id == 0){\n        id = &id;\n      }else{\n        id = (type)(*(type)(id + 0x20) + (type)id);\n      }\n      id = call(id, &id, id, id);\n      if(id == -1)goto lbl;\n      id = id + 1;\n    }\n    id = id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "pr_ast": "type id( id, type id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id[64];\n  type id;\n  type id;\n  type id;\n  id = -1;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id, id, id, 1);\n  if(id == 0){\n    id = 0;\n    while(id = call(id, id, *(type)(id + 0x20), 1, &id, 0)id == 0){\n      *(type)(*(type)(id + 0x20) + (type)id) = 0;\n      if(id == 0){\n        id = str;\n      }else{\n        id = (type)(*(type)(id + 0x20) + (type)id);\n      }\n      id = call(id, &id, id, id);\n      if(id == -1)goto lbl;\n      id = id + 1;\n    }\n    id = id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.40625,
          "base_ppl": 2.296875,
          "pr_ppl": 2.25,
          "source_ast_ppl": 6.71875,
          "base_ast_ppl": 3.625,
          "pr_ast_ppl": 3.75,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves human readability by using a semantically appropriate type (char*) for a string pointer, aligning with standard C practices. The control flow remains identical, but the type change reduces ambiguity and better reflects the intended usage of local_90 as a string reference rather than a generic undefined pointer. This makes the code more intuitive for human readers.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns with the Source Code structure by correcting the type of `local_90` to `char *` (matching string operations in the source) and using string literals/pointers consistently. Candidate A uses `undefined *`, which does not reflect the source's string handling.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "The structural changes between Candidate A and B do not alter the control flow skeleton (e.g., the `if-else` and `while` constructs remain unchanged). Since the logic is not identical and the nesting depth is the same, the tie-breaker does not apply. However, Candidate A retains the original assignment (`&id`), which aligns with the existing control flow without introducing new variables or dependencies. Candidate B introduces `str`, which may imply a semantic shift but does not improve the idiomatic structure of the control flow.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE."
        }
      }
    ],
    "deepseek-r1": [
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(_dta_timestamp_parse_actions[lVar8 + lVar15 + 1]) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = id - 1900;\n              }\n              break;\n            }\n          case 16:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 17:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 44)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  44;\n  id != id\n  {\n    type id[1024];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(*(type)(id + 0x102361 + id)){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(id[id + id + 1]){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.609375,
          "source_ast_ppl": 2.328125,
          "base_ast_ppl": 2.78125,
          "pr_ast_ppl": 2.78125,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses an array access in the switch statement, which is more idiomatic and readable. This structure is clearer and aligns with high-level human thinking, making the logic flow more understandable.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts."
        },
        "llm_ast": {
          "motivation": "Candidate B simplifies the switch statement by using direct array indexing instead of complex pointer arithmetic and casting. This makes the code more readable and aligns with higher-level, human-like thinking by using clearer expressions.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(_dta_timestamp_parse_actions[lVar8 + lVar15 + 1]) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = id - 1900;\n              }\n              break;\n            }\n          case 16:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 17:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 44)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  44;\n  id != id\n  {\n    type id[1024];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(*(type)(id + 0x102361 + id)){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(id[id + id + 1]){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.609375,
          "source_ast_ppl": 2.328125,
          "base_ast_ppl": 2.78125,
          "pr_ast_ppl": 2.78125,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a direct array access in the switch statement, which is cleaner and more readable. It avoids the complexity of pointer dereferencing, making the logic clearer and easier to follow, thus aligning with better human engineering practices.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B's switch statement directly accesses the _dta_timestamp_parse_actions array, aligning with the Source's structure which uses a switch to handle predefined actions. This improves clarity and efficiency.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate B simplifies the switch statement by removing complex pointer arithmetic, making the code cleaner and more readable. The change reduces artificial nesting and focuses on clear logical structure, aligning with high-level human thinking.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "Candidate A preserves the exact switch expression from the source, maintaining the original AST structure and complexity.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(_sav_date_parse_actions[lVar8 + lVar11 + 1]) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                type id = ((((*(id)))) - str);\n                if(id >= 0 && id <= 9){\n                  id = 10 * id + id;\n                }\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                if(id < 70){\n                  id->id = 100 + id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 47)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  47;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(*(type)(id + 0x102311 + id)){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(id[id + id + 1]){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.015625,
          "base_ppl": 2.609375,
          "pr_ppl": 2.578125,
          "source_ast_ppl": 2.390625,
          "base_ast_ppl": 2.921875,
          "pr_ast_ppl": 2.890625,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses an array lookup which is cleaner and more readable, avoiding the complexity of a pointer dereference. This makes the code more maintainable and follows idiomatic practices better.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns better with the source code's use of array indexing for switch cases, which is structurally closer to the original switch statement in the source.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate B simplifies the switch expression using array access, which is more readable and aligns with high-level language constructs, making the code more human-like.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(_sav_date_parse_actions[lVar8 + lVar11 + 1]) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                type id = ((((*(id)))) - str);\n                if(id >= 0 && id <= 9){\n                  id = 10 * id + id;\n                }\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                if(id < 70){\n                  id->id = 100 + id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 47)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  47;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(*(type)(id + 0x102311 + id)){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(id[id + id + 1]){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.015625,
          "base_ppl": 2.609375,
          "pr_ppl": 2.578125,
          "source_ast_ppl": 2.390625,
          "base_ast_ppl": 2.921875,
          "pr_ast_ppl": 2.890625,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a clear and semantic array access in the switch statement, which is more readable and maintainable. It avoids the complexity of pointer dereference and undefined types, aligning with high-level human thinking and better readability.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B uses a direct array access with a clear index, matching the Source Code's structure where an array is accessed based on the state. This improves readability and correctness compared to Candidate A's pointer dereference with an undefined type.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "The change simplifies the switch statement by using array indexing instead of a complex pointer dereference, making it cleaner and more readable. This aligns with high-level human thinking by avoiding unnecessary complexity and artificial nesting.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(_sav_time_parse_actions[lVar17 + (long)cVar3 + 1]) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = (((*(id)))) - str;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 12)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  12;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(*(type)((type)id + 0x1020c9 + id)){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(id[id + (type)id + 1]){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.734375,
          "pr_ppl": 2.671875,
          "source_ast_ppl": 3.03125,
          "base_ast_ppl": 3.65625,
          "pr_ast_ppl": 3.578125,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses an array lookup with a clear index, which is more readable and reflects a higher-level construct compared to the pointer dereference and complex arithmetic in Candidate A. This makes the code more human-like and easier to understand.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns more closely with the Source Code structure by directly accessing the array `_sav_time_parse_actions` with an index, which matches the Source's control flow and logic. Candidate A uses a more complex pointer dereference that does not match the Source's array-based approach.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate B simplifies the switch condition to use array indexing, which is a higher-level, more idiomatic construct compared to the pointer dereference in Candidate A. This makes the code more readable and aligns with human-like logical structures.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "Candidate B changes the switch statement's condition, altering the AST topology by replacing a pointer dereference with an array access, which doesn't match the Source's structure. Candidate A preserves the switch node, aligning with the Source's AST.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(_sav_time_parse_actions[lVar17 + (long)cVar3 + 1]) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = (((*(id)))) - str;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 12)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  12;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(*(type)((type)id + 0x1020c9 + id)){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(id[id + (type)id + 1]){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.734375,
          "pr_ppl": 2.671875,
          "source_ast_ppl": 3.03125,
          "base_ast_ppl": 3.65625,
          "pr_ast_ppl": 3.578125,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses an array access with a clear index calculation, which is more readable and idiomatic. The array name _sav_time_parse_actions suggests a predefined structure, making the code more maintainable and easier to understand compared to the pointer dereference in Candidate A.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns with the source code's switch statement structure, correctly using _sav_time_parse_actions with the appropriate index, whereas Candidate A uses an undefined pointer, which does not match the source.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate B simplifies the switch expression using array indexing, which is more readable and aligns with high-level human thinking. It reduces the complexity of the expression, making the code cleaner and more idiomatic.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "Candidate A preserves the SwitchStatement node with pointer arithmetic, matching the Source's AST topology. Candidate B changes it to an array access, altering the node type.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_replace-O0.so",
        "function": "file_replace",
        "source_code": "file_protected int\nfile_replace(struct magic_set *ms, const char *pat, const char *rep)\n{\n\tfile_regex_t rx;\n\tint rc, rv = -1;\n\n\trc = file_regcomp(ms, &rx, pat, REG_EXTENDED);\n\tif (rc == 0) {\n\t\tregmatch_t rm;\n\t\tint nm = 0;\n\t\twhile (file_regexec(ms, &rx, ms->o.buf, 1, &rm, 0) == 0) {\n\t\t\tms->o.buf[rm.rm_so] = '\\0';\n\t\t\tif (file_printf(ms, \"%s%s\", rep,\n\t\t\t    rm.rm_eo != 0 ? ms->o.buf + rm.rm_eo : \"\") == -1)\n\t\t\t\tgoto out;\n\t\t\tnm++;\n\t\t}\n\t\trv = nm;\n\t}\nout:\n\tfile_regfree(&rx);\n\treturn rv;\n}\n",
        "function_base": "\nint file_replace(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  undefined *local_90;\n  int local_74;\n  int local_70;\n  int local_6c;\n  int local_68;\n  int local_64;\n  undefined1 local_60 [64];\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_68 = -1;\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_64 = file_regcomp(param_1,local_60,param_2,1);\n  if (local_64 == 0) {\n    local_74 = 0;\n    while (iVar1 = file_regexec(local_10,local_60,*(undefined8 *)(local_10 + 0x20),1,&local_70,0),\n          iVar1 == 0) {\n      *(undefined1 *)(*(long *)(local_10 + 0x20) + (long)local_70) = 0;\n      if (local_6c == 0) {\n        local_90 = &DAT_0010201c;\n      }\n      else {\n        local_90 = (undefined *)(*(long *)(local_10 + 0x20) + (long)local_6c);\n      }\n      iVar1 = file_printf(local_10,&DAT_00102098,local_20,local_90);\n      if (iVar1 == -1) goto LAB_0010189e;\n      local_74 = local_74 + 1;\n    }\n    local_68 = local_74;\n  }\nLAB_0010189e:\n  file_regfree(local_60);\n  return local_68;\n}\n\n",
        "function_pr": "\nint file_replace(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  char *local_90;\n  int local_74;\n  int local_70;\n  int local_6c;\n  int local_68;\n  int local_64;\n  undefined1 local_60 [64];\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_68 = -1;\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_64 = file_regcomp(param_1,local_60,param_2,1);\n  if (local_64 == 0) {\n    local_74 = 0;\n    while (iVar1 = file_regexec(local_10,local_60,*(undefined8 *)(local_10 + 0x20),1,&local_70,0),\n          iVar1 == 0) {\n      *(undefined1 *)(*(long *)(local_10 + 0x20) + (long)local_70) = 0;\n      if (local_6c == 0) {\n        local_90 = \"\";\n      }\n      else {\n        local_90 = (char *)(*(long *)(local_10 + 0x20) + (long)local_6c);\n      }\n      iVar1 = file_printf(local_10,&DAT_00102098,local_20,local_90);\n      if (iVar1 == -1) goto LAB_0010189e;\n      local_74 = local_74 + 1;\n    }\n    local_68 = local_74;\n  }\nLAB_0010189e:\n  file_regfree(local_60);\n  return local_68;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id;\n  type id, id = -1;\n  id = call(id, &id, id, id);\n  if(id == 0){\n    type id;\n    type id = 0;\n    while(call(id, &id, id->id.id, 1, &id, 0) == 0){\n      id->id.id[id.id] = str;\n      if(call(id, str, id, (id.id != 0 ? id->id.id + id.id : str)) == -1)goto lbl;\n      id++;\n    }\n    id = id;\n  }\n  lbl:\n  call(&id);\n  return id;\n}",
        "base_ast": "type id( id, type id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id[64];\n  type id;\n  type id;\n  type id;\n  id = -1;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id, id, id, 1);\n  if(id == 0){\n    id = 0;\n    while(id = call(id, id, *(type)(id + 0x20), 1, &id, 0)id == 0){\n      *(type)(*(type)(id + 0x20) + (type)id) = 0;\n      if(id == 0){\n        id = &id;\n      }else{\n        id = (type)(*(type)(id + 0x20) + (type)id);\n      }\n      id = call(id, &id, id, id);\n      if(id == -1)goto lbl;\n      id = id + 1;\n    }\n    id = id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "pr_ast": "type id( id, type id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id[64];\n  type id;\n  type id;\n  type id;\n  id = -1;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id, id, id, 1);\n  if(id == 0){\n    id = 0;\n    while(id = call(id, id, *(type)(id + 0x20), 1, &id, 0)id == 0){\n      *(type)(*(type)(id + 0x20) + (type)id) = 0;\n      if(id == 0){\n        id = str;\n      }else{\n        id = (type)(*(type)(id + 0x20) + (type)id);\n      }\n      id = call(id, &id, id, id);\n      if(id == -1)goto lbl;\n      id = id + 1;\n    }\n    id = id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.625,
          "base_ppl": 2.609375,
          "pr_ppl": 2.671875,
          "source_ast_ppl": 7.875,
          "base_ast_ppl": 4.28125,
          "pr_ast_ppl": 4.40625,
          "delta_ppl": 0.0625
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by explicitly initializing `local_90` with an empty string instead of an undefined pointer, and by correctly specifying the pointer type as `char *`. This makes the code more maintainable and clearer in intent, aligning with idiomatic C practices.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B correctly initializes local_90 with appropriate values, aligning with the Source's structure by avoiding undefined behavior and correctly handling string operations.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "Okay, so I'm trying to figure out which version, A or B, better matches the source AST topology based on the given criteria. Let me break this down step by step.\n\nFirst, I need to understand the problem. The task is to compare two candidates, A and B, and determine which one aligns more closely with the source AST structure. The criteria are:\n\n1. Topology Match: Does the + code in the diff restore a node type that was present in the source but missing in the - version?\n2. Complexity: Does the + code match the nesting depth of the source?\n\nLooking at the source AST, I see that it's a function with several statements. There's a while loop inside an if block. The while loop has a condition that involves a function call, and inside the loop, there's an if statement with a goto lbl. Then, after the loop, there's a call to a function and a return statement.\n\nNow, looking at the diff provided. The diff shows changes around line 20. In Candidate A, the line is:\n\nwhile(id = call(id, id, *(type)(id + 0x20), 1, &id, 0)id == 0){\n\nAnd in Candidate B, it's changed to:\n\nwhile(id = call(id, id, *(type)(id + 0x20), 1, &id, 0)id == 0){\n\nWait, that's the same line. Hmm, maybe I need to look further. Oh, the change is in the lines after that. Let me check the context.\n\nIn the diff, the lines after the while loop are modified. Specifically, inside the while loop, there's an if statement. In Candidate A, the if statement is:\n\nif(id == 0){\n  id = &id;\n} else {\n  id = (type)(*(type)(id + 0x20) + (type)id);\n}\n\nIn Candidate B, it's changed to:\n\nif(id == 0){\n  id = str;\n} else {\n  id = (type)(*(type)(id + 0x20) + (type)id);\n}\n\nSo the main change is in the assignment inside the if block. In A, it's id = &id; and in B, it's id = str;.\n\nNow, looking back at the source AST, in the corresponding part, after the while loop, there's an if statement that checks if a function call returns -1, and if so, it goes to lbl. But in the source, the if statement inside the while loop doesn't have a goto; instead, it's part of the loop's condition.\n\nWait, maybe I'm getting confused. Let me try to map the source AST structure.\n\nIn the source, after the while loop, there's an if statement that uses goto lbl if a certain condition is met. The while loop's condition is a function call that returns 0, and inside the loop, there's another if statement that modifies some variables.\n\nIn the diff, the while loop's condition is similar, but the body has an if statement. In Candidate A, when id is 0, it sets id to &id. In Candidate B, it sets id to str.\n\nNow, applying the criteria:\n\n1. Topology Match: Does the + code (Candidate B) restore a node type present in the source but missing in Candidate A?\n\nLooking at the source, in the if block inside the while loop, the code is:\n\nif(call(id, str, id, (id.id != 0 ? id->id.id + id.id : str)) == -1) goto lbl;\n\nBut in the diff, the if statement inside the while loop is simplified. In Candidate A, it's id = &id; which is an assignment. In Candidate B, it's id = str; which is also an assignment but to a different variable.\n\nWait, in the source, the if statement inside the while loop doesn't directly set id to something; instead, it calls a function and uses goto if it returns -1. But in the diff, the if statement is inside the while loop, and the code in the source after the while loop has a goto lbl, which is then followed by a call and return.\n\nHmm, maybe I'm missing something. The source has a goto lbl, which is then followed by a call to &id. So in the source, after the while loop, there's a lbl: which is the target of the goto.\n\nIn the diff, the while loop's body in Candidate B sets id to str when id is 0. Does this restore a node type that was present in the source? The source had a goto lbl in that if condition, but in the diff, it's replaced with an assignment to str. So in the source, the if condition leads to a goto, which is a control flow change, but in the diff, it's just an assignment. So in terms of node types, the source had a GotoStatement, but in the diff, it's missing in both A and B. Wait, no, in the source, the if statement inside the while loop leads to a goto, but in the diff, the if is simplified to an assignment.\n\nWait, maybe I'm overcomplicating. The key is whether the + code (Candidate B) restores a node type that was in the source but missing in Candidate A.\n\nIn Candidate A, the if block sets id to &id, which is an assignment. In Candidate B, it sets id to str, which is also an assignment. So both are assignment statements. But in the source, the if condition inside the while loop leads to a goto, which is a different node type (GotoStatement). So in the source, there was a GotoStatement, but in both candidates, it's replaced with an assignment. So neither A nor B has the GotoStatement node. Therefore, neither is restoring that node type. Hmm, that's confusing.\n\nWait, maybe I'm looking at the wrong part. Let me check the source again. The source has:\n\nif(call(id, str, id, (id.id != 0 ? id->id.id + id.id : str)) == -1) goto lbl;\n\nSo that's an IfStatement with a condition and a GotoStatement as the consequence. In the diff, the while loop's if statement is simplified to just an assignment. So in the source, the if statement has a GotoStatement, but in the candidates, it's just an assignment. So neither A nor B includes the GotoStatement. Therefore, neither is restoring that node type. So maybe the topology match criterion isn't met by either.\n\nBut wait, the diff shows that in the while loop, the if statement is modified. In the source, the if statement is inside the while loop, and the diff shows that in both candidates, the if statement is present but the body is different. So perhaps the issue is whether the + code (Candidate B) correctly restores the structure.\n\nAlternatively, maybe the source has a SwitchStatement somewhere, but looking at the source, I don't see a SwitchStatement. The source has if statements and a while loop, but no switch.\n\nWait, the first criterion is whether the + code restores a node type present in the source but missing in -. So in the diff, the lines that are - are Candidate A, and + are Candidate B.\n\nLooking at the lines, the while loop condition is the same in both, but the body's if statement is different. In A, the if sets id to &id; in B, it sets id to str.\n\nIn the source, the corresponding part after the while loop has a goto lbl, which is then followed by a call and return. So perhaps the source's structure includes a goto, which is a GotoStatement node. But in the candidates, the if statement inside the while loop doesn't have a goto; instead, it's just an assignment. So in the source, the if statement leads to a goto, but in the candidates, it's just an assignment. Therefore, the source has an IfStatement with a GotoStatement, but the candidates have IfStatements with AssignmentExpressions.\n\nSo in terms of topology, the source has IfStatement -> GotoStatement, but the candidates have IfStatement -> Assignment. Therefore, the + code (Candidate B) doesn't restore the GotoStatement node, which was present in the source. So in that sense, neither A nor B is restoring that node type.\n\nWait, but maybe I'm misunderstanding the diff. The diff shows that in the while loop, the if statement is modified. In the source, the if statement inside the while loop leads to a goto, but in the candidates, it's just an assignment. So the source has an IfStatement with a GotoStatement, but the candidates have IfStatements with Assignments. Therefore, the + code (Candidate B) doesn't restore the GotoStatement node, which was present in the source. So in terms of topology, Candidate B doesn't restore that node type, but neither does A.\n\nHmm, maybe I'm missing something else. Let's look at the complexity criterion: does the + code match the nesting depth of the source?\n\nIn the source, the if statement is inside the while loop, which is inside the if block after the initial if. So the nesting depth is higher. In the candidates, the while loop's if statement is at the same level as the while loop, so the nesting depth is similar. So in terms of complexity, both candidates have the same nesting depth as the source.\n\nBut wait, in the source, after the while loop, there's a goto lbl, which is then followed by a call and return. So the structure is:\n\nif (condition) {\n  while (loop condition) {\n    if (condition) goto lbl;\n  }\n  lbl"
        }
      }
    ],
    "qwen-2.5": [
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(_dta_timestamp_parse_actions[lVar8 + lVar15 + 1]) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = id - 1900;\n              }\n              break;\n            }\n          case 16:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 17:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 44)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  44;\n  id != id\n  {\n    type id[1024];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(*(type)(id + 0x102361 + id)){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(id[id + id + 1]){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.453125,
          "base_ppl": 2.046875,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 2.03125,
          "base_ast_ppl": 2.453125,
          "pr_ast_ppl": 2.421875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by using a cleaner expression for the switch statement, making the code more aligned with idiomatic control flow and easier to understand for humans.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(_dta_timestamp_parse_actions[lVar8 + lVar15 + 1]) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = id - 1900;\n              }\n              break;\n            }\n          case 16:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 17:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 44)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  44;\n  id != id\n  {\n    type id[1024];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(*(type)(id + 0x102361 + id)){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(id[id + id + 1]){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.453125,
          "base_ppl": 2.046875,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 2.03125,
          "base_ast_ppl": 2.453125,
          "pr_ast_ppl": 2.421875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B improves readability by using a cleaner expression for the array index calculation, making the code more idiomatic and easier to understand.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(_sav_date_parse_actions[lVar8 + lVar11 + 1]) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                type id = ((((*(id)))) - str);\n                if(id >= 0 && id <= 9){\n                  id = 10 * id + id;\n                }\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                if(id < 70){\n                  id->id = 100 + id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 47)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  47;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(*(type)(id + 0x102311 + id)){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(id[id + id + 1]){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.5078125,
          "base_ppl": 2.015625,
          "pr_ppl": 1.9921875,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 2.515625,
          "pr_ast_ppl": 2.5,
          "delta_ppl": -0.0234375
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses an array lookup for the switch statement, which is more idiomatic and abstract compared to directly dereferencing memory. This makes the code easier to understand and maintain as it clearly maps to high-level human thinking.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns better with the Source Code structure by using the correct variable for the switch statement, which is _sav_date_parse_actions[lVar8 + lVar11 + 1]. This matches the pattern seen in the Source Code where actions are accessed through an array.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(_sav_date_parse_actions[lVar8 + lVar11 + 1]) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                type id = ((((*(id)))) - str);\n                if(id >= 0 && id <= 9){\n                  id = 10 * id + id;\n                }\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                if(id < 70){\n                  id->id = 100 + id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 47)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  47;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(*(type)(id + 0x102311 + id)){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(id[id + id + 1]){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.5078125,
          "base_ppl": 2.015625,
          "pr_ppl": 1.9921875,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 2.515625,
          "pr_ast_ppl": 2.5,
          "delta_ppl": -0.0234375
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses an array lookup for the switch statement, which simplifies the logic and makes it more readable and maintainable. It avoids direct memory dereferencing and uses a named array, which enhances semantic understanding.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns more closely with the Source Code structure by using the correct array for actions, maintaining the intended logic and control flow.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate B improves idiomatic design by using a more straightforward array indexing operation instead of pointer arithmetic, which makes the code cleaner and easier to understand.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(_sav_time_parse_actions[lVar17 + (long)cVar3 + 1]) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = (((*(id)))) - str;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 12)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  12;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(*(type)((type)id + 0x1020c9 + id)){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(id[id + (type)id + 1]){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 2.0,
          "pr_ppl": 1.9765625,
          "source_ast_ppl": 2.546875,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.03125,
          "delta_ppl": -0.0234375
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses an array lookup for the switch statement, which is more idiomatic and abstract, reflecting cleaner and more readable code structure compared to the direct memory access used in Candidate A.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts."
        },
        "llm_ast": {
          "motivation": "Candidate B improves idiomatic design by replacing the complex pointer arithmetic and casting in the switch statement with a cleaner array access, making the code more readable and closer to high-level human thinking.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(_sav_time_parse_actions[lVar17 + (long)cVar3 + 1]) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = (((*(id)))) - str;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 12)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  12;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(*(type)((type)id + 0x1020c9 + id)){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(id[id + (type)id + 1]){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 2.0,
          "pr_ppl": 1.9765625,
          "source_ast_ppl": 2.546875,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.03125,
          "delta_ppl": -0.0234375
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses an array lookup for the switch statement, which is more idiomatic and abstract compared to directly dereferencing a memory address. This makes the code easier to understand and maintain, aligning better with human engineering practices.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts."
        },
        "llm_ast": {
          "motivation": "Candidate B improves the idiomatic design by using a cleaner and more intuitive array access pattern instead of pointer arithmetic, which enhances readability and aligns better with high-level human thinking.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      },
      {
        "binary": "task-file_file_replace-O0.so",
        "function": "file_replace",
        "source_code": "file_protected int\nfile_replace(struct magic_set *ms, const char *pat, const char *rep)\n{\n\tfile_regex_t rx;\n\tint rc, rv = -1;\n\n\trc = file_regcomp(ms, &rx, pat, REG_EXTENDED);\n\tif (rc == 0) {\n\t\tregmatch_t rm;\n\t\tint nm = 0;\n\t\twhile (file_regexec(ms, &rx, ms->o.buf, 1, &rm, 0) == 0) {\n\t\t\tms->o.buf[rm.rm_so] = '\\0';\n\t\t\tif (file_printf(ms, \"%s%s\", rep,\n\t\t\t    rm.rm_eo != 0 ? ms->o.buf + rm.rm_eo : \"\") == -1)\n\t\t\t\tgoto out;\n\t\t\tnm++;\n\t\t}\n\t\trv = nm;\n\t}\nout:\n\tfile_regfree(&rx);\n\treturn rv;\n}\n",
        "function_base": "\nint file_replace(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  undefined *local_90;\n  int local_74;\n  int local_70;\n  int local_6c;\n  int local_68;\n  int local_64;\n  undefined1 local_60 [64];\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_68 = -1;\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_64 = file_regcomp(param_1,local_60,param_2,1);\n  if (local_64 == 0) {\n    local_74 = 0;\n    while (iVar1 = file_regexec(local_10,local_60,*(undefined8 *)(local_10 + 0x20),1,&local_70,0),\n          iVar1 == 0) {\n      *(undefined1 *)(*(long *)(local_10 + 0x20) + (long)local_70) = 0;\n      if (local_6c == 0) {\n        local_90 = &DAT_0010201c;\n      }\n      else {\n        local_90 = (undefined *)(*(long *)(local_10 + 0x20) + (long)local_6c);\n      }\n      iVar1 = file_printf(local_10,&DAT_00102098,local_20,local_90);\n      if (iVar1 == -1) goto LAB_0010189e;\n      local_74 = local_74 + 1;\n    }\n    local_68 = local_74;\n  }\nLAB_0010189e:\n  file_regfree(local_60);\n  return local_68;\n}\n\n",
        "function_pr": "\nint file_replace(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  char *local_90;\n  int local_74;\n  int local_70;\n  int local_6c;\n  int local_68;\n  int local_64;\n  undefined1 local_60 [64];\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_68 = -1;\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_64 = file_regcomp(param_1,local_60,param_2,1);\n  if (local_64 == 0) {\n    local_74 = 0;\n    while (iVar1 = file_regexec(local_10,local_60,*(undefined8 *)(local_10 + 0x20),1,&local_70,0),\n          iVar1 == 0) {\n      *(undefined1 *)(*(long *)(local_10 + 0x20) + (long)local_70) = 0;\n      if (local_6c == 0) {\n        local_90 = \"\";\n      }\n      else {\n        local_90 = (char *)(*(long *)(local_10 + 0x20) + (long)local_6c);\n      }\n      iVar1 = file_printf(local_10,&DAT_00102098,local_20,local_90);\n      if (iVar1 == -1) goto LAB_0010189e;\n      local_74 = local_74 + 1;\n    }\n    local_68 = local_74;\n  }\nLAB_0010189e:\n  file_regfree(local_60);\n  return local_68;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id;\n  type id, id = -1;\n  id = call(id, &id, id, id);\n  if(id == 0){\n    type id;\n    type id = 0;\n    while(call(id, &id, id->id.id, 1, &id, 0) == 0){\n      id->id.id[id.id] = str;\n      if(call(id, str, id, (id.id != 0 ? id->id.id + id.id : str)) == -1)goto lbl;\n      id++;\n    }\n    id = id;\n  }\n  lbl:\n  call(&id);\n  return id;\n}",
        "base_ast": "type id( id, type id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id[64];\n  type id;\n  type id;\n  type id;\n  id = -1;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id, id, id, 1);\n  if(id == 0){\n    id = 0;\n    while(id = call(id, id, *(type)(id + 0x20), 1, &id, 0)id == 0){\n      *(type)(*(type)(id + 0x20) + (type)id) = 0;\n      if(id == 0){\n        id = &id;\n      }else{\n        id = (type)(*(type)(id + 0x20) + (type)id);\n      }\n      id = call(id, &id, id, id);\n      if(id == -1)goto lbl;\n      id = id + 1;\n    }\n    id = id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "pr_ast": "type id( id, type id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id[64];\n  type id;\n  type id;\n  type id;\n  id = -1;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id, id, id, 1);\n  if(id == 0){\n    id = 0;\n    while(id = call(id, id, *(type)(id + 0x20), 1, &id, 0)id == 0){\n      *(type)(*(type)(id + 0x20) + (type)id) = 0;\n      if(id == 0){\n        id = str;\n      }else{\n        id = (type)(*(type)(id + 0x20) + (type)id);\n      }\n      id = call(id, &id, id, id);\n      if(id == -1)goto lbl;\n      id = id + 1;\n    }\n    id = id;\n  }\n  lbl:\n  call(id);\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 1.9765625,
          "pr_ppl": 1.9140625,
          "source_ast_ppl": 5.625,
          "base_ast_ppl": 3.328125,
          "pr_ast_ppl": 3.46875,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns better with the Source Code structure by using 'char *' for local_90, which is consistent with the string operations in the Source Code. Additionally, it correctly assigns an empty string when local_6c is 0, matching the Source Code's intent.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate B improves idiomatic design by replacing the artificial assignment `id = &id;` with a more meaningful and contextually appropriate assignment `id = str;`, which better aligns with high-level human thinking and reduces cognitive load.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts."
        }
      }
    ]
  }
}