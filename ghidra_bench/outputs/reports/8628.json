{
  "pr": "8628",
  "mean_delta_perplexity": -0.0096875,
  "mean_perplexity_base": 1.99125,
  "mean_perplexity_pr": 1.9815625,
  "mean_perplexity_source": 2.1309375,
  "mean_perplexity_base_ast": 2.6884375,
  "mean_perplexity_pr_ast": 2.6903125,
  "mean_perplexity_source_ast": 3.446875,
  "results": {
    "qwen-coder": [
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.7734375,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 2.3125,
          "base_ast_ppl": 2.109375,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.7734375,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 2.3125,
          "base_ast_ppl": 2.109375,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.96875,
          "base_ppl": 1.9375,
          "pr_ppl": 1.9296875,
          "source_ast_ppl": 2.578125,
          "base_ast_ppl": 2.28125,
          "pr_ast_ppl": 2.265625,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.96875,
          "base_ppl": 1.9453125,
          "pr_ppl": 1.9375,
          "source_ast_ppl": 2.578125,
          "base_ast_ppl": 2.28125,
          "pr_ast_ppl": 2.265625,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "```json\n{\n  \"diff_analysis\": \"Both Candidate A and Candidate B are identical in their structure and content compared to the Source AST. There are no structural differences between them.\",\n  \"motivation\": \"Since both candidates mirror the exact structure and complexity of the Source AST without any modifications or transformations, they equally preserve the architectural intent of the original code. However, since the problem statement specifies that we should choose the candidate that is closer to the Source intent, and both candidates are identical, either could be considered correct based on this criterion. For the purpose of this analysis, we will consider both as winners.\",\n  \"winner\": [\"A\", \"B\"]\n}\n```"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + ((long)iVar7 - 1);\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + ((long)(iVar7 << 1) - 2);\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 - 1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c - 1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type *id;\n  type id[num];\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type *id;\n  type id[num];\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.71875,
          "pr_ppl": 1.71875,
          "source_ast_ppl": 2.3125,
          "base_ast_ppl": 2.015625,
          "pr_ast_ppl": 2.015625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + ((long)iVar7 - 1);\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + ((long)(iVar7 << 1) - 2);\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc - 1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c - 1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.96875,
          "base_ppl": 1.734375,
          "pr_ppl": 1.734375,
          "source_ast_ppl": 2.578125,
          "base_ast_ppl": 2.015625,
          "pr_ast_ppl": 2.015625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "```json\n{\n  \"diff_analysis\": \"Both Candidate A and Candidate B are identical to each other and significantly different from the Source AST. They both lack proper structural representation and fail to preserve the architectural intent of the Source code.\",\n  \"motivation\": \"Neither Candidate A nor Candidate B accurately represents the Source AST. Both candidates suffer from numerous structural issues such as missing control structures, incorrect variable declarations, and logical errors. Therefore, neither candidate can be considered a valid or accurate decompilation of the Source code.\",\n  \"winner\": null\n}\n```"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.6640625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.4375,
          "pr_ast_ppl": 2.4375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "```json\n{\n  \"diff_analysis\": \"Both Candidate A and Candidate B have identical structures and logic compared to the Source AST. They both contain complex control flow constructs such as loops, conditionals, and function calls. There are no significant structural differences between them or the Source AST.\",\n  \"motivation\": \"Since both candidates mirror the Source AST in terms of their structural hierarchy and control flow, they preserve the architectural intent equally well. However, since there is no degradation or deviation from the Source's structure, neither candidate can be considered superior based solely on structural isomorphism. Therefore, this comparison does not provide a clear winner.\",\n  \"winner\": null\n}\n```"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.6640625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.4375,
          "pr_ast_ppl": 2.4375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.734375,
          "base_ppl": 2.234375,
          "pr_ppl": 2.21875,
          "source_ast_ppl": 2.328125,
          "base_ast_ppl": 2.5625,
          "pr_ast_ppl": 2.546875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "```json\n{\n  \"diff_analysis\": \"Both candidates are identical in structure and logic.\",\n  \"motivation\": \"Since both candidates are exactly the same, there is no structural difference to evaluate. Therefore, neither candidate is more human-like than the other based on the given criteria.\",\n  \"winner\": null\n}\n```"
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "Since both candidates match the Source AST exactly, they preserve the architectural intent equally well. However, since there is no structural difference between them, neither can be considered more faithful than the other based on the provided criteria."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.734375,
          "base_ppl": 2.234375,
          "pr_ppl": 2.21875,
          "source_ast_ppl": 2.328125,
          "base_ast_ppl": 2.5625,
          "pr_ast_ppl": 2.546875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "```json\n{\n  \"diff_analysis\": \"Both candidates are identical in structure and content.\",\n  \"motivation\": \"Since both candidates are exactly the same, there is no difference in their structural design. Therefore, neither candidate can be considered more human-like than the other.\",\n  \"winner\": null\n}\n```"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.125,
          "base_ppl": 1.8046875,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 5.84375,
          "base_ast_ppl": 2.609375,
          "pr_ast_ppl": 2.734375,
          "delta_ppl": -0.0390625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "Candidate B uses a function call ('call(id op num)') which makes the code more structured and resembles higher-level programming practices. This abstraction helps in understanding the flow better and aligns more closely with human-readable code conventions."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.125,
          "base_ppl": 1.8046875,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 5.84375,
          "base_ast_ppl": 2.609375,
          "pr_ast_ppl": 2.734375,
          "delta_ppl": -0.0390625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + ((long)iVar2 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar2 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 - 0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.734375,
          "base_ppl": 1.890625,
          "pr_ppl": 1.8828125,
          "source_ast_ppl": 2.328125,
          "base_ast_ppl": 2.15625,
          "pr_ast_ppl": 2.15625,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + ((long)local_5c - 1);\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + ((long)(local_5c << 1) - 2);\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 - 1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + ((int)*local_40 - 0x30U);\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.6640625,
          "base_ppl": 2.03125,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.15625,
          "pr_ast_ppl": 2.15625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "```json\n{\n  \"diff_analysis\": \"Both Candidate A and Candidate B exhibit significant structural differences from the Source AST. However, upon closer inspection, both candidates fail to preserve the architectural intent of the Source by transforming high-level control structures into lower-level constructs such as nested loops and conditional statements.\",\n  \"motivation\": \"Neither Candidate A nor Candidate B accurately represents the original source code's architecture. They have replaced complex control flow with simpler but less efficient alternatives, leading to a degradation in fidelity. Therefore, neither candidate can be considered a valid representation of the Source AST.\",\n  \"winner\": null\n}\n```"
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.46875,
          "base_ppl": 1.9765625,
          "pr_ppl": 1.984375,
          "source_ast_ppl": 3.40625,
          "base_ast_ppl": 2.546875,
          "pr_ast_ppl": 2.546875,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.46875,
          "base_ppl": 1.9765625,
          "pr_ppl": 1.9921875,
          "source_ast_ppl": 3.40625,
          "base_ast_ppl": 2.5625,
          "pr_ast_ppl": 2.5625,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "Neither Candidate A nor Candidate B accurately preserves the architectural intent of the Source AST. They both transform the high-level structure of the Source code into lower-level constructs, such as using `if-else` chains instead of `switch` statements, and introducing additional variables and operations that are not present in the Source. This transformation results in a loss of clarity and readability compared to the Source code."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.21875,
          "base_ppl": 2.234375,
          "pr_ppl": 2.1875,
          "source_ast_ppl": 2.921875,
          "base_ast_ppl": 2.921875,
          "pr_ast_ppl": 2.890625,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "```json\n{\n  \"diff_analysis\": \"Both Candidate A and Candidate B diverge significantly from the Source AST in their implementation details. However, both candidates fail to preserve the architectural intent of the Source by transforming high-level structures into lower-level constructs like `do-while` loops and complex conditional logic. Neither candidate accurately represents the original control flow or logical operations present in the Source.\",\n  \"motivation\": \"Neither Candidate A nor Candidate B maintains the structural integrity of the Source AST. They both introduce unnecessary complexity and alter the control flow, making them inferior choices compared to preserving the original architecture. The Source uses a combination of `if-else`, `switch`, and looping constructs to achieve its intended functionality. Both candidates simplify these structures, leading to a loss of fidelity in terms of architectural intent.\",\n  \"winner\": null\n}\n```"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.21875,
          "base_ppl": 2.234375,
          "pr_ppl": 2.1875,
          "source_ast_ppl": 2.921875,
          "base_ast_ppl": 2.921875,
          "pr_ast_ppl": 2.890625,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O0.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + (long)iVar1 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar1 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + *local_2040 + -0x30;\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = *local_2040 + -0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + ((long)iVar1 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar1 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + ((int)*local_2040 - 0x30U);\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = (int)*local_2040 - 0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = *id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = (type)*id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.21875,
          "base_ppl": 1.796875,
          "pr_ppl": 1.8046875,
          "source_ast_ppl": 2.921875,
          "base_ast_ppl": 2.546875,
          "pr_ast_ppl": 2.515625,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "winner": "BASE",
          "motivation": "Candidate A uses more traditional loop constructs like `for` and `if` statements, which are generally more readable and maintainable than low-level constructs or complex nested structures. This makes Candidate A more aligned with human engineering practices."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "BASE",
          "motivation": "Since both candidates are structurally identical, the choice between them should be based on tie-breaking rules. Candidate A has slightly less artificial nesting compared to Candidate B, making it more human-like."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O2.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id, type id, type id){\n  type id;\n  call(call(id, &id));\n  type id[id op num];\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.265625,
          "base_ppl": 1.8515625,
          "pr_ppl": 1.8359375,
          "source_ast_ppl": 3.546875,
          "base_ast_ppl": 2.578125,
          "pr_ast_ppl": 2.578125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "Candidate B's use of parentheses makes the expression clearer and more readable, aligning better with idiomatic programming practices. This improves the overall structure and readability, making it more human-like."
        },
        "llm_ast_source": {
          "winner": "PR",
          "motivation": "Candidate A uses more complex expressions and additional variables, making it less readable and harder to understand compared to Candidate B. Candidate B maintains a cleaner and more straightforward structure, aligning more closely with the Source AST's architectural intent."
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O3.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id, type id, type id){\n  type id;\n  call(call(id, &id));\n  type id[id op num];\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.265625,
          "base_ppl": 1.8515625,
          "pr_ppl": 1.8359375,
          "source_ast_ppl": 3.546875,
          "base_ast_ppl": 2.578125,
          "pr_ast_ppl": 2.578125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "Candidate B is more human-like because it follows a clearer and more conventional syntax for nested operations. The use of parentheses makes the expression easier to read and understand, aligning better with typical programming practices."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-file_file_printable-O2.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, , *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.234375,
          "base_ppl": 2.3125,
          "pr_ppl": 2.3125,
          "source_ast_ppl": 7.0,
          "base_ast_ppl": 5.0,
          "pr_ast_ppl": 4.875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "PR",
          "motivation": "Candidate B adheres to Human Engineering Practices by using a standard 'while' loop, which is easier to read and understand compared to the use of 'goto'."
        },
        "llm_qualitative_source": {
          "winner": "BASE",
          "motivation": "Candidate A maintains the same control flow and data access pattern as the ground truth, making it more faithful to the original logic. Candidate B introduces a new approach using a `for` loop and `isprint`, which diverges from the original structure."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-file_file_printable-O3.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, , *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.234375,
          "base_ppl": 2.3125,
          "pr_ppl": 2.3125,
          "source_ast_ppl": 7.0,
          "base_ast_ppl": 5.0,
          "pr_ast_ppl": 4.875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "PR",
          "motivation": "Candidate A uses `(param_2 + param_3 + -1)` which is less readable compared to Candidate B's `(param_2 + (param_3 - 1))`. This minor difference makes Candidate B slightly more human-readable."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-file_strlcpy-O0.so",
        "function": "strlcpy",
        "source_code": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0 && --n != 0) {\n\t\tdo {\n\t\t\tif ((*d++ = *s++) == 0)\n\t\t\t\tbreak;\n\t\t} while (--n != 0);\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}\n",
        "function_base": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 + -1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + (-1 - (long)param_2);\n}\n\n",
        "function_pr": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 - 1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + -(long)param_2 + -1;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type id){\n  type *id = id;\n  type *id = id;\n  type id = id;\n  if(id != num && upd id != num){\n    do{\n      if((*id upd = *id upd) == num)break;\n    }while(upd id != num);\n  }\n  if(id == num){\n    if(id != num)*id = str;\n    while(*id upd);\n  }\n  return (id op id op num);\n}",
        "base_ast": "type *id(type *id, type *id,  id){\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op (num op (type)id);\n}",
        "pr_ast": "type *id(type *id, type *id,  id){\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op -(type)id op num;\n}",
        "metrics": {
          "source_ppl": 1.2890625,
          "base_ppl": 1.6796875,
          "pr_ppl": 1.6640625,
          "source_ast_ppl": 9.5,
          "base_ast_ppl": 3.296875,
          "pr_ast_ppl": 3.4375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "Candidate B is more concise and avoids unnecessary redundancy, making it easier for a human reader to understand and follow the control flow. The use of the negation operator in the return statement also adds clarity to the logic being executed."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "```json\n{\n  \"diff_analysis\": \"Both Candidate A and Candidate B have significant structural differences from the Source AST. Both candidates introduce unnecessary complexity and transformations that deviate from the original source code's architectural intent.\",\n  \"motivation\": \"Neither Candidate A nor Candidate B accurately preserves the architectural intent of the Source AST. They both transform the original control flow and logic in ways that are not present in the Source. Therefore, neither candidate can be considered as preserving the topological shape or the architectural intent of the Source.\",\n  \"winner\": null\n}\n```"
        }
      },
      {
        "binary": "task-file_file_printable-O0.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + param_3 + -1) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + param_3 + -4 <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + (param_3 - 1)) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + (param_3 - 4) <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, , *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op id op num) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op id op num <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op (id op num)) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op (id op num) <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.234375,
          "base_ppl": 2.109375,
          "pr_ppl": 2.125,
          "source_ast_ppl": 7.0,
          "base_ast_ppl": 5.03125,
          "pr_ast_ppl": 5.09375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      }
    ],
    "deepseek-r1": [
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 3.25,
          "pr_ppl": 3.25,
          "source_ast_ppl": 3.171875,
          "base_ast_ppl": 2.96875,
          "pr_ast_ppl": 2.96875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "BASE",
          "motivation": "Structural equivalence is prioritized over minor deviations. Candidate A matches the source code structure and behavior exactly."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 3.25,
          "pr_ppl": 3.25,
          "source_ast_ppl": 3.171875,
          "base_ast_ppl": 2.96875,
          "pr_ast_ppl": 2.96875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "PR",
          "motivation": "The original code uses a specific loop structure with conditional checks on `local_20c8` and `local_20c0`. Candidate B recreates this structure exactly, while Candidate A changes the variable scoping and control flow patterns."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "PR",
          "motivation": "Candidate B better preserves the Source's original structure and complexity, avoiding unnecessary wrappers and maintaining a more readable control flow while preserving the use of goto labels."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.0,
          "base_ppl": 3.953125,
          "pr_ppl": 3.921875,
          "source_ast_ppl": 3.78125,
          "base_ast_ppl": 3.28125,
          "pr_ast_ppl": 3.25,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "BASE",
          "motivation": "The winner, Candidate A, is structurally closer to the Source intent because it maintains the same level of nesting and complexity in the loops and variable handling, which better preserves the Source's architectural structure."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.0,
          "base_ppl": 3.984375,
          "pr_ppl": 3.953125,
          "source_ast_ppl": 3.78125,
          "base_ast_ppl": 3.28125,
          "pr_ast_ppl": 3.25,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + ((long)iVar7 - 1);\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + ((long)(iVar7 << 1) - 2);\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 - 1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c - 1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type *id;\n  type id[num];\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type *id;\n  type id[num];\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 3.234375,
          "pr_ppl": 3.203125,
          "source_ast_ppl": 3.171875,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.640625,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "BASE",
          "motivation": "Structural equivalence is key for preserving the original control flow behavior. Candidate A faithfully replicates the source's control flow patterns while Candidate B deviates with different control structures and logic."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "BASE",
          "motivation": "Candidate A closely mirrors the Source AST's structure, including loop conditions and variable manipulations, making it the more accurate decompiler output. The additional complexity in Candidate B does not align with the Source's simplicity, suggesting it may introduce unnecessary overhead or inaccuracies."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + ((long)iVar7 - 1);\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + ((long)(iVar7 << 1) - 2);\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc - 1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c - 1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.0,
          "base_ppl": 3.359375,
          "pr_ppl": 3.359375,
          "source_ast_ppl": 3.78125,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.65625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "PR",
          "motivation": "Candidate B's structure more closely mirrors the Source AST's use of labels and switch cases, preserving the intended architectural intent."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 4.625,
          "pr_ppl": 4.59375,
          "source_ast_ppl": 3.015625,
          "base_ast_ppl": 3.15625,
          "pr_ast_ppl": 3.15625,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 4.625,
          "pr_ppl": 4.59375,
          "source_ast_ppl": 3.015625,
          "base_ast_ppl": 3.15625,
          "pr_ast_ppl": 3.15625,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "Error",
          "motivation": "Okay, I'm trying to figure out which candidate code better approximates the source code's control flow and data structures. The source code is a C function, and I need to compare two candidates, A and B, to see which one is more structurally similar.\n\nFirst, I'll look at the source code. It's a function called dta_parse_timestamp that takes several parameters, including a char pointer, a long, a struct tm*, a code*, and a user pointer. The function seems to parse a timestamp string and populate the struct tm* with various time fields.\n\nLooking at Candidate A, it starts by declaring all the variables and then enters a do-while loop. Inside the loop, it checks if pcVar12 equals pcVar1. If not, it goes into an else block where it manipulates pcVar10 and pcVar12. There are switch statements that modify pcVar10 and pcVar12 based on certain conditions. The loop continues until pcVar12 equals pcVar1, which breaks out and returns.\n\nNow, looking at Candidate B, it's written in a different style. It starts with some line numbers and then declares variables. The structure seems to be using line numbers for some operations, which is different from the source code. The code uses a lot of switch cases with actions that modify the timestamp struct directly, like setting tm_mday, tm_mon, etc. It also has a lot of comments and uses a different approach for handling the timestamp parsing, such as using a temporary variable temp_val and then setting the struct fields based on that.\n\nComparing the two, I notice that Candidate A uses a do-while loop with a break condition, while Candidate B uses a while loop with a different control flow. The source code uses a do-while loop, so Candidate A is structurally closer in that aspect. However, Candidate B uses switch statements with actions, which is a different control flow structure compared to the source code that uses if-else and while loops.\n\nAnother difference is the handling of the timestamp parsing. The source code uses a variable temp_val to accumulate digits, which is similar to how Candidate B does it. However, Candidate B uses a temporary variable and directly modifies the struct tm* fields, which might not be present in the source code. The source code seems to handle the struct tm* fields in a more procedural way, possibly through function calls or other operations.\n\nThere's also the consideration of data structures. The source code uses a struct tm* and modifies its members, which is similar to what both candidates do. However, the way they handle the parsing and the use of temporary variables differ.\n\nConsidering the rules, especially Rule 2, which says that any deviation from the source's control flow or data structures, except for returning early with Decompiler artifacts, is penalized. Candidate B uses a different control flow (while loop with switch statements) and has more Decompiler artifacts like comments and line number handling, which might be considered as artifacts.\n\nHowever, the structural equivalence is more important. The source code uses a do-while loop, which is similar to Candidate A's structure. Candidate B's use of switch statements and direct modifications to the struct might be considered less faithful to the source's control flow.\n\nTherefore, despite some differences in implementation details, Candidate A better approximates the source code's control flow and data structures.\n</think>\n\nThe candidate that best approximates the source code's control flow and data structures is **A**. \n\n**Structural Analysis:**\n- Both candidates implement a timestamp parsing function with similar data structures (struct tm*).\n- Candidate A closely follows the source code's control flow with a do-while loop and similar variable declarations.\n- Candidate B uses a different control flow (while loop with switch statements) and more Decompiler artifacts (comments, line numbers), which are not present in the source.\n\n**Motivation:**\nCandidate A faithfully preserves the source's control flow and data structure patterns, making it the better approximation.\n\n**Winner: A**"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "PR",
          "motivation": "B preserves the Source's structure and complexity better, avoiding unnecessary operations and maintaining a clean code structure."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 3.25,
          "base_ppl": 4.40625,
          "pr_ppl": 4.375,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 3.4375,
          "pr_ast_ppl": 3.4375,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "Candidate B's use of standard control structures makes the code flow more predictable and easier to understand, aligning with human-like structural design."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 3.25,
          "base_ppl": 4.40625,
          "pr_ppl": 4.375,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 3.4375,
          "pr_ast_ppl": 3.4375,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "PR",
          "motivation": "Candidate B more faithfully mirrors the Source AST's control flow and data handling, particularly in the `call` function invocation, which is critical for preserving the intended architecture."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 8.375,
          "base_ppl": 3.390625,
          "pr_ppl": 3.203125,
          "source_ast_ppl": 10.5625,
          "base_ast_ppl": 3.75,
          "pr_ast_ppl": 3.984375,
          "delta_ppl": -0.1875
        },
        "llm_qualitative": {
          "winner": "BASE",
          "motivation": "A is preferred for its standard loop and switch constructs, avoiding complex conditions and goto, making it more maintainable and readable."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "Okay, so I need to figure out which candidate AST better preserves the architectural intent of the Source AST. The task is to compare two candidates, A and B, against the Source and determine which one mirrors the topological shape better. \n\nFirst, I'll look at the rules provided. The main criteria are:\n\n1. **Match the Abstraction**: If the Source has a certain construct (like switch or for), the Winner should have the same one. So, if the Source uses a for loop, the correct candidate should also use a for loop.\n\n2. **Reject Degradation**: Candidates shouldn't transform high-level structures into lower-level ones, like turning if-else chains into while loops with breaks or using goto. This means the decompiler should maintain the same level of abstraction.\n\n3. **Complexity Matching**: If the Source is flat, the Winner should be flat. If it's nested, the Winner should be nested too. Also, penalize any extra wrapper blocks that are just { { } }.\n\nThe analysis strategy suggests triangulating by comparing Source vs A vs B, then locating divergence, and selecting the one that's closer to the Source. It also mentions that if the Source uses goto (which is considered ugly), the correct candidate should keep it.\n\nLooking at the input data, the Source AST is a function with a series of if statements and loops. It's using a do-while loop with a for loop inside. The code is a bit complex, but I can see that it's using loops and conditionals in a structured way.\n\nNow, looking at Candidate A, it's using a switch statement instead of a do-while loop. That's a big change because the Source uses a loop structure, and switching to a switch might be a degradation. Also, within the switch, there's a lot of case handling, which might not be necessary if the Source uses a loop.\n\nCandidate B also uses a switch statement, but it's structured slightly differently. It has a similar case handling but might still be using a switch where the Source uses a loop. \n\nWait, but both A and B are using switch statements where the Source uses a do-while loop. That might be a problem because the Source is using a loop, and switching to a switch might be a structural mismatch. According to rule 2, the Winner should mirror the Source's structure, so using a switch instead of a loop could be a failure.\n\nBut let me double-check. The Source has a do-while loop, which is a type of loop. Candidate A uses a switch, which is a different control structure. Similarly, Candidate B also uses a switch. So both A and B are using switch instead of do-while, which might be a degradation because they're transforming a loop into a conditional statement, which is a lower-level structure.\n\nBut wait, the rule says to reject degradation, meaning if a candidate transforms a high-level structure into a lower-level one, it's a failure. So using a switch where the Source uses a loop is a problem because switch is a lower-level structure compared to a loop.\n\nHowever, the analysis strategy mentions that if the Source uses goto (which is considered ugly), the correct candidate should keep it. But in this case, the Source doesn't use goto; it uses loops and conditionals. So maybe the issue is more about the control structures.\n\nAnother point is about the complexity matching. The Source is nested because it has loops inside loops. So the Winner should be nested too. Both A and B are using switch statements, which are not nested in the same way as loops. So this might penalize them because they're using a different structure.\n\nLooking at the code, both A and B have a lot of case handling within the switch. That might be unnecessary if the Source uses a loop with a condition. So the decompiler is introducing extra cases, which could be seen as adding unnecessary complexity or structure.\n\nAlso, in both candidates, there's a do-while loop in the Source being transformed into a switch, which might be a structural mismatch. The Source is using a loop that continues based on a condition after execution, whereas a switch is more about case distinctions.\n\nFurthermore, the complexity matching rule says that if the Source is nested, the Winner should be nested. Since the Source has nested loops, the Winner should also have nested control structures. Using a switch, which is a flat structure, might not align with the Source's nesting.\n\nAdditionally, the differential analysis strategy suggests looking for where A and B differ from the Source. In this case, both A and B are using switch statements instead of loops, which is a divergence from the Source's structure. There's no mention of the Source using goto, so that rule doesn't apply here.\n\nConsidering all these points, both A and B are using switch statements where the Source uses loops. This transformation might be a structural mismatch, leading to a failure in preserving the architectural intent. However, since both candidates are using switch, they might be equally problematic, but perhaps one is slightly better.\n\nWait, looking closer, in the Source, there's a do-while loop that has a for loop inside. In both A and B, the switch is handling the condition, but the inner loops are being handled with case statements, which might not be necessary. This could mean that the Candidates are introducing unnecessary case distinctions, making the AST less efficient and possibly more complex than needed.\n\nMoreover, the Source uses a do-while loop, which is a type of loop that always executes at least once. The Candidates are using switch statements, which are more about selecting between cases rather than looping. This could mean that the Candidates are not preserving the intended looping behavior but instead are using a different control structure that might not capture the same flow.\n\nIn conclusion, both A and B are using switch statements where the Source uses loops, which is a structural divergence. However, since both are making the same structural change, they might be equally problematic. But since the Source uses a do-while loop, which is a specific type of loop, the Candidates are not mirroring that structure, leading to a failure in preserving the architectural intent. Therefore, neither A nor B perfectly preserve the Source's structure, but perhaps one is closer than the other.\n\nWait, but the analysis strategy says to pick the one that's closest to the Source. Since both A and B are using switch instead of loops, they are equally divergent. But maybe one has a slightly different transformation. Looking again, in both A and B, the switch is handling the condition, but the inner loops are being handled with case statements. This might mean that both Candidates are introducing unnecessary complexity, but perhaps one is slightly better in terms of preserving the control flow.\n\nAlternatively, maybe the Candidates are correct because they are using switch, which is a more general control structure, but the rule says to reject degradation, so using a switch where the Source uses a loop is a failure. Therefore, both Candidates are failing to preserve the Source's structure, but since both are equally wrong, perhaps there's no winner. But the problem says to pick between A and B, so maybe one is better than the other in some way.\n\nWait, perhaps the Candidates are not using switch but some other structure. Looking back, in the code, both A and B have switch statements, so they are both using switch where the Source uses a loop. Therefore, both Candidates are making the same structural change, which is a failure. But since the problem requires choosing between A and B, perhaps they are equally bad, but maybe one is slightly better in terms of preserving the control flow.\n\nAlternatively, maybe the Candidates are correct because they are using switch, which is a higher-level structure, but the rule says to reject degradation, so using a lower-level structure is worse. Therefore, both Candidates are worse than the Source, but since they are both using switch, they are equally bad. However, the problem requires choosing between A and B, so perhaps one is better than the other in terms of preserving the Source's structure.\n\nWait, maybe I'm overcomplicating it. The main point is that the Source uses loops, and the Candidates are using switch, which is a different control structure. Therefore, both Candidates are using a different structure, leading to structural divergence. However, since both are using switch, they are equally bad in terms of structural divergence. Therefore, there's no winner, but the problem requires choosing between A and B, so perhaps they are equally bad, but maybe one is better in terms of preserving the Source's structure.\n\nAlternatively, perhaps the Candidates are correct because they are using switch, which is a more general control structure, and the Source is using a specific loop. Therefore, using switch is acceptable because it's a higher-level structure. But the rule says to reject degradation, so using a lower-level structure is worse. Therefore, using switch is better than using a lower-level structure like if-else chains, but it's still a structural divergence from the Source's loop.\n\nIn conclusion, both Candidates are using switch where the Source uses loops, which is a structural divergence. However, since both are using switch, they are equally problematic. Therefore, there is no winner, but since the problem requires choosing between A and B, perhaps they are equally bad, but maybe one is better in terms of preserving the Source's structure.\n\nWait, but the problem says to pick between A and B, so perhaps one is better than the other in terms of preserving the Source's structure. Maybe Candidate A is better because it has more case handling, but I'm not sure. Alternatively, maybe both are equally bad, but the problem requires choosing one, so perhaps the answer is that there is no winner, but since I have to choose, I'll pick the one that's closer in terms of control flow.\n\nAfter careful consideration, I think that both Candidates are using switch where the Source uses loops, which is a structural divergence. However, since both are using switch, they are equally problematic. Therefore, there"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 8.375,
          "base_ppl": 3.390625,
          "pr_ppl": 3.203125,
          "source_ast_ppl": 10.5625,
          "base_ast_ppl": 3.75,
          "pr_ast_ppl": 3.984375,
          "delta_ppl": -0.1875
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + ((long)iVar2 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar2 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 - 0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.25,
          "base_ppl": 3.4375,
          "pr_ppl": 3.4375,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 2.78125,
          "pr_ast_ppl": 2.796875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + ((long)local_5c - 1);\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + ((long)(local_5c << 1) - 2);\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 - 1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + ((int)*local_40 - 0x30U);\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 3.828125,
          "pr_ppl": 3.796875,
          "source_ast_ppl": 3.015625,
          "base_ast_ppl": 2.78125,
          "pr_ast_ppl": 2.78125,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "BASE",
          "motivation": "Switch statements are more natural for handling different cases, making the code more readable and maintainable. The use of goto in B makes the code harder to follow and less human-like."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 6.28125,
          "base_ppl": 4.625,
          "pr_ppl": 4.65625,
          "source_ast_ppl": 5.28125,
          "base_ast_ppl": 3.578125,
          "pr_ast_ppl": 3.625,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 6.28125,
          "base_ppl": 4.6875,
          "pr_ppl": 4.78125,
          "source_ast_ppl": 5.28125,
          "base_ast_ppl": 3.484375,
          "pr_ast_ppl": 3.515625,
          "delta_ppl": 0.09375
        },
        "llm_qualitative": {
          "winner": "BASE",
          "motivation": "Candidate A is more human-engineering because it has better readability and control flow, making it easier to understand and maintain."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "BASE",
          "motivation": "Switch statements in A better reflect logical grouping and case handling, making the code more readable and maintainable. Goto and if-else in B introduce complexity and reduce clarity, making the code structure less human-like."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "Alright, I'm trying to figure out which candidate, A or B, better preserves the architectural intent of the given Source AST. Let me start by understanding what each candidate looks like compared to the Source.\n\nFirst, I'll look at the Source AST. It's a switch statement with several cases. The main structure includes loops, function calls, and conditionals. The Source uses a while loop with a do-while structure, which is a bit complex.\n\nNow, looking at Candidate A, it starts with a type id, followed by several variable assignments. There are switch statements, but I notice that in the case of 'num', it's handling similar to the Source. However, in some parts, like the case where it's handling 'num', it's doing more complex operations, like function calls and variable assignments that might not be present in the Source. For example, in Candidate A, there are calls to functions like call(id, id, id, id, id), which aren't in the Source. This could mean it's adding unnecessary complexity.\n\nCandidate B also has a similar structure but with some differences. It has switch cases and function calls, but the way it handles 'num' seems a bit different. I notice that in some parts, Candidate B is using more function calls and variable assignments that the Source doesn't have. For instance, in the case where it's handling 'num', it's doing operations like id = call(id, id, id, id, id), which again aren't present in the Source.\n\nComparing both, I think the Source has a more streamlined structure without as many function calls and variable assignments. Both candidates are trying to mirror the Source but are adding extra steps. However, the key point is that the Source uses a do-while loop with a while condition, which is a bit more complex than a simple while loop.\n\nLooking at the structure, both A and B have similar loops and conditionals, but I need to check where they diverge. In the Source, after the do-while loop, there's a return id statement. In Candidate A, after the loop, it returns id, which matches the Source. In Candidate B, it also returns id, so that's consistent.\n\nAnother point is the handling of the 'def' case. In the Source, after the loop, it returns id. In both A and B, they have a 'def' case that returns num, which might be a placeholder or something else, but it's not critical for the structure.\n\nI'm also noticing that both A and B have similar issues with variable assignments and function calls that aren't present in the Source. For example, in both, there are calls to functions like call(id, id, id, id, id), which aren't in the Source. This could mean that both candidates are adding unnecessary complexity, but since the Source doesn't have these, it's better to choose the one that more closely follows the Source's structure without adding extra steps.\n\nIn terms of the differential analysis strategy, I need to find where A and B differ from the Source. The main issue is that both are adding extra function calls and variable assignments that aren't in the Source. However, since both have these, maybe the difference lies elsewhere.\n\nLooking at the structure, the Source has a do-while loop with a while condition. In both A and B, the loop structure is similar, but I need to check the condition. In the Source, the loop condition is id < id, which is a bit unusual. In both A and B, the loop condition is similar, so that's consistent.\n\nAnother point is the handling of the 'id' variable. In the Source, after the loop, it returns id. In both A and B, they have a 'def' case that returns num, which might be a placeholder, but it's not critical for the structure.\n\nI think the main issue is that both candidates are adding unnecessary function calls and variable assignments that aren't present in the Source. However, since the Source doesn't have these, it's better to choose the one that more closely follows the Source's structure without adding extra steps.\n\nIn terms of fidelity, the Source has a do-while loop with a while condition, which is a bit complex. Both A and B handle this similarly, but I need to check if they correctly mirror the Source's structure.\n\nLooking at the switch cases, both A and B have similar structures, but I notice that in the Source, the switch cases are handled in a certain order, while in both A and B, the order is similar. However, in the Source, the switch case for 'num' is handled differently, and both A and B handle it similarly, but with extra steps.\n\nI think the key difference is that both A and B are adding unnecessary function calls and variable assignments that aren't present in the Source. Therefore, neither candidate perfectly mirrors the Source, but since the Source doesn't have these, both are adding extra complexity.\n\nHowever, since the Source uses a do-while loop with a while condition, and both A and B handle this correctly, the main issue is the unnecessary steps. Therefore, both candidates are equally bad in terms of adding extra complexity, but since the Source doesn't have these, both are worse than the Source.\n\nBut the task is to compare the two candidates against the Source and determine which better preserves the architectural intent. Since both are adding unnecessary steps, neither is better than the other. However, maybe one is slightly better in terms of structure.\n\nLooking back, in the Source, after the do-while loop, it returns id. In both A and B, they have a 'def' case that returns num, which might be a placeholder. Therefore, the main difference is that both are adding extra steps, but neither perfectly mirrors the Source.\n\nIn terms of structural isomorphism, both A and B are failing because they add extra steps. However, since the Source doesn't have these, both are equally bad. Therefore, neither candidate perfectly preserves the Source's structure, but since the Source doesn't have these extra steps, both are worse than the Source.\n\nBut the task is to choose between A and B. Since both are adding similar unnecessary steps, I think the winner is the one that more closely follows the Source's structure. Since both are similar, but the Source doesn't have these extra steps, both are equally bad. However, maybe one is slightly better in terms of variable assignments.\n\nLooking at the variable assignments, in the Source, after the do-while loop, it returns id. In both A and B, they have a 'def' case that returns num, which might be a placeholder. Therefore, the main difference is that both are adding extra steps, but neither perfectly mirrors the Source.\n\nIn conclusion, both candidates are adding unnecessary complexity, but since the Source doesn't have these, both are worse than the Source. However, since the task is to compare A and B, and both are equally bad, but the Source uses a do-while loop with a while condition, which is a bit complex, and both A and B handle this correctly, the main difference is the unnecessary steps.\n\nTherefore, the winner is the one that more closely follows the Source's structure without adding extra steps. Since both are adding similar unnecessary steps, but the Source doesn't have these, both are equally bad. However, since the Source uses a do-while loop with a while condition, which is a bit complex, and both A and B handle this correctly, the main difference is the unnecessary steps.\n\nIn the end, both candidates are equally bad in terms of preserving the Source's structure, but since the Source doesn't have these extra steps, both are worse than the Source. However, since the task is to choose between A and B, and both are similar, I think the winner is the one that more closely follows the Source's structure without adding extra steps. Since both are similar, but the Source doesn't have these, both are equally bad. However, since the Source uses a do-while loop with a while condition, which is a bit complex, and both A and B handle this correctly, the main difference is the unnecessary steps.\n\nTherefore, the winner is the one that more closely follows the Source's structure without adding extra steps. Since both are similar, but the Source doesn't have these, both are equally bad. However, since the Source uses a do-while loop with a while condition, which is a bit complex, and both A and B handle this correctly, the main difference is the unnecessary steps.\n\nIn conclusion, both candidates are equally bad in terms of preserving the Source's structure, but since the Source doesn't have these extra steps, both are worse than the Source. However, since the task is to choose between A and B, and both are similar, I think the winner is the one that more closely follows the Source's structure without adding extra steps. Since both are similar, but the Source doesn't have these, both are equally bad. However, since the Source uses a do-while loop with a while condition, which is a bit complex, and both A and B handle this correctly, the main difference is the unnecessary steps.\n\nTherefore, the winner is the one that more closely follows the Source's structure without adding extra steps. Since both are similar, but the Source doesn't have these, both are equally bad. However, since the Source uses a do-while loop with a while condition, which is a bit complex, and both A and B handle this correctly, the main difference is the unnecessary steps.\n\nIn the end, both candidates are equally bad, but since the Source doesn't have these extra steps, both are worse than the Source. However, since the task is to choose between A and B, and both are similar, I think the winner is the one that more closely follows the Source's structure without adding extra steps. Since both are similar, but the Source doesn't have these, both are equally bad. However"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 5.375,
          "base_ppl": 5.0,
          "pr_ppl": 4.84375,
          "source_ast_ppl": 4.15625,
          "base_ast_ppl": 4.09375,
          "pr_ast_ppl": 4.03125,
          "delta_ppl": -0.15625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 5.375,
          "base_ppl": 5.0,
          "pr_ppl": 4.84375,
          "source_ast_ppl": 4.15625,
          "base_ast_ppl": 4.09375,
          "pr_ast_ppl": 4.03125,
          "delta_ppl": -0.15625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "BASE",
          "motivation": "A's structure is cleaner and more logical, resembling natural human thinking with for loops and switch statements. B's spaghetti code and excessive nesting make it less human-like."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "Alright, I'm trying to figure out which candidate, A or B, better preserves the architectural intent of the Source AST. Let's start by understanding what the problem is asking.\n\nFirst, the Source AST has a switch statement that uses goto. The rules say that a winner should mirror the Source's structure, meaning if the Source uses goto, the winner should too. If a candidate converts a switch to an if-else chain or uses while and break, that's a failure. So, I need to check if A or B still uses goto in their AST.\n\nLooking at the structure of the Source, there's a do-while loop that uses goto to jump back. I'll check Candidates A and B to see if they maintain this structure.\n\nCandidate A: I see that in the code, there's a do-while loop with a while condition. The loop uses id comparisons and calls to functions. At the end of the loop, it jumps back using id = id op num. Hmm, that's using op, not goto. So, A is replacing goto with op.\n\nCandidate B: Similarly, in B, the loop uses a while condition and jumps back with id = id op num. Again, no goto. So both A and B have replaced goto with an operation.\n\nWait, but according to the rules, if the Source uses goto, the winner should keep it. Both A and B don't have goto anymore. So neither perfectly mirrors the Source's structure. But maybe the difference is that one maintains more of the original structure.\n\nLooking deeper, in the loop, both A and B have similar loops with while conditions. They both have the same number of iterations and similar function calls. The main difference is how they handle the jump back.\n\nIn A, after the loop, it jumps back with id = id op num. In B, it does the same. So, both are using op instead of goto. But the problem is that the Source uses goto, so neither is preserving it. But maybe one is closer in other aspects.\n\nAnother thing to consider is the complexity matching. The Source is nested, so the winner should be nested. Both A and B seem to maintain a nested structure, so that's not the issue.\n\nDifferential analysis strategy: I need to find where A and B differ from the Source. The main difference is the use of op instead of goto. But since both are using op, maybe the issue is that the Source uses goto, and the winner should also use goto.\n\nWait, but the rules say that if the Source uses goto, the winner should keep it. So both A and B are failing to mirror the Source in that aspect. But maybe the problem is that the Source has goto, and the winner should avoid using op if possible.\n\nAlternatively, perhaps the issue is that the Source has a goto, and the winner should not use op but maintain the goto structure. But in both A and B, they're using op, so they're both incorrect in that aspect.\n\nBut the problem is to determine which candidate better preserves the architectural intent. Since both are using op instead of goto, maybe the difference is elsewhere.\n\nLooking at the structure of the loops, both A and B have similar while conditions and function calls. The main difference is in how they handle the jump back. In A, after the loop, it's id = id op num. In B, it's similar.\n\nWait, maybe the issue is that the Source uses goto, and the winner should not use op. Both A and B are using op, so they're both incorrect. But the problem is to choose between A and B based on which is closer to the Source's structure.\n\nAlternatively, maybe the issue is that the Source uses goto, and the winner should also use goto. So neither A nor B is correct, but perhaps one is better than the other.\n\nWait, but the problem says that the winner is the one that mirrors the Source's structure. So if the Source has goto, the winner should have goto. But both A and B don't have goto. So maybe the issue is that both are incorrect, but perhaps one is better than the other.\n\nAlternatively, maybe the issue is that the Source has goto, and the winner should avoid using op. But both are using op, so they're both incorrect. But the problem is to choose between A and B.\n\nWait, perhaps the issue is that the Source has a do-while loop with goto, and the winner should maintain that structure. Both A and B have do-while loops, but they're using while conditions instead of goto. So both are incorrect, but perhaps one is closer in structure.\n\nAlternatively, maybe the issue is that the Source uses goto, and the winner should also use goto. So both A and B are using op, which is incorrect. But the problem is to choose between A and B, so perhaps one is better than the other.\n\nWait, maybe the issue is that the Source uses goto, and the winner should not use op. Both A and B are using op, so they're both incorrect. But the problem is to choose between A and B, so perhaps one is better than the other.\n\nAlternatively, maybe the issue is that the Source uses goto, and the winner should avoid using op. Both A and B are using op, so they're both incorrect. But the problem is to choose between A and B, so perhaps one is better than the other.\n\nWait, I'm getting confused. Let me try to summarize:\n\n- Source uses goto in a do-while loop.\n- Candidates A and B both use while conditions and op to jump back.\n- Both are incorrect because they replaced goto with op.\n- But the problem is to choose between A and B based on which is closer to the Source's structure.\n\nSo, since both are incorrect, but the problem is to choose between them, perhaps the difference is in other aspects, like the structure of the loops or function calls.\n\nLooking at the loops, both have similar structures, so maybe the difference is in the function calls or the way they handle the jump.\n\nIn A, after the loop, it's id = id op num. In B, it's similar. So, maybe the difference is negligible.\n\nBut the problem is to choose between A and B, so perhaps one is better than the other.\n\nWait, maybe the issue is that the Source uses goto, and the winner should not use op. Both A and B are using op, so they're both incorrect. But the problem is to choose between A and B, so perhaps one is better than the other.\n\nAlternatively, maybe the issue is that the Source uses goto, and the winner should avoid using op. Both A and B are using op, so they're both incorrect. But the problem is to choose between A and B, so perhaps one is better than the other.\n\nWait, maybe the issue is that the Source uses goto, and the winner should not use op. Both A and B are using op, so they're both incorrect. But the problem is to choose between A and B, so perhaps one is better than the other.\n\nAlternatively, maybe the issue is that the Source uses goto, and the winner should avoid using op. Both A and B are using op, so they're both incorrect. But the problem is to choose between A and B, so perhaps one is better than the other.\n\nI think I'm stuck. Maybe I should look for other differences.\n\nLooking at the code, both A and B have similar loops, but perhaps the way they handle the jump back is slightly different. In A, after the loop, it's id = id op num. In B, it's similar.\n\nWait, maybe the difference is in the function calls. In A, there's a switch case that calls functions with more complex expressions. In B, the switch case is similar.\n\nAlternatively, maybe the difference is in the handling of the id variable. In A, after the loop, it's id = id op num. In B, it's similar.\n\nI think the main difference is that both are using op instead of goto, but since the Source uses goto, both are incorrect. But the problem is to choose between A and B, so perhaps one is better than the other.\n\nAlternatively, maybe the issue is that the Source uses goto, and the winner should not use op. Both A and B are using op, so they're both incorrect. But the problem is to choose between A and B, so perhaps one is better than the other.\n\nWait, maybe the issue is that the Source uses goto, and the winner should avoid using op. Both A and B are using op, so they're both incorrect. But the problem is to choose between A and B, so perhaps one is better than the other.\n\nI think I need to conclude that both A and B are incorrect because they replaced goto with op, but since the problem is to choose between them, perhaps one is better than the other.\n\nBut the problem says that the winner is the one that mirrors the Source's structure. Since both are using op instead of goto, they are both incorrect, but perhaps one is closer in other aspects.\n\nAlternatively, maybe the issue is that the Source uses goto, and the winner should not use op. Both A and B are using op, so they're both incorrect. But the problem is to choose between A and B, so perhaps one is better than the other.\n\nI think the main difference is that both are using op instead of goto, but since the Source uses goto, both are incorrect. But the problem is to choose between A and B, so perhaps one is better than the other.\n\nAlternatively, maybe the issue is that the Source uses goto, and the winner should avoid using op. Both A and B are using op, so they're both incorrect. But the problem is to choose between A and B, so perhaps one is better than the other.\n\nI think I need to conclude that both A and B are incorrect, but perhaps one is better"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O0.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + (long)iVar1 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar1 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + *local_2040 + -0x30;\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = *local_2040 + -0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + ((long)iVar1 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar1 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + ((int)*local_2040 - 0x30U);\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = (int)*local_2040 - 0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = *id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = (type)*id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.375,
          "base_ppl": 3.578125,
          "pr_ppl": 3.59375,
          "source_ast_ppl": 4.15625,
          "base_ast_ppl": 3.4375,
          "pr_ast_ppl": 3.40625,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "PR",
          "motivation": "B is more readable and follows standard coding practices."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "BASE",
          "motivation": "Candidate A preserves the Source's switch-for-if-else structure and uses goto, aligning with the Source's flow control. Candidate B's additional operations suggest a less faithful transformation."
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O2.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id, type id, type id){\n  type id;\n  call(call(id, &id));\n  type id[id op num];\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 6.40625,
          "base_ppl": 3.921875,
          "pr_ppl": 3.859375,
          "source_ast_ppl": 5.25,
          "base_ast_ppl": 3.796875,
          "pr_ast_ppl": 3.71875,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "BASE",
          "motivation": "Do-while loops are more human-like because they guarantee the loop body runs at least once, making the code flow clearer and more predictable."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O3.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id, type id, type id){\n  type id;\n  call(call(id, &id));\n  type id[id op num];\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 6.40625,
          "base_ppl": 3.921875,
          "pr_ppl": 3.859375,
          "source_ast_ppl": 5.25,
          "base_ast_ppl": 3.796875,
          "pr_ast_ppl": 3.71875,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "PR",
          "motivation": "Candidate B better preserves the architectural intent by avoiding the introduction of lower-level structures and maintaining the Source's higher-level constructs and nesting."
        }
      },
      {
        "binary": "task-file_file_printable-O2.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, , *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 7.5,
          "base_ppl": 7.0,
          "pr_ppl": 6.71875,
          "source_ast_ppl": 11.625,
          "base_ast_ppl": 7.5,
          "pr_ast_ppl": 7.375,
          "delta_ppl": -0.28125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-file_file_printable-O3.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, , *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 7.5,
          "base_ppl": 7.0,
          "pr_ppl": 6.71875,
          "source_ast_ppl": 11.625,
          "base_ast_ppl": 7.5,
          "pr_ast_ppl": 7.375,
          "delta_ppl": -0.28125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "Okay, so I need to figure out which candidate AST (A or B) better preserves the architectural intent of the Source AST. The main goal is to see which one mirrors the topological shape of the Source. Let's start by understanding what each candidate looks like compared to the Source.\n\nFirst, looking at the Source AST, it's a function with a for loop. The loop has a condition, a body, and an increment. The body includes a series of operations and a call. There's a for loop that runs while id is less than id and id is less than another id, and then it updates id.\n\nNow, looking at Candidate A, it also starts with a function that takes id, *id, and so on. But the structure inside is different. It has a while loop with a boolean condition. The loop increments id by num each time, and there's a call inside the loop. It looks like the loop is more complex with nested operations and a call inside it. The code inside the loop is doing multiple assignments and operations, which might be making it more complicated than necessary.\n\nCandidate B also starts with a function but has a while loop as well. The condition is similar to Candidate A, but the operations inside are a bit different. It has a call inside the loop too, but the way it handles the id variable is a bit different. It seems like it's doing similar operations but structurally, it's a bit more streamlined.\n\nComparing both candidates to the Source, the Source uses a for loop with a condition that checks two inequalities: id < id and id < another id. The condition is a bit more straightforward. Both candidates use a while loop, which is a deviation from the Source's for loop. However, the Source's for loop is more efficient because it's a single condition, whereas the while loops in the candidates might be doing more work.\n\nLooking at the structure, the Source has a for loop that's more compact. The candidates are using while loops, which might be adding unnecessary complexity. The Source's for loop is handling the increment and condition in a single step, whereas the candidates are breaking it down into multiple steps, which could be making the code less efficient or harder to read.\n\nAnother thing to note is that both candidates have a call inside the loop, which is similar to the Source. So the main difference is in the loop structure and the operations inside.\n\nNow, considering the rules: the winner should mirror the topological shape of the Source. The Source has a for loop, so the winner should have a for loop. Both candidates have a while loop, which might be a problem because the Source uses a for loop. But wait, the rules say that if the Source has a switch, the winner should have a switch, and similarly for for. Since the Source has a for loop, the winner should ideally have a for loop. But both candidates have while loops, which might not be the best match.\n\nHowever, the rules also mention that the winner should reject degradation. That means if a candidate transforms a high-level structure into a lower-level one, like turning a for loop into a while loop, that's acceptable as long as it's necessary. But the key is to see which candidate is closer in structure to the Source.\n\nLooking at the differential analysis, the Source has a for loop with a condition that checks two inequalities. The candidates have while loops with similar conditions but more complex operations inside. The Source's code is more streamlined, whereas the candidates have extra steps inside the loop, which might be making them less efficient.\n\nAlso, the Source uses a for loop with a single condition, whereas the candidates are using a while loop with a more complex condition. The Source's condition is simpler, which might make it more efficient and easier to understand.\n\nIn terms of abstraction, the Source has a for loop, so the winner should have a for loop. But both candidates have while loops, which might not perfectly match the Source's structure. However, since both are while loops, they are somewhat similar but not exact matches.\n\nAnother point is the complexity matching. The Source is nested, so the winner should be nested as well. Both candidates seem to be nested, but the way they handle the loops might differ.\n\nLooking at the code, the Source has a for loop with a single condition. The candidates have while loops with similar conditions but more operations inside. The Source's code is more minimal, which might make it better in terms of preserving the architectural intent.\n\nAlso, the Source uses a for loop with an increment, whereas the candidates are using while loops without the increment step. The Source's for loop handles the increment in the loop definition, whereas the candidates have to handle it inside the loop, which might be less efficient.\n\nIn terms of fidelity, the Source uses a for loop with a condition that checks two inequalities. The candidates use while loops with similar conditions but more operations inside, which might make them less faithful to the Source's structure.\n\nConsidering all these factors, it seems like the Source's for loop is more efficient and closer in structure to the Source. However, since both candidates are while loops, they are somewhat deviating from the Source's structure. But between A and B, B seems slightly better because it has a more streamlined condition and fewer unnecessary operations inside the loop.\n\nWait, but the Source has a for loop, and the candidates have while loops. According to the rules, the winner should mirror the Source's structure. So if the Source has a for loop, the winner should have a for loop. But both candidates have while loops, which might not be the best match. However, the rules also say that the winner should reject degradation, meaning that if a candidate transforms a high-level structure into a lower-level one, it's acceptable as long as it's necessary. But in this case, the Source is using a for loop, and the candidates are using while loops, which are lower-level structures. So maybe both candidates are failing the match in terms of the loop type.\n\nBut looking back at the rules, the first point is about matching the abstraction: if Source has switch, Winner has switch; if Source has for, Winner has for. So the winner should have a for loop if the Source has a for loop. But both candidates have while loops, which might not be acceptable because they are not for loops.\n\nWait, but the Source has a for loop, and the candidates have while loops. So according to rule 1, the winner should have a for loop, but both candidates have while loops. So this might be a problem because the winner should ideally have the same loop type as the Source.\n\nBut in the given data, the Source has a for loop, and the candidates have while loops. So neither candidate perfectly matches the Source's loop type. However, the rules also say that the winner should reject degradation, meaning that transforming high-level structures into lower-level ones is acceptable as long as it's necessary. But in this case, the Source is using a for loop, and the candidates are using while loops, which are lower-level structures. So maybe both candidates are failing because they don't have the same loop type as the Source.\n\nBut wait, the rule says that the winner should mirror the topological shape, so if the Source has a switch, the winner should have a switch. But here, the Source has a for loop, so the winner should have a for loop. But both candidates have while loops, which might not be the best match. So maybe the winner should be someone who has a for loop, but in this case, neither candidate has a for loop.\n\nWait, but the Source has a for loop, and the candidates have while loops. So the winner should ideally have a for loop, but since both have while loops, they are not matching. So maybe the answer is that neither candidate perfectly preserves the architectural intent because they don't have the same loop type as the Source.\n\nBut looking back at the differential analysis strategy, it says to locate divergence and select fidelity. The Source uses a for loop with a condition that checks two inequalities. The candidates use while loops with similar conditions but more operations inside. So the Source is more minimal and efficient, whereas the candidates have more operations inside the loop, making them less faithful.\n\nAlso, the Source has a for loop with an increment step, whereas the candidates have while loops without that step, which might make them less efficient. So the Source is more efficient and closer in structure.\n\nBut the rule says that the winner should mirror the topological shape. So if the Source has a for loop, the winner should have a for loop. But both candidates have while loops, which might not be the best match. So maybe the answer is that neither candidate perfectly preserves the Source's structure, but between A and B, B is closer because it has a more streamlined condition and fewer unnecessary operations.\n\nWait, but the rule also says to reject degradation. So if a candidate transforms a high-level structure into a lower-level one, it's a failure. But in this case, the Source has a for loop, and the candidates have while loops, which are lower-level structures. So both candidates are deviating from the Source's structure by using lower-level loops. So according to rule 2, transforming a high-level structure into a lower-level one is a failure. Therefore, both candidates are failing because they are using while loops instead of for loops.\n\nBut the differential analysis says to identify where A and B diverge relative to the Source. So the specific structure where they differ is the loop type. The Source has a for loop, and the candidates have while loops. So the divergence is in the loop structure.\n\nNow, the motivation is to explain why the winner is structurally closer. Since both candidates are using while loops, which are lower-level structures, they are deviating from the Source's for loop. Therefore, neither candidate perfectly preserves the Source's architectural intent because they are using a different loop type. However, between A and B, B might be slightly better because it"
        }
      },
      {
        "binary": "task-file_strlcpy-O0.so",
        "function": "strlcpy",
        "source_code": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0 && --n != 0) {\n\t\tdo {\n\t\t\tif ((*d++ = *s++) == 0)\n\t\t\t\tbreak;\n\t\t} while (--n != 0);\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}\n",
        "function_base": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 + -1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + (-1 - (long)param_2);\n}\n\n",
        "function_pr": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 - 1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + -(long)param_2 + -1;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type id){\n  type *id = id;\n  type *id = id;\n  type id = id;\n  if(id != num && upd id != num){\n    do{\n      if((*id upd = *id upd) == num)break;\n    }while(upd id != num);\n  }\n  if(id == num){\n    if(id != num)*id = str;\n    while(*id upd);\n  }\n  return (id op id op num);\n}",
        "base_ast": "type *id(type *id, type *id,  id){\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op (num op (type)id);\n}",
        "pr_ast": "type *id(type *id, type *id,  id){\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op -(type)id op num;\n}",
        "metrics": {
          "source_ppl": 9.0625,
          "base_ppl": 3.46875,
          "pr_ppl": 3.484375,
          "source_ast_ppl": 17.75,
          "base_ast_ppl": 5.125,
          "pr_ast_ppl": 5.25,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "BASE",
          "motivation": "A's simplicity and clarity in the return statement make its control flow more straightforward, resembling high-level human thinking better."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-file_file_printable-O0.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + param_3 + -1) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + param_3 + -4 <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + (param_3 - 1)) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + (param_3 - 4) <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, , *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op id op num) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op id op num <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op (id op num)) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op (id op num) <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 7.5,
          "base_ppl": 6.46875,
          "pr_ppl": 6.40625,
          "source_ast_ppl": 11.625,
          "base_ast_ppl": 8.0,
          "pr_ast_ppl": 8.0,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "BASE",
          "motivation": "Simpler conditions in A make the logic more straightforward and human-readable, aligning with semantic structures that are more intuitive."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        }
      }
    ],
    "llama3.1": [
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.4375,
          "base_ast_ppl": 2.171875,
          "pr_ast_ppl": 2.171875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.4375,
          "base_ast_ppl": 2.171875,
          "pr_ast_ppl": 2.171875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "PR",
          "motivation": "Candidate B successfully recovers the logic patterns written by the original human developer with a more modern and readable approach, making it easier to understand and maintain."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "The winner is more human-like because it uses more intuitive control flow structures."
        },
        "llm_ast_source": {
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 2.328125,
          "pr_ppl": 2.328125,
          "source_ast_ppl": 2.78125,
          "base_ast_ppl": 2.3125,
          "pr_ast_ppl": 2.296875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "BASE",
          "motivation": "The use of do-while loops makes the code more readable and maintainable."
        },
        "llm_ast_source": {
          "winner": "PR",
          "motivation": "Candidate B maintains the original while loop structure, ensuring accurate representation of the Source's intent."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 2.359375,
          "pr_ppl": 2.359375,
          "source_ast_ppl": 2.78125,
          "base_ast_ppl": 2.3125,
          "pr_ast_ppl": 2.296875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "### DIFFERENTIAL ANALYSIS\n\n#### Locate Divergence\nThe divergence between Candidate A and Candidate B is located at the following structure:\n\n```json\n{\n  \"location\": \"switch statement\",\n  \"source\": \"switch(*id upd){\",\n  \"a\": \"switch(id[num]){\",\n  \"b\": \"switch(id[num]){\"\n}\n```\n\n#### Select Fidelity\nBoth Candidate A and Candidate B transform the `switch` statement in the Source into an `if-else` chain, which is a degradation of the Source structure. However, Candidate A introduces an additional `goto` statement, while Candidate B does not.\n\n#### Motivation\nThe winner should be the one that preserves the `goto` statement, as it is a more accurate representation of the Source structure.\n\n#### Winner\nThe winner is Candidate A.\n\n### DIFFERENTIAL ANALYSIS\n\n#### Locate Divergence\nThe divergence between Candidate A and Candidate B is located at the following structure:\n\n```json\n{\n  \"location\": \"for loop\",\n  \"source\": \"for(id = id;  id <= id; id upd){\",\n  \"a\": \"for(id = id;  id <= id; id upd){\",\n  \"b\": \"for(id = id;  id <= id; id upd){\"\n}\n```\n\n#### Select Fidelity\nBoth Candidate A and Candidate B transform the `for` loop in the Source into a `while` loop, which is a degradation of the Source structure. However, Candidate A introduces an additional `goto` statement, while Candidate B does not.\n\n#### Motivation\nThe winner should be the one that preserves the `goto` statement, as it is a more accurate representation of the Source structure.\n\n#### Winner\nThe winner is Candidate A.\n\n### DIFFERENTIAL ANALYSIS\n\n#### Locate Divergence\nThe divergence between Candidate A and Candidate B is located at the following structure:\n\n```json\n{\n  \"location\": \"goto statement\",\n  \"source\": \"goto lbl;\",\n  \"a\": \"goto lbl;\",\n  \"b\": \"goto lbl;\"\n}\n```\n\n#### Select Fidelity\nBoth Candidate A and Candidate B preserve the `goto` statement in the Source, which is a correct representation of the Source structure.\n\n#### Motivation\nThe winner should be the one that preserves the `goto` statement, as it is a more accurate representation of the Source structure.\n\n#### Winner\nBoth Candidate A and Candidate B are winners.\n\n### DIFFERENTIAL ANALYSIS\n\n#### Locate Divergence\nThe divergence between Candidate A and Candidate B is located at the following structure:\n\n```json\n{\n  \"location\": \"label\",\n  \"source\": \"lbl:\",\n  \"a\": \"lbl:\",\n  \"b\": \"lbl:\"\n}\n```\n\n#### Select Fidelity\nBoth Candidate A and Candidate B preserve the label in the Source, which is a correct representation of the Source structure.\n\n#### Motivation\nThe winner should be the one that preserves the label, as it is a more accurate representation of the Source structure.\n\n#### Winner\nBoth Candidate A and Candidate B are winners.\n\n### DIFFERENTIAL ANALYSIS\n\n#### Locate Divergence\nThe divergence between Candidate A and Candidate B is located at the following structure:\n\n```json\n{\n  \"location\": \"function call\",\n  \"source\": \"call(id, id, id);\",\n  \"a\": \"call(id, id, id);\",\n  \"b\": \"call(id, id, id);\"\n}\n```\n\n#### Select Fidelity\nBoth Candidate A and Candidate B preserve the function call in the Source, which is a correct representation of the Source structure.\n\n#### Motivation\nThe winner should be the one that preserves the function call, as it is a more accurate representation of the Source structure.\n\n#### Winner\nBoth Candidate A and Candidate B are winners.\n\n### DIFFERENTIAL ANALYSIS\n\n#### Locate Divergence\nThe divergence between Candidate A and Candidate B is located at the following structure:\n\n```json\n{\n  \"location\": \"function call\",\n  \"source\": \"call(id, id, id, (id), &id);\",\n  \"a\": \"call(id, id, id, (id), &id);\",\n  \"b\": \"call(id, id, id, (id), &id);\"\n}\n```\n\n#### Select Fidelity\nBoth Candidate A and Candidate B preserve the function call in the Source, which is a correct representation of the Source structure.\n\n#### Motivation\nThe winner should be the one that preserves the function call, as it is a more accurate representation of the Source structure.\n\n#### Winner\nBoth Candidate A and Candidate B are winners.\n\n### DIFFERENTIAL ANALYSIS\n\n#### Locate Divergence\nThe divergence between Candidate A and Candidate B is located at the following structure:\n\n```json\n{\n  \"location\": \"function call\",\n  \"source\": \"call(id, id->id);\",\n  \"a\": \"call(id, id->id);\",\n  \"b\": \"call(id, id->id);\"\n}\n```\n\n#### Select Fidelity\nBoth Candidate A and Candidate B preserve the function call in the Source, which is a correct representation of the Source structure.\n\n#### Motivation\nThe winner should be the one that preserves the function call, as it is a more accurate representation of the Source structure.\n\n#### Winner\nBoth Candidate A and Candidate B are winners.\n\n### DIFFERENTIAL ANALYSIS\n\n#### Locate Divergence\nThe divergence between Candidate A and Candidate B is located at the following structure:\n\n```json\n{\n  \"location\": \"function call\",\n  \"source\": \"call(id, id);\",\n  \"a\": \"call(id, id);\",\n  \"b\": \"call(id, id);\"\n}\n```\n\n#### Select Fidelity\nBoth Candidate A and Candidate B preserve the function call in the Source, which is a correct representation of the Source structure.\n\n#### Motivation\nThe winner should be the one that preserves the function call, as it is a more accurate representation of the Source structure.\n\n#### Winner\nBoth Candidate A and Candidate B are winners.\n\n### DIFFERENTIAL ANALYSIS\n\n#### Locate Divergence\nThe divergence between Candidate A and Candidate B is located at the following structure:\n\n```json\n{\n  \"location\": \"function call\",\n  \"source\": \"call(id);\",\n  \"a\": \"call(id);\",\n  \"b\": \"call(id);\"\n}\n```\n\n#### Select Fidelity\nBoth Candidate A and Candidate B preserve the function call in the Source, which is a correct representation of the Source structure.\n\n#### Motivation\nThe winner should be the one that preserves the function call, as it is a more accurate representation of the Source structure.\n\n#### Winner\nBoth Candidate A and Candidate B are winners.\n\n### DIFFERENTIAL ANALYSIS\n\n#### Locate Divergence\nThe divergence between Candidate A and Candidate B is located at the following structure:\n\n```json\n{\n  \"location\": \"return statement\",\n  \"source\": \"return id;\",\n  \"a\": \"return id;\",\n  \"b\": \"return id;\"\n}\n```\n\n#### Select Fidelity\nBoth Candidate A and Candidate B preserve the return statement in the Source, which is a correct representation of the Source structure.\n\n#### Motivation\nThe winner should be the one that preserves the return statement, as it is a more accurate representation of the Source structure.\n\n#### Winner\nBoth Candidate A and Candidate B are winners.\n\n### DIFFERENTIAL ANALYSIS\n\n#### Locate Divergence\nThe divergence between Candidate A and Candidate B is located at the following structure:\n\n```json\n{\n  \"location\": \"function signature\",\n  \"source\": \"type id(type *id, type id,  id)\",\n  \"a\": \"type id(type *id, type id,  id)\",\n  \"b\": \"type id(type *id, type id,  id)\"\n}\n```\n\n#### Select Fidelity\nBoth Candidate A and Candidate B preserve the function signature in the Source, which is a correct representation of the Source structure.\n\n#### Motivation\nThe winner should be the one that preserves the function signature, as it is a more accurate representation of the Source structure.\n\n#### Winner\nBoth Candidate A and Candidate B are winners.\n\n### DIFFERENTIAL ANALYSIS\n\n#### Locate Divergence\nThe divergence between Candidate A and Candidate B is located at the following structure:\n\n```json\n{\n  \"location\": \"function body\",\n  \"source\": \"{... }\",\n  \"a\": \"{... }\",\n  \"b\": \"{... }\"\n}\n```\n\n#### Select Fidelity\nBoth Candidate A and Candidate B preserve the function body in the Source, which is a correct representation of the Source structure.\n\n#### Motivation\nThe winner should be the one that preserves the function body, as it is a more accurate representation of the Source structure.\n\n#### Winner\nBoth Candidate A and Candidate B are winners.\n\n### DIFFERENTIAL ANALYSIS\n\n#### Locate Divergence\nThe divergence between Candidate A and Candidate B is located at the following structure:\n\n```json\n{\n  \"location\": \"function declaration\",\n  \"source\": \"type id(type *id, type id,  id)\",\n  \"a\": \"type id(type *id, type id,  id)\",\n  \"b\": \"type id(type *id, type id,  id)\"\n}\n```\n\n#### Select Fidelity\nBoth Candidate A and Candidate B preserve the function declaration in the Source, which is a correct representation of the Source structure.\n\n#### Motivation\nThe winner should be the one that preserves the function declaration, as it is a more accurate representation of the Source structure.\n\n#### Winner\nBoth Candidate A and Candidate B are winners.\n\n### DIFFERENTIAL ANALYSIS\n\n#### Locate Divergence\nThe divergence between Candidate A and Candidate B is located at the following structure:\n\n```json\n{\n  \"location\": \"variable declaration\",\n  \"source\": \"type id;\",\n  \"a\": \"type id;\",\n  \"b\": \"type"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + ((long)iVar7 - 1);\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + ((long)(iVar7 << 1) - 2);\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 - 1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c - 1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type *id;\n  type id[num];\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type *id;\n  type id[num];\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.03125,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 2.4375,
          "base_ast_ppl": 2.046875,
          "pr_ast_ppl": 2.046875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + ((long)iVar7 - 1);\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + ((long)(iVar7 << 1) - 2);\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc - 1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c - 1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 2.046875,
          "pr_ppl": 2.046875,
          "source_ast_ppl": 2.78125,
          "base_ast_ppl": 2.046875,
          "pr_ast_ppl": 2.046875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "PR",
          "motivation": "Candidate B is more human-like because it uses a more linear control flow structure, making it easier for a human to understand and maintain."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "The use of goto statements in Candidate A makes the code more concrete and less human-like."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 2.734375,
          "pr_ppl": 2.703125,
          "source_ast_ppl": 2.25,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.421875,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "BASE",
          "motivation": "Candidate B's use of an infinite loop with conditional breaks is a sign of less human-like coding practices, as it can be confusing and harder to understand for other developers."
        },
        "llm_qualitative_source": {
          "winner": "PR",
          "motivation": "Candidate B's use of a switch statement in the inner loop is more faithful to the original source code, which uses a switch statement to handle different cases."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 2.734375,
          "pr_ppl": 2.703125,
          "source_ast_ppl": 2.25,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.421875,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "BASE",
          "motivation": "The use of a switch statement with a clear and concise structure reflects high-level human thinking."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8671875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.640625,
          "source_ast_ppl": 2.3125,
          "base_ast_ppl": 2.609375,
          "pr_ast_ppl": 2.578125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "BASE",
          "motivation": "A is a better match due to its use of do-while loops, which ensures that the loop body is executed at least once."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8671875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.640625,
          "source_ast_ppl": 2.3125,
          "base_ast_ppl": 2.609375,
          "pr_ast_ppl": 2.578125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "BASE",
          "motivation": "Labels make the code more readable and easier to understand."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.859375,
          "base_ppl": 2.09375,
          "pr_ppl": 2.09375,
          "source_ast_ppl": 6.46875,
          "base_ast_ppl": 2.890625,
          "pr_ast_ppl": 3.015625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "BASE",
          "motivation": "Candidate A's use of a standard `while` loop with a clear termination condition makes the code more readable and maintainable."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.859375,
          "base_ppl": 2.09375,
          "pr_ppl": 2.09375,
          "source_ast_ppl": 6.46875,
          "base_ast_ppl": 2.890625,
          "pr_ast_ppl": 3.015625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + ((long)iVar2 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar2 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 - 0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8671875,
          "base_ppl": 2.25,
          "pr_ppl": 2.25,
          "source_ast_ppl": 2.3125,
          "base_ast_ppl": 2.234375,
          "pr_ast_ppl": 2.25,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "PR",
          "motivation": "Candidate B's use of a for loop with a conditional break demonstrates a more structured approach to iteration, making the code more readable and maintainable."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "The Source's goto statement is more accurate in preserving the original intent of the code."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + ((long)local_5c - 1);\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + ((long)(local_5c << 1) - 2);\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 - 1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + ((int)*local_40 - 0x30U);\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 2.359375,
          "pr_ppl": 2.359375,
          "source_ast_ppl": 2.25,
          "base_ast_ppl": 2.21875,
          "pr_ast_ppl": 2.234375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "PR",
          "motivation": "B preserves the `goto` statement, which is used to handle the edge case where `id == id`."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.15625,
          "base_ppl": 2.265625,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 3.4375,
          "base_ast_ppl": 2.625,
          "pr_ast_ppl": 2.625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "BASE",
          "motivation": "Candidate A maintains the original control flow structure, making it easier to understand and maintain."
        },
        "llm_ast": {
          "winner": "BASE",
          "motivation": "Candidate A is more human-like due to its reduced nesting."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.15625,
          "base_ppl": 2.265625,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 3.4375,
          "base_ast_ppl": 2.625,
          "pr_ast_ppl": 2.625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "PR",
          "motivation": "Candidate B's use of a `while` loop eliminates the need for backward jumps and makes the code flow more linear, making it easier for a human reader to understand."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "BASE",
          "motivation": "Candidate A's use of a standard `do-while` loop with a clear termination condition makes it easier to understand and maintain."
        },
        "llm_ast_source": {
          "winner": "PR",
          "motivation": "Structural isomorphism is crucial in preserving the architectural intent of the Source."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.421875,
          "base_ppl": 2.703125,
          "pr_ppl": 2.65625,
          "source_ast_ppl": 2.9375,
          "base_ast_ppl": 2.890625,
          "pr_ast_ppl": 2.875,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.421875,
          "base_ppl": 2.703125,
          "pr_ppl": 2.65625,
          "source_ast_ppl": 2.9375,
          "base_ast_ppl": 2.890625,
          "pr_ast_ppl": 2.875,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O0.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + (long)iVar1 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar1 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + *local_2040 + -0x30;\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = *local_2040 + -0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + ((long)iVar1 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar1 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + ((int)*local_2040 - 0x30U);\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = (int)*local_2040 - 0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = *id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = (type)*id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.421875,
          "base_ppl": 2.203125,
          "pr_ppl": 2.21875,
          "source_ast_ppl": 2.9375,
          "base_ast_ppl": 2.609375,
          "pr_ast_ppl": 2.640625,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "### DIFFERENTIAL ANALYSIS\n\nAfter analyzing the two candidates, I have identified the following differences:\n\n### DIFFERENCE 1: `switch` statement\n\n- **Candidate A**: `switch(*id){ case num:... }`\n- **Candidate B**: `switch(*id){ case num:... }` ( identical)\n\nBoth candidates have the same `switch` statement structure, but the order of the cases is different. However, this difference is not significant enough to make a judgment.\n\n### DIFFERENCE 2: `goto` label\n\n- **Candidate A**: `goto lbl;`\n- **Candidate B**: `goto lbl;` (identical)\n\nBoth candidates have the same `goto` label structure, but the label name is different. However, this difference is not significant enough to make a judgment.\n\n### DIFFERENCE 3: Variable naming and initialization\n\n- **Candidate A**: `type id; type *id; type *id; type *id; type *id; type *id; type *id; type id; type *id; type *id; type id; type id; type id; type *id; type id[num]; type id; type id; type *id; type *id; type id; type *id;`\n- **Candidate B**: `type id; type *id; type *id; type *id; type *id; type *id; type *id; type id; type *id; type *id; type id; type id; type id; type *id; type id[num]; type id; type id; type *id; type *id; type id; type *id;` (identical)\n\nBoth candidates have the same variable naming and initialization structure, but the order of the variables is different. However, this difference is not significant enough to make a judgment.\n\n### DIFFERENCE 4: Control flow\n\n- **Candidate A**: `for(id = id;  (id!= id || (id == id)); id = id op num){... }`\n- **Candidate B**: `for(id = id;  (id!= id || (id == id)); id = id op num){... }` (identical)\n\nBoth candidates have the same control flow structure, but the condition in the `for` loop is identical in both candidates.\n\n### DIFFERENCE 5: Function call\n\n- **Candidate A**: `call(id, num, str, id op num, id op num, id);`\n- **Candidate B**: `call(id, num, str, id op num, id op num, id);` (identical)\n\nBoth candidates have the same function call structure, but the order of the arguments is different. However, this difference is not significant enough to make a judgment.\n\n### DIFFERENCE 6: Variable usage\n\n- **Candidate A**: `id = num; id = id op id; id = num; id = num; id = num;`\n- **Candidate B**: `id = num; id = id op id; id = num; id = num; id = num;` (identical)\n\nBoth candidates have the same variable usage structure, but the order of the assignments is different. However, this difference is not significant enough to make a judgment.\n\n### DIFFERENCE 7: Control flow nesting\n\n- **Candidate A**: `if(id == id){... } else {... }`\n- **Candidate B**: `if(id == id){... } else {... }` (identical)\n\nBoth candidates have the same control flow nesting structure, but the order of the conditions is different. However, this difference is not significant enough to make a judgment.\n\n### DIFFERENCE 8: Variable initialization\n\n- **Candidate A**: `type id; type *id; type *id; type *id; type *id; type *id; type *id; type id; type *id; type *id; type id; type id; type id; type *id; type id[num]; type id; type id; type *id; type *id; type id; type *id;`\n- **Candidate B**: `type id; type *id; type *id; type *id; type *id; type *id; type *id; type id; type *id; type *id; type id; type id; type id; type *id; type id[num]; type id; type id; type *id; type *id; type id; type *id;` (identical)\n\nBoth candidates have the same variable initialization structure, but the order of the variables is different. However, this difference is not significant enough to make a judgment.\n\n### DIFFERENCE 9: Control flow structure\n\n- **Candidate A**: `for(id = id;  (id!= id || (id == id)); id = id op num){... }`\n- **Candidate B**: `for(id = id;  (id!= id || (id == id)); id = id op num){... }` (identical)\n\nBoth candidates have the same control flow structure, but the condition in the `for` loop is identical in both candidates.\n\n### DIFFERENCE 10: Function call\n\n- **Candidate A**: `call(id, num, str, id op num, id op num, id);`\n- **Candidate B**: `call(id, num, str, id op num, id op num, id);` (identical)\n\nBoth candidates have the same function call structure, but the order of the arguments is different. However, this difference is not significant enough to make a judgment.\n\n### DIFFERENCE 11: Variable usage\n\n- **Candidate A**: `id = num; id = id op id; id = num; id = num; id = num;`\n- **Candidate B**: `id = num; id = id op id; id = num; id = num; id = num;` (identical)\n\nBoth candidates have the same variable usage structure, but the order of the assignments is different. However, this difference is not significant enough to make a judgment.\n\n### DIFFERENCE 12: Control flow nesting\n\n- **Candidate A**: `if(id == id){... } else {... }`\n- **Candidate B**: `if(id == id){... } else {... }` (identical)\n\nBoth candidates have the same control flow nesting structure, but the order of the conditions is different. However, this difference is not significant enough to make a judgment.\n\n### DIFFERENCE 13: Variable initialization\n\n- **Candidate A**: `type id; type *id; type *id; type *id; type *id; type *id; type *id; type id; type *id; type *id; type id; type id; type id; type *id; type id[num]; type id; type id; type *id; type *id; type id; type *id;`\n- **Candidate B**: `type id; type *id; type *id; type *id; type *id; type *id; type *id; type id; type *id; type *id; type id; type id; type id; type *id; type id[num]; type id; type id; type *id; type *id; type id; type *id;` (identical)\n\nBoth candidates have the same variable initialization structure, but the order of the variables is different. However, this difference is not significant enough to make a judgment.\n\n### DIFFERENCE 14: Control flow structure\n\n- **Candidate A**: `for(id = id;  (id!= id || (id == id)); id = id op num){... }`\n- **Candidate B**: `for(id = id;  (id!= id || (id == id)); id = id op num){... }` (identical)\n\nBoth candidates have the same control flow structure, but the condition in the `for` loop is identical in both candidates.\n\n### DIFFERENCE 15: Function call\n\n- **Candidate A**: `call(id, num, str, id op num, id op num, id);`\n- **Candidate B**: `call(id, num, str, id op num, id op num, id);` (identical)\n\nBoth candidates have the same function call structure, but the order of the arguments is different. However, this difference is not significant enough to make a judgment.\n\n### DIFFERENCE 16: Variable usage\n\n- **Candidate A**: `id = num; id = id op id; id = num; id = num; id = num;`\n- **Candidate B**: `id = num; id = id op id; id = num; id = num; id = num;` (identical)\n\nBoth candidates have the same variable usage structure, but the order of the assignments is different. However, this difference is not significant enough to make a judgment.\n\n### DIFFERENCE 17: Control flow nesting\n\n- **Candidate A**: `if(id == id){... } else {... }`\n- **Candidate B**: `if(id == id){... } else {... }` (identical)\n\nBoth candidates have the same control flow nesting structure, but the order of the conditions is different. However, this difference is not significant enough to make a judgment.\n\n### DIFFERENCE 18: Variable initialization\n\n- **Candidate A**: `type id; type *id; type *id; type *id; type *id; type *id; type *id; type id; type *id; type *id; type id; type id; type id; type *id; type id[num]; type id; type id; type *id; type *id; type id; type *id;`\n- **Candidate B**: `type id; type *id; type *id; type *id; type *id; type *id; type"
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "Both candidates have the same complexity in their loop conditions, but they also introduce an unnecessary label lbl after the for loop."
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O2.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id, type id, type id){\n  type id;\n  call(call(id, &id));\n  type id[id op num];\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.28125,
          "base_ppl": 2.15625,
          "pr_ppl": 2.15625,
          "source_ast_ppl": 3.65625,
          "base_ast_ppl": 2.875,
          "pr_ast_ppl": 2.84375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "PR",
          "motivation": "Candidate B's use of a `do-while` loop makes it more intuitive and easier to follow, aligning with human-readable coding standards."
        },
        "llm_qualitative_source": {
          "winner": "BASE",
          "motivation": "Both candidates deviate from the original source structure, but Candidate A preserves the original logic patterns, including the use of `do-while` loops and the `goto` statement, making it more faithful to the human intent."
        },
        "llm_ast": {
          "winner": "BASE",
          "motivation": "Candidate A avoids introducing additional operations, making the code more readable and maintainable."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O3.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id, type id, type id){\n  type id;\n  call(call(id, &id));\n  type id[id op num];\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.28125,
          "base_ppl": 2.15625,
          "pr_ppl": 2.15625,
          "source_ast_ppl": 3.65625,
          "base_ast_ppl": 2.875,
          "pr_ast_ppl": 2.84375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "PR",
          "motivation": "Candidate A's use of a do-while loop with a conditional break makes the code harder to read and understand, whereas Candidate B's traditional for loop is more straightforward and easier to follow."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "Candidate A and B both transform the Source's high-level `for` loop into a low-level `do-while` loop with a `goto` statement. However, the Source's `for` loop is more abstract and easier to understand. Candidate A and B's use of `goto` degrades the structure and makes it harder to understand."
        }
      },
      {
        "binary": "task-file_file_printable-O2.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, , *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.921875,
          "base_ppl": 2.578125,
          "pr_ppl": 2.546875,
          "source_ast_ppl": 7.15625,
          "base_ast_ppl": 5.5625,
          "pr_ast_ppl": 5.5,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "Candidate B clearly conveys the intended logic with a more explicit structure."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-file_file_printable-O3.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, , *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.921875,
          "base_ppl": 2.578125,
          "pr_ppl": 2.546875,
          "source_ast_ppl": 7.15625,
          "base_ast_ppl": 5.5625,
          "pr_ast_ppl": 5.5,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-file_strlcpy-O0.so",
        "function": "strlcpy",
        "source_code": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0 && --n != 0) {\n\t\tdo {\n\t\t\tif ((*d++ = *s++) == 0)\n\t\t\t\tbreak;\n\t\t} while (--n != 0);\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}\n",
        "function_base": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 + -1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + (-1 - (long)param_2);\n}\n\n",
        "function_pr": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 - 1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + -(long)param_2 + -1;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type id){\n  type *id = id;\n  type *id = id;\n  type id = id;\n  if(id != num && upd id != num){\n    do{\n      if((*id upd = *id upd) == num)break;\n    }while(upd id != num);\n  }\n  if(id == num){\n    if(id != num)*id = str;\n    while(*id upd);\n  }\n  return (id op id op num);\n}",
        "base_ast": "type *id(type *id, type *id,  id){\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op (num op (type)id);\n}",
        "pr_ast": "type *id(type *id, type *id,  id){\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op -(type)id op num;\n}",
        "metrics": {
          "source_ppl": 1.8046875,
          "base_ppl": 2.015625,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 10.125,
          "base_ast_ppl": 3.78125,
          "pr_ast_ppl": 3.75,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "BASE",
          "motivation": "Candidate A maintains the original control flow structure, including the use of do-while loops, which is a key aspect of the human-written code."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-file_file_printable-O0.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + param_3 + -1) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + param_3 + -4 <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + (param_3 - 1)) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + (param_3 - 4) <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, , *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op id op num) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op id op num <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op (id op num)) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op (id op num) <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.921875,
          "base_ppl": 2.5625,
          "pr_ppl": 2.546875,
          "source_ast_ppl": 7.15625,
          "base_ast_ppl": 5.5625,
          "pr_ast_ppl": 5.5625,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "Consistent use of parentheses reduces cognitive load and improves code readability."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      }
    ],
    "gemma2": [
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 1.75,
          "pr_ppl": 1.75,
          "source_ast_ppl": 2.171875,
          "base_ast_ppl": 2.046875,
          "pr_ast_ppl": 2.046875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "Error",
          "motivation": "```\n\nThe `if`\n```\n\n\n\n```\n\n```\n```\n\n```\n\n\n\n```\n\n```\n```\n\n\n\n```\n```\n```\n\n\n\n```\n```\n```\n\n\n\n```\n```\n```\n\n\n\n```\n\n\n\n```\n```\n```\n```\n```\n```\n\n\n\n```\n\n\n\n```\n```\n```\n\n\n\n```\n```\n\n\n\n```\n\n\n\n```\n\n\n\n```\n```\n```\n\n\n\n```\n\n\n\n```\n```\n```\n```\n```\n```\n\n\n\n```\n```\n```\n```\n```\n\n\n\n```\n```\n```\n\n\n\n`\n```\n`\n\n```\n\n\n\n```\n\n\n\n```\n\n\n\n`\n```\n\n\n\n```\n```\n```\n\n\n\n```\n\n\n\n`\n```\n\n\n\n`\n`\n`\n\n\n\n`\n`\n\n\n\n`\n`\n`\n\n\n\n`\n`\n\n\n\n`\n`\n\n\n\n`\n`\n`\n```\n`\n`\n\n\n\n`\n```\n\n\n\n`\n```\n`\n```\n`\n```\n```\n`\n\n\n\n`\n\n\n\n`\n`\n`\n`\n```\n`\n`\n```\n```\n`\n```\n\n\n\n`\n`\n`\n`\n```\n\n\n\n`\n`\n`\n`\n`\n```\n``\n```\n`\n`\n```\n`\n`\n````\n`\n```\n`\n`\n`\n`\n`\n```\n`\n```\n`\n`\n```\n`\n`\n```\n`\n```\n```\n`\n`\n`\n`\n`\n`\n```\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n``\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n``\n`\n`\n`\n`\n``\n`\n``\n``\n``\n``\n``\n``\n``\n``\n`\n``\n``\n`\n`\n`\n`\n``\n`\n`\n``\n``\n`\n`\n``\n`\n`\n``\n`\n`\n`\n`\n`\n`\n`\n`\n``\n``\n`\n`\n`\n`\n`\n``\n``\n`\n`\n`\n`\n`\n`\n`\n`\n``\n`\n`\n`\n`\n`\n``\n`\n`\n`\n`\n`\n`\n`\n`\n``\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n``\n``\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n``\n``\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n``\n`\n``\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n`\n"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + ((ulong)uVar9 * 2 - 2);\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 - 1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 - 1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  type id[num];\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op id;\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)str[id op num]str[id op num] != str)){\n        id = str op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id op -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, str, id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] op num];\n  if(str[(type)(type)id[id] op num] != str){\n    id = str op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == str){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, str, id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, str, id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 1.75,
          "pr_ppl": 1.75,
          "source_ast_ppl": 2.171875,
          "base_ast_ppl": 2.046875,
          "pr_ast_ppl": 2.046875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "Error",
          "motivation": "`\n```\n\nThe code is not a good idea, but it is not the best.\n```\n\nThe code is not a good idea.\n\n\n\n\n```\n```\n\n```\n```\n\n```\n```\n\n```\n```\n\n```\n```\n\n```\n\n\n\n```\n```\n\n```\n```\n\n\n\n```\n```\n```\n\n\n\n```\n```\n\n\n\n```\n```\n\n\n\n```\n\n\n\n```\n```\n```\n\n```\n```\n```\n\n\n\n```\n\n\n\n```\n\n\n\n```\n\n\n\n```\n\n```\n\n\n\n`\n```\n\n\n\n`\n`\n\n\n\n`\n\n\n\n`\n`\n\n```\n\n```\n\n```\n```\n\n\n\n`\n\n```\n`\n\n```\n\n\n\n`\n\n```\n\n\n\n```\n\n\n\n```\n\n\n\n`\n\n\n\n`\n\n\n\n```\n```\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n``\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n``\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n``\n\n\n\n``\n\n\n\n`\n\n\n\n``\n\n``\n\n\n\n``\n\n\n\n`\n\n\n\n`\n\n\n\n`\n\n\n\n``\n\n\n\n``\n\n\n\n``\n\n\n\n``\n\n\n\n``\n\n\n\n``\n\n\n\n``\n\n\n\n`\n\n\n\n``\n\n\n\n```\n\n``\n\n\n\n``\n\n\n\n````\n\n\n\n```\n\n\n\n```\n\n\n\n```\n\n\n\n```\n\n\n\n```\n\n\n\n````\n\n```\n\n\n\n````\n\n\n````\n\n\n\n````\n\n```\n\n\n\n````\n\n\n\n```\n\n\n\n````\n\n\n\n````\n\n\n\n````\n\n\n\n```\n\n\n\n````\n\n```````\n\n\n\n```````\n\n\n\n```````\n\n\n\n````````\n```````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````` ` ```````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````` ` ``````````````````````````````` ````````````` ` `` ` `````` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` `"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8515625,
          "base_ppl": 1.875,
          "pr_ppl": 1.875,
          "source_ast_ppl": 2.390625,
          "base_ast_ppl": 2.109375,
          "pr_ast_ppl": 2.109375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 * 2 - 2);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 - 1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 - 1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), str, (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8515625,
          "base_ppl": 1.8828125,
          "pr_ppl": 1.8828125,
          "source_ast_ppl": 2.390625,
          "base_ast_ppl": 2.109375,
          "pr_ast_ppl": 2.109375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + ((long)iVar7 - 1);\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + ((long)(iVar7 << 1) - 2);\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 - 1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c - 1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num];\n  type id[num op num];\n  type *id = null;\n  type id = num;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type *id;\n  type id[num];\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  type id;\n  type *id;\n  type id[num];\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, str, id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, str, id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, str, id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == str){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, str, (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 1.734375,
          "pr_ppl": 1.734375,
          "source_ast_ppl": 2.171875,
          "base_ast_ppl": 1.953125,
          "pr_ast_ppl": 1.953125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "Error",
          "motivation": "```\n\n**Analysis:**\n\nCandidate B implements a state machine (using the `cs` variable) to navigate the `_sav_long_variable_parse_trans_indicies` table.\n\n**Human-written code would likely use a switch statement to handle the actions defined in `_sav_long_variable_parse_trans_actions`\n\n**Decompiled code:**\n\n```\nif (p == pe)\n    if (cs == 0)\n    if (p != pe)\n    if (p == eof)\n    if (table)\n    return READSTAT_ERROR_PARSE\n    return READSTAT_OK\n\n```\n\n**Analysis:**\n\n* The code attempts to parse a variable name.\n\n* The code handles the `_sav_long_variable_parse_eof_actions`\n\n* The code has a `readstat_parse_parse_actions`\n\n* The code has a `readstat_parse_actions`\n\n* The code has a `readstat_parse_actions`\n\n* The code has a `readstat_parse_actions`\n\n\n\n**Conclusion:**\n\nCandidate B is a decompiled version of a state machine.\n\n\n\n\n```\n\n**Note:** The code is complex and likely part of a larger parsing engine.\n\n**Note:** The code is not a single function.\n\n\n```\n```\n\n**Note:** The code is not a single function.\n\n\n\n\n```\n```\n\n```\n```\n\n\n\n\n```,\n```\n\n\n\n**Note:**\n\n\n\n\n```\n\n```\n\n\n\n\n```\n```\n,\n```\n\n```\n\n```\n```\n```\n\n```\n```\n\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + ((long)iVar7 - 1);\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + ((long)(iVar7 << 1) - 2);\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc - 1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c - 1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[num op num op num];\n  type id = num;\n  type *id = null;\n  type id = num;\n  type id = num op id;\n  type *id = null;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type *id;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, , *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != str){\n            type id = (*id) op str;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, , *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op ((type)id op num);\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op ((type)(id op num) op num);\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, str, (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8515625,
          "base_ppl": 1.71875,
          "pr_ppl": 1.71875,
          "source_ast_ppl": 2.390625,
          "base_ast_ppl": 1.9453125,
          "pr_ast_ppl": 1.9453125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.4921875,
          "base_ppl": 2.25,
          "pr_ppl": 2.234375,
          "source_ast_ppl": 2.046875,
          "base_ast_ppl": 2.3125,
          "pr_ast_ppl": 2.3125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 * 2 - 2);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = ((int)*pcVar12 + iVar16 * 10) - 0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = ((type)*id op id op num) op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if((id != id) || (id = numid < str)){\n        if(id != (type)num){\n          call(id, num, str, id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.4921875,
          "base_ppl": 2.25,
          "pr_ppl": 2.234375,
          "source_ast_ppl": 2.046875,
          "base_ast_ppl": 2.3125,
          "pr_ast_ppl": 2.3125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "PR",
          "motivation": "Candidate B's use of standard constructs like `for` loops and struct members makes it significantly easier to read and understand."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.5703125,
          "base_ppl": 2.171875,
          "pr_ppl": 2.171875,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 2.421875,
          "pr_ast_ppl": 2.421875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + ((ulong)uVar12 * 2 - 2);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != str)){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == str)){\n      if(((id != id) || (id = numid < str)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.5703125,
          "base_ppl": 2.171875,
          "pr_ppl": 2.171875,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 2.421875,
          "pr_ast_ppl": 2.421875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.234375,
          "base_ppl": 1.890625,
          "pr_ppl": 1.84375,
          "source_ast_ppl": 5.1875,
          "base_ast_ppl": 2.609375,
          "pr_ast_ppl": 2.671875,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < (ulong)(lVar7 - 0x4000000000000001U)) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < call(id op num))goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.234375,
          "base_ppl": 1.890625,
          "pr_ppl": 1.84375,
          "source_ast_ppl": 5.1875,
          "base_ast_ppl": 2.609375,
          "pr_ast_ppl": 2.671875,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + ((long)iVar2 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar2 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 - 0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op str);\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = *id op num;\n            if((num < id) && (id < str)){\n              id = id op num op (type)id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.5703125,
          "base_ppl": 1.8671875,
          "pr_ppl": 1.859375,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 2.15625,
          "pr_ast_ppl": 2.15625,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "PR",
          "motivation": "While both candidates deviate from the Source's structure, Candidate B's `for` loop, despite its always-true condition, more closely mirrors the nested logic of the Source's `if` and `while` statements. Candidate A's loop, with its always-true condition, becomes a runaway loop that doesn't adhere to the Source's intended control flow."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + ((long)local_5c - 1);\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + ((long)(local_5c << 1) - 2);\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 - 1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + ((int)*local_40 - 0x30U);\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 - 0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type id[num];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type id;\n  type id[num];\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(num < *(type)(id op (type)id op num)){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = str op (type)(type)id[id];\n      id = (id) op (type)(id op (type)id op num);\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id = idid <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.4921875,
          "base_ppl": 1.984375,
          "pr_ppl": 1.9921875,
          "source_ast_ppl": 2.046875,
          "base_ast_ppl": 2.140625,
          "pr_ast_ppl": 2.140625,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.578125,
          "base_ppl": 2.0,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 3.0625,
          "base_ast_ppl": 2.390625,
          "pr_ast_ppl": 2.40625,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "PR",
          "motivation": "While both candidates simplify the Source AST, Candidate B is slightly closer to the Source's architectural intent due to its more faithful representation of the nested `if-else` blocks. Although both candidates introduce `goto` statements and simplify the `switch` statement, B's handling of the nested logic is less disruptive to the overall structure."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if ((ulong)(*(long *)(param_1 + 0x48) - 0x7ffffffffffffffdU) < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 - 1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(call(*(type)(id op num) op num) < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != str){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.578125,
          "base_ppl": 2.015625,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 3.0625,
          "base_ast_ppl": 2.421875,
          "pr_ast_ppl": 2.421875,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "BASE",
          "motivation": "While Candidate B makes some minor optimizations, the core structure remains largely the same.  The human-like quality comes from the use of `for` loops, `do-while` loops, and `switch` statements, which are all constructs that map well to common programming patterns."
        },
        "llm_ast_source": {
          "winner": "BASE",
          "motivation": "While both candidates have significant structural issues, Candidate A is slightly closer to the Source's intent in preserving the overall flow of the code. It maintains a more recognizable hierarchy of control structures, even though it introduces some unnecessary loops. Candidate B's changes are more disruptive and introduce a greater degree of complexity."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 2.171875,
          "pr_ppl": 2.140625,
          "source_ast_ppl": 2.59375,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.671875,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 * 2 - 2);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = ((int)*pcVar8 + iVar16 * 10) - 0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = (int)*pcVar8 - 0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = ((type)*id op id op num) op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = (type)*id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, str, id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 2.171875,
          "pr_ppl": 2.140625,
          "source_ast_ppl": 2.59375,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.671875,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O0.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + (long)iVar1 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar1 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + *local_2040 + -0x30;\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = *local_2040 + -0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  int *local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar2 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar2 || (local_2040 == pcVar2));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar2) {\n      if ('\\0' < (char)_sav_time_parse_eof_trans[local_2054]) {\n        local_2060 = (int)(char)_sav_time_parse_eof_trans[local_2054] - 1;\n      }\n    }\n    else {\n      local_2068 = _sav_time_parse_trans_keys + (int)(char)_sav_time_parse_key_offsets[local_2054];\n      local_2060 = (uint)(char)_sav_time_parse_index_offsets[local_2054];\n      iVar1 = (int)(char)_sav_time_parse_single_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2088 = local_2068 + ((long)iVar1 - 1);\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar3 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar3) {\n            local_2088 = pcVar3 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar3) {\n              local_2060 = ((int)pcVar3 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar3 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar1;\n        local_2060 = iVar1 + local_2060;\n      }\n      iVar1 = (int)(char)_sav_time_parse_range_lengths[local_2054];\n      if (0 < iVar1) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + ((long)(iVar1 << 1) - 2);\n        while (local_2098 <= local_20a0) {\n          pcVar3 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar3) {\n            local_20a0 = pcVar3 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar3[1]) {\n              iVar1 = (int)((long)pcVar3 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar3 + 2;\n          }\n        }\n        local_2060 = iVar1 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_time_parse_cond_targs[local_2060];\n    if (_sav_time_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_time_parse_actions +\n                   (long)(int)(char)_sav_time_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_time_parse_actions\n                                   [(int)(char)_sav_time_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 - 1) {\n        switch(*local_2070) {\n        case 0:\n          local_2058 = local_2058 * 10 + ((int)*local_2040 - 0x30U);\n          break;\n        case 1:\n          local_2058 = 0;\n          break;\n        case 2:\n          local_2058 = (int)*local_2040 - 0x30;\n          break;\n        case 3:\n          param_3[2] = local_2058;\n          break;\n        case 4:\n          param_3[1] = local_2058;\n          break;\n        case 5:\n          *param_3 = local_2058;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar2) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0xc) || (local_2040 != pcVar2)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[num];\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type *id;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op str);\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op str;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op (type)id op num;\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op (type)(id op num) op num;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op *id op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = *id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id[num];\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  id = num;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  for(id = id;  (id != id || (id == id)); id = id op num){\n    if(id == id){\n      if(str < (type)id[id]){\n        id = (type)(type)id[id] op num;\n      }\n    }else{\n      id = id op (type)(type)id[id];\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id op ((type)id op num);\n        id = id;\n        while(id <= id){\n          id = id op ((type)id op (type)id op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= *id){\n              id = ((type)id op (type)id) op id;\n              goto lbl;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if(num < id){\n        id = id;\n        id = id op ((type)(id op num) op num);\n        while(id <= id){\n          id = id op ((type)id op (type)id op num op num);\n          if(*id < *id){\n            id = id op num;\n          }else{\n            if(*id <= id[num]){\n              id = (type)((type)id op (type)id op num);\n              break;\n            }\n            id = id op num;\n          }\n        }\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = id op (type)(type)(type)id[id] op num;\n      for(id = (type)(type)id[(type)(type)id[id]];  id != num; id = id op num){\n        switch(*id){\n          case num:\n            id = id op num op ((type)*id op num);\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            id = (type)*id op num;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            id[num] = id;\n            break;\n          case num:\n            *id = id;\n        }\n        id = id op num;\n      }\n    }\n    if((id == id) || (id == num))break;\n  }\n  if((id < num) || (id != id)){\n    if(id != (type)num){\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      id = id;\n      call(id, num, str, id op num, id op num, id);\n      call(id, id);\n    }\n    id = num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 1.7421875,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 2.59375,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.46875,
          "delta_ppl": 0.0234375
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O2.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id, type id, type id){\n  type id;\n  call(call(id, &id));\n  type id[id op num];\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.578125,
          "base_ppl": 1.8359375,
          "pr_ppl": 1.8203125,
          "source_ast_ppl": 3.15625,
          "base_ast_ppl": 2.546875,
          "pr_ast_ppl": 2.546875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_raw_coder_init-O3.so",
        "function": "lzma_raw_coder_init",
        "source_code": "extern lzma_ret\nlzma_raw_coder_init(lzma_next_coder *next, const lzma_allocator *allocator,\n\t\tconst lzma_filter *options,\n\t\tlzma_filter_find coder_find, bool is_encoder)\n{\n\t// Do some basic validation and get the number of filters.\n\tsize_t count;\n\treturn_if_error(lzma_validate_chain(options, &count));\n\n\t// Set the filter functions and copy the options pointer.\n\tlzma_filter_info filters[LZMA_FILTERS_MAX + 1];\n\tif (is_encoder) {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t// The order of the filters is reversed in the\n\t\t\t// encoder. It allows more efficient handling\n\t\t\t// of the uncompressed data.\n\t\t\tconst size_t j = count - i - 1;\n\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[j].id = options[i].id;\n\t\t\tfilters[j].init = fc->init;\n\t\t\tfilters[j].options = options[i].options;\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\tconst lzma_filter_coder *const fc\n\t\t\t\t\t= coder_find(options[i].id);\n\t\t\tif (fc == NULL || fc->init == NULL)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t\tfilters[i].id = options[i].id;\n\t\t\tfilters[i].init = fc->init;\n\t\t\tfilters[i].options = options[i].options;\n\t\t}\n\t}\n\n\t// Terminate the array.\n\tfilters[count].id = LZMA_VLI_UNKNOWN;\n\tfilters[count].init = NULL;\n\n\t// Initialize the filters.\n\tconst lzma_ret ret = lzma_next_filter_init(next, allocator, filters);\n\tif (ret != LZMA_OK)\n\t\tlzma_next_end(next, allocator);\n\n\treturn ret;\n}\n",
        "function_base": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 + -1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + local_b0 * 3 + -1;\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 + -1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "function_pr": "\nulong lzma_raw_coder_init(undefined8 param_1,undefined8 param_2,undefined8 *param_3,code *param_4,\n                         char param_5)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long local_b0;\n  undefined8 local_a8 [15];\n  \n  uVar2 = lzma_validate_chain(param_3,&local_b0);\n  if ((int)uVar2 != 0) {\n    return uVar2;\n  }\n  if (param_5 == '\\0') {\n    if (local_b0 != 0) {\n      puVar4 = local_a8 + 2;\n      lVar5 = local_b0;\n      do {\n        lVar3 = (*param_4)(*param_3);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        lVar3 = *(long *)(lVar3 + 8);\n        if (lVar3 == 0) {\n          return 8;\n        }\n        puVar4[-2] = *param_3;\n        puVar4[-1] = lVar3;\n        *puVar4 = param_3[1];\n        puVar4 = puVar4 + 3;\n        param_3 = param_3 + 2;\n        lVar5 = lVar5 - 1;\n      } while (lVar5 != 0);\n      goto LAB_001012ff;\n    }\n  }\n  else if (local_b0 != 0) {\n    puVar4 = local_a8 + (local_b0 * 3 - 1);\n    lVar5 = local_b0;\n    do {\n      lVar3 = (*param_4)(*param_3);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 8;\n      }\n      puVar4[-2] = *param_3;\n      puVar4[-1] = lVar3;\n      *puVar4 = param_3[1];\n      param_3 = param_3 + 2;\n      puVar4 = puVar4 + -3;\n      lVar5 = lVar5 - 1;\n    } while (lVar5 != 0);\n    goto LAB_001012ff;\n  }\n  local_b0 = 0;\nLAB_001012ff:\n  local_a8[local_b0 * 3] = 0xffffffffffffffff;\n  local_a8[local_b0 * 3 + 1] = 0;\n  uVar1 = lzma_next_filter_init(param_1,param_2,local_a8);\n  if (uVar1 == 0) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = (ulong)uVar1;\n    lzma_next_end(param_1,param_2);\n  }\n  return uVar2;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id, type id, type id){\n  type id;\n  call(call(id, &id));\n  type id[id op num];\n  if(id){\n    for(type id = num; id < id; upd id){\n      type id = id op id op num;\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }else{\n    for(type id = num; id < id; upd id){\n      type *id = call(id[id].id);\n      if(id == null || id->id == null)return id;\n      id[id].id = id[id].id;\n      id[id].id = id->id;\n      id[id].id = id[id].id;\n    }\n  }\n  id[id].id = id;\n  id[id].id = null;\n  type id = call(id, id, id);\n  if(id != id)call(id, id);\n  return id;\n}",
        "base_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op id op num op num;\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type id, type id, type *id, type *id, type id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[num];\n  id = call(id, &id);\n  if((type)id != num){\n    return id;\n  }\n  if(id == str){\n    if(id != num){\n      id = id op num;\n      id = id;\n      do{\n        id = call(*id);\n        if(id == num){\n          return num;\n        }\n        id = *(type)(id op num);\n        if(id == num){\n          return num;\n        }\n        id[num] = *id;\n        id[num] = id;\n        *id = id[num];\n        id = id op num;\n        id = id op num;\n        id = id op num;\n      }while(id != num);\n      goto lbl;\n    }\n  }elseif(id != num){\n    id = id op (id op num op num);\n    id = id;\n    do{\n      id = call(*id);\n      if(id == num){\n        return num;\n      }\n      id = *(type)(id op num);\n      if(id == num){\n        return num;\n      }\n      id[num] = *id;\n      id[num] = id;\n      *id = id[num];\n      id = id op num;\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    goto lbl;\n  }\n  id = num;\n  lbl:\n  id[id op num] = num;\n  id[id op num op num] = num;\n  id = call(id, id, id);\n  if(id == num){\n    id = num;\n  }else{\n    id = (type)id;\n    call(id, id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.578125,
          "base_ppl": 1.8359375,
          "pr_ppl": 1.8203125,
          "source_ast_ppl": 3.15625,
          "base_ast_ppl": 2.546875,
          "pr_ast_ppl": 2.546875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-file_file_printable-O2.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, , *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.40625,
          "pr_ppl": 2.375,
          "source_ast_ppl": 6.71875,
          "base_ast_ppl": 5.03125,
          "pr_ast_ppl": 4.9375,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-file_file_printable-O3.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + param_3 + -1) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + param_3 + -4 <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + param_3 + -1 <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  pbVar4 = param_2;\n  if ((param_2 < param_2 + (param_3 - 1)) && (0 < param_5)) {\n    pbVar2 = param_4;\n    while( true ) {\n      pbVar5 = pbVar2 + 1;\n      bVar1 = *pbVar2;\n      if ((ulong)bVar1 == 0) break;\n      if (((*(byte *)(param_1 + 0x45) & 1) == 0) &&\n         (ppuVar3 = __ctype_b_loc(), (*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x40) == 0)\n         ) {\n        if (param_2 + (param_3 - 4) <= pbVar4) break;\n        *pbVar4 = 0x5c;\n        pbVar4[1] = *pbVar2 >> 6 | 0x30;\n        pbVar4[2] = *pbVar2 >> 3 & 7 | 0x30;\n        pbVar4[3] = *pbVar2 & 7 | 0x30;\n        pbVar4 = pbVar4 + 4;\n      }\n      else {\n        *pbVar4 = bVar1;\n        pbVar4 = pbVar4 + 1;\n      }\n      if ((param_2 + (param_3 - 1) <= pbVar4) || (pbVar2 = pbVar5, param_4 + param_5 <= pbVar5))\n      break;\n    }\n  }\n  *pbVar4 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, , *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op id op num) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op id op num <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op id op num <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type id;\n  type *id;\n  type **id;\n  type *id;\n  type *id;\n  id = id;\n  if((id < id op (id op num)) && (num < id)){\n    id = id;\n    while(bool){\n      id = id op num;\n      id = *id;\n      if((type)id == num)break;\n      if(((*(type)(id op num) op num) == num) && (id = call()(*(type)((type)*id op (type)id op num op num) op num) == num)){\n        if(id op (id op num) <= id)break;\n        *id = num;\n        id[num] = *id op num op num;\n        id[num] = *id op num op num op num;\n        id[num] = *id op num op num;\n        id = id op num;\n      }else{\n        *id = id;\n        id = id op num;\n      }\n      if((id op (id op num) <= id) || (id = idid op id <= id))break;\n    }\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.40625,
          "pr_ppl": 2.375,
          "source_ast_ppl": 6.71875,
          "base_ast_ppl": 5.03125,
          "pr_ast_ppl": 4.9375,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "PR",
          "motivation": "Candidate B's loop conditions are easier to follow due to the use of `param_3 - 1` instead of `param_3 + -1`."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-file_strlcpy-O0.so",
        "function": "strlcpy",
        "source_code": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0 && --n != 0) {\n\t\tdo {\n\t\t\tif ((*d++ = *s++) == 0)\n\t\t\t\tbreak;\n\t\t} while (--n != 0);\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}\n",
        "function_base": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 + -1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + (-1 - (long)param_2);\n}\n\n",
        "function_pr": "\nchar * strlcpy(char *param_1,char *param_2,long param_3)\n\n{\n  char cVar1;\n  char *pcVar2;\n  long local_38;\n  char *local_30;\n  char *local_28;\n  \n  local_38 = param_3;\n  local_30 = param_2;\n  local_28 = param_1;\n  pcVar2 = param_2;\n  if (param_3 != 0) {\n    do {\n      local_38 = local_38 - 1;\n      local_30 = pcVar2;\n      local_28 = param_1;\n      if (local_38 == 0) break;\n      local_30 = pcVar2 + 1;\n      cVar1 = *pcVar2;\n      local_28 = param_1 + 1;\n      *param_1 = cVar1;\n      param_1 = local_28;\n      pcVar2 = local_30;\n    } while (cVar1 != '\\0');\n  }\n  if (local_38 == 0) {\n    if (param_3 != 0) {\n      *local_28 = '\\0';\n    }\n    do {\n      pcVar2 = local_30 + 1;\n      cVar1 = *local_30;\n      local_30 = pcVar2;\n    } while (cVar1 != '\\0');\n  }\n  return local_30 + -(long)param_2 + -1;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type id){\n  type *id = id;\n  type *id = id;\n  type id = id;\n  if(id != num && upd id != num){\n    do{\n      if((*id upd = *id upd) == num)break;\n    }while(upd id != num);\n  }\n  if(id == num){\n    if(id != num)*id = str;\n    while(*id upd);\n  }\n  return (id op id op num);\n}",
        "base_ast": "type *id(type *id, type *id,  id){\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op (num op (type)id);\n}",
        "pr_ast": "type *id(type *id, type *id,  id){\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  if(id != num){\n    do{\n      id = id op num;\n      id = id;\n      id = id;\n      if(id == num)break;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      *id = id;\n      id = id;\n      id = id;\n    }while(id != str);\n  }\n  if(id == num){\n    if(id != num){\n      *id = str;\n    }\n    do{\n      id = id op num;\n      id = *id;\n      id = id;\n    }while(id != str);\n  }\n  return id op -(type)id op num;\n}",
        "metrics": {
          "source_ppl": 2.25,
          "base_ppl": 1.7578125,
          "pr_ppl": 1.7578125,
          "source_ast_ppl": 9.3125,
          "base_ast_ppl": 3.234375,
          "pr_ast_ppl": 3.234375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response (Position Bias); declaring TIE."
        }
      },
      {
        "binary": "task-file_file_printable-O0.so",
        "function": "file_printable",
        "source_code": "file_protected char *\nfile_printable(struct magic_set *ms, char *buf, size_t bufsiz,\n    const char *str, size_t slen)\n{\n\tchar *ptr, *eptr = buf + bufsiz - 1;\n\tconst unsigned char *s = RCAST(const unsigned char *, str);\n\tconst unsigned char *es = s + slen;\n\n\tfor (ptr = buf;  ptr < eptr && s < es && *s; s++) {\n\t\tif ((ms->flags & MAGIC_RAW) != 0 || isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr - 3)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 6) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 3) & 7) + '0';\n\t\t*ptr++ = ((CAST(unsigned int, *s) >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}\n",
        "function_base": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + param_3 + -1) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + param_3 + -4 <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "function_pr": "\nbyte * file_printable(long param_1,byte *param_2,long param_3,byte *param_4,long param_5)\n\n{\n  ushort **ppuVar1;\n  byte *pbVar2;\n  bool bVar3;\n  byte *local_48;\n  byte *local_38;\n  \n  local_48 = param_4;\n  local_38 = param_2;\n  while( true ) {\n    bVar3 = false;\n    if ((local_38 < param_2 + (param_3 - 1)) && (bVar3 = false, local_48 < param_4 + param_5)) {\n      bVar3 = *local_48 != 0;\n    }\n    if (!bVar3) break;\n    if (((*(uint *)(param_1 + 0x44) & 0x100) == 0) &&\n       (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(int)(uint)*local_48] & 0x4000) == 0)) {\n      if (param_2 + (param_3 - 4) <= local_38) break;\n      *local_38 = 0x5c;\n      local_38[1] = (*local_48 >> 6) + 0x30;\n      pbVar2 = local_38 + 3;\n      local_38[2] = (*local_48 >> 3 & 7) + 0x30;\n      local_38 = local_38 + 4;\n      *pbVar2 = (*local_48 & 7) + 0x30;\n    }\n    else {\n      *local_38 = *local_48;\n      local_38 = local_38 + 1;\n    }\n    local_48 = local_48 + 1;\n  }\n  *local_38 = 0;\n  return param_2;\n}\n\n",
        "source_ast": "type *id(type *id, type *id, type id, type *id, type id){\n  type *id, , *id = id op id op num;\n  type *id = call(id op id);\n  type *id = id op id;\n  for(id = id;  id < id && id < id && *id; id upd){\n    if((id->id op id) != num || call(*id)){\n      *id upd = *id;\n      continue;\n    }\n    if(id >= id op num)break;\n    *id upd = str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n    *id upd = ((type)&num) op str;\n  }\n  *id = str;\n  return id;\n}",
        "base_ast": "type *id( id, type *id,  id, type *id,  id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op id op num) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op id op num <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "pr_ast": "type *id( id, type *id,  id, type *id,  id){\n  type **id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  id = id;\n  id = id;\n  while(bool){\n    id = bool;\n    if((id < id op (id op num)) && (id = boolid < id op id)){\n      id = *id != num;\n    }\n    if(!id)break;\n    if(((*(type)(id op num) op num) == num) && (id = call()((*id)[(type)(id) op id] op num) == num)){\n      if(id op (id op num) <= id)break;\n      *id = num;\n      id[num] = (*id op num) op num;\n      id = id op num;\n      id[num] = (*id op num op num) op num;\n      id = id op num;\n      *id = (*id op num) op num;\n    }else{\n      *id = *id;\n      id = id op num;\n    }\n    id = id op num;\n  }\n  *id = num;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.25,
          "pr_ppl": 2.234375,
          "source_ast_ppl": 6.71875,
          "base_ast_ppl": 5.0,
          "pr_ast_ppl": 5.09375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE."
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "While both candidates exhibit structural deviations, Candidate B's changes are slightly less drastic in terms of expression complexity and variable assignments compared to Candidate A.  However, neither candidate accurately preserves the Source's `for` loop structure and its intended iteration logic."
        }
      }
    ]
  }
}